\newpage
\section{Prolog built-in predicates}
%HEVEA\cutdef[1]{subsection}
\subsection{Type testing}
\subsubsection{\IdxPBD{var/1}, \label{var/1}
               \IdxPBD{nonvar/1},
               \IdxPBD{atom/1},
               \IdxPBD{integer/1},
               \IdxPBD{float/1},
               \IdxPBD{number/1},
               \IdxPBD{atomic/1}, \\
               \IdxPBD{compound/1},
               \IdxPBD{callable/1},
               \IdxPBD{ground/1},
               \IdxPBD{is\_list/1},
               \IdxPBD{list/1}, \\
               \IdxPBD{partial\_list/1},
               \IdxPBD{list\_or\_partial\_list/1}}

\begin{TemplatesTwoCols}
var(?term)\\
nonvar(?term)\\
atom(?term)\\
integer(?term)\\
float(?term)\\
number(?term)\\
atomic(?term)\\
compound(?term)\\
callable(?term)\\
ground(?term)\\
is\_list(?term)\\
list(?term)\\
partial\_list(?term)\\
list\_or\_partial\_list(?term)

\end{TemplatesTwoCols}

\Description

\texttt{var(Term)} succeeds if \texttt{Term} is currently
uninstantiated (which therefore has not been bound to anything, except
possibly another uninstantiated variable).

\texttt{nonvar(Term)} succeeds if \texttt{Term} is currently instantiated
(opposite of \texttt{var/1}).

\texttt{atom(Term)} succeeds if \texttt{Term} is currently instantiated
to an atom.

\texttt{integer(Term)} succeeds if \texttt{Term} is currently
instantiated to an integer.

\texttt{float(Term)} succeeds if \texttt{Term} is currently instantiated
to a floating point number.

\texttt{number(Term)} succeeds if \texttt{Term} is currently instantiated
to an integer or a floating point number.

\texttt{atomic(Term)} succeeds if \texttt{Term} is currently instantiated
to an atom, an integer or a floating point number.

\texttt{compound(Term)} succeeds if \texttt{Term} is currently
instantiated to a compound term, i.e. a term of arity $>$ 0 (a list or a
structure).

\texttt{callable(Term)} succeeds if \texttt{Term} is currently
instantiated to a callable term, i.e. an atom or a compound term.

\texttt{ground(Term)} succeeds if \texttt{Term} is a ground term.

\texttt{list(Term)} succeeds if \texttt{Term} is currently instantiated
to a list, i.e. the atom \texttt{[]} (empty list) or a term with principal
functor \texttt{'.'/2} and with second argument (the tail) a list.

\texttt{is\_list(Term)} behaves like \texttt{list(Term)} (for compatibility
purpose).

\texttt{partial\_list(Term)} succeeds if \texttt{Term} is currently
instantiated to a partial list, i.e. a variable or a term whose the main
functor is \texttt{'.'/2} and the second argument (the tail) is a partial
list.

\texttt{list\_or\_partial\_list(Term)} succeeds if \texttt{Term} is
currently instantiated to a list or a partial list.

\PlErrorsNone

\Portability

\texttt{var/1}, \texttt{nonvar/1}, \texttt{atom/1}, \texttt{integer/1},
\texttt{float/1}, \texttt{number/1}, \texttt{atomic/1}, \texttt{compound/1}
\texttt{callable/1} and \texttt{ground/1} are ISO predicates.

\texttt{list/1}, \texttt{partial\_list/1} and
\texttt{list\_or\_partial\_list/1} are GNU Prolog predicates.

\subsection{Term unification}

\subsubsection{\IdxPBD{(=)/2} - Prolog unification}

\begin{TemplatesOneCol}
=(?term, ?term)

\end{TemplatesOneCol}

\Description

\texttt{Term1 = Term2} unifies \texttt{Term1} and \texttt{Term2}. No occurs
check is done, i.e. this predicate does not check if a variable is unified
with a compound term containing this variable (this can lead to an infinite
loop).

\texttt{=} is a predefined infix operator \RefSP{op/3:(Term-input/output)}.

\PlErrorsNone

\Portability

ISO predicate.

\subsubsection{\IdxPBD{unify\_with\_occurs\_check/2}}

\begin{TemplatesOneCol}
unify\_with\_occurs\_check(?term, ?term)
\end{TemplatesOneCol}

\Description

\texttt{unify\_with\_occurs\_check(Term1, Term2)} unifies \texttt{Term1} and
\texttt{Term2}. The occurs check test is done (i.e. the unification fails if
a variable is unified with a compound term containing this variable).

\PlErrorsNone

\Portability

ISO predicate.

\subsubsection{\IdxPBD{({\bs}=)/2} - not Prolog unifiable}

\begin{TemplatesOneCol}
{\bs}=(?term, ?term)
\end{TemplatesOneCol}

\Description

\texttt{Term1 {\bs}= Term2} succeeds if \texttt{Term1} and \texttt{Term2}
are not unifiable (no occurs check is done).

\texttt{{\bs}=} is a predefined infix operator \RefSP{op/3:(Term-input/output)}.

\PlErrorsNone

\Portability

ISO predicate.

\subsection{Term comparison}

\subsubsection{Standard total ordering of terms}
\label{Standard-total-ordering-of-terms}
The built-in predicates described in this section allows the user to compare
Prolog terms. Prolog terms are totally ordered according to the standard
total ordering of terms which is as follows (from the smallest term to the
greatest):

\begin{itemize}

\item variables, oldest first.

\item finite domain variables \RefSP{Finite-Domain-variables}, oldest
first.

\item floating point numbers, in numeric order.

\item integers, in numeric order.

\item atoms, in alphabetical (i.e. character code) order.

\item compound terms, ordered first by arity, then by the name of the
principal functor and by the arguments in left-to-right order.

\end{itemize}

A list is treated as a compound term (whose principal functor is
\texttt{'.'/2}).

The portability of the order of variables is not guaranteed (in the ISO
reference the order of variables is system dependent).

\subsubsection{\IdxPBD{(==)/2} - term identical, \label{(==)/2}
               \IdxPBD{({\bs}==)/2} - term not identical, \\
   \AddPBD{("@{\lt})/2} % Pb with @ in \index with HeVeA
   \AddPBD{("@={\lt})/2}
   \AddPBD{("@{\gt})/2}
   \AddPBD{("@{\gt}=)/2}
               \texttt{(@{\lt})/2} - term less than,
               \texttt{(@={\lt})/2} - term less than or equal to, \\
               \texttt{(@{\gt})/2} - term greater than,
               \texttt{(@{\gt}=)/2} - term greater than or equal to}

\begin{TemplatesTwoCols}
==(?term, ?term)\\
{\bs}==(?term, ?term) \\
@{\lt}(?term, ?term) \\
@={\lt}(?term, ?term)\\
@{\gt}(?term, ?term)\\
@{\gt}=(?term, ?term)

\end{TemplatesTwoCols}

\Description

These predicates compare two terms according to the standard total ordering
of terms \RefSP{Standard-total-ordering-of-terms}.

\texttt{Term1 == Term2} succeeds if \texttt{Term1} and \texttt{Term2} are
equal.

\texttt{Term1 {\bs}== Term2} succeeds if \texttt{Term1} and
\texttt{Term2} are different.

\texttt{Term1 @{\lt} Term2} succeeds if \texttt{Term1} is less than
\texttt{Term2}.

\texttt{Term1 @={\lt} Term2} succeeds if \texttt{Term1} is less than or
equal to \texttt{Term2}.

\texttt{Term1 @{\gt} Term2} succeeds if \texttt{Term1} is greater than
\texttt{Term2}.

\texttt{Term1 @{\gt}= Term2} succeeds if \texttt{Term1} is greater than
or equal to \texttt{Term2}.

\texttt{==}, \texttt{{\bs}==}, \texttt{@{\lt}}, \texttt{@={\lt}},
\texttt{@{\gt}} and \texttt{@{\gt}=} are predefined infix operators \RefSP{op/3:(Term-input/output)}.

\PlErrorsNone

\Portability

ISO predicates.

\subsubsection{\IdxPBD{compare/3} \label{compare/3}}

\begin{TemplatesOneCol}
compare(?atom, +term, +term)

\end{TemplatesOneCol}

\Description

\texttt{compare(Order, Term1, Term2)} compares \texttt{Term1} and
\texttt{Term2} according to the standard \RefSP{Standard-total-ordering-of-terms} and unifies \texttt{Order} with:

\begin{itemize}

\item the atom \texttt{{\lt}} if \texttt{Term1} is less than \texttt{Term2}.

\item the atom \texttt{=} if \texttt{Term1} and \texttt{Term2} are equal.

\item the atom \texttt{{\gt}} if \texttt{Term1} is greater than
\texttt{Term2}.

\end{itemize}

\begin{PlErrors}

\ErrCond{\texttt{Order} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Order)}

\ErrCond{\texttt{Order} is an atom but not \texttt{{\lt}}, \texttt{=} or \texttt{{\gt}}}
\ErrTerm{domain\_error(order, Order)}

\end{PlErrors}

\Portability

ISO predicate.

\subsection{Term processing}

\subsubsection{\IdxPBD{functor/3} \label{functor/3}}

\begin{TemplatesOneCol}
functor(+nonvar, ?atomic, ?integer)\\
functor(-nonvar, +atomic, +integer)

\end{TemplatesOneCol}

\Description

\texttt{functor(Term, Name, Arity)} succeeds if the principal functor of
\texttt{Term} is \texttt{Name} and its arity is \texttt{Arity}. This
predicate can be used in two ways:

\begin{itemize}

\item \texttt{Term} is not a variable: extract the name (an atom or a number
if \texttt{Term} is a number) and the arity of \texttt{Term} (if
\texttt{Term} is atomic \texttt{Arity} = 0).

\item \texttt{Term} is a variable: unify \texttt{Term} with a general term
whose principal functor is given by \texttt{Name} and arity is given by
\texttt{Arity}.

\end{itemize}

\begin{PlErrors}

\ErrCond{\texttt{Term} and \texttt{Name} are both variables}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Term} and \texttt{Arity} are both variables}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Term} is a variable and \texttt{Name} is neither a variable
nor an atomic term}
\ErrTerm{type\_error(atomic, Name)}

\ErrCond{\texttt{Term} is a variable and \texttt{Arity} is neither a
variable nor an integer}
\ErrTerm{type\_error(integer, Arity)}

\ErrCond{\texttt{Term} is a variable, \texttt{Name} is a constant but not an
atom and \texttt{Arity} is an integer $>$ 0}
\ErrTerm{type\_error(atom, Name)}

\ErrCond{\texttt{Term} is a variable and \texttt{Arity} is an integer $>$
\texttt{max\_arity} flag \RefSP{set-prolog-flag/2}}
\ErrTerm{representation\_error(max\_arity)}

\ErrCond{\texttt{Term} is a variable and \texttt{Arity} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Arity)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{arg/3} \label{arg/3}}

\begin{TemplatesOneCol}
arg(+integer, +compound\_term, ?term)

\end{TemplatesOneCol}

\Description

\texttt{arg(N, Term, Arg)} succeeds if the \texttt{N}\emph{th} argument of
\texttt{Term} is \texttt{Arg}.

\begin{PlErrors}

\ErrCond{\texttt{N} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Term} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{N} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, N)}

\ErrCond{\texttt{Term} is neither a variable nor a compound term}
\ErrTerm{type\_error(compound, Term)}

\ErrCond{\texttt{N} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, N)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{(=..)/2} - univ \label{(=..)/2}}

\begin{TemplatesOneCol}
=..(+nonvar, ?list)\\
=..(-nonvar, +list)

\end{TemplatesOneCol}

\Description

\texttt{Term =.. List} succeeds if \texttt{List} is a list whose head is the
atom corresponding to the principal functor of \texttt{Term} and whose tail
is a list of the arguments of \texttt{Term}.

\texttt{=..} is a predefined infix operator \RefSP{op/3:(Term-input/output)}.

\begin{PlErrors}

\ErrCond{\texttt{Term} is a variable and \texttt{List} is a partial list}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{List} is neither a partial list nor a list}
\ErrTerm{type\_error(list, List)}

\ErrCond{\texttt{Term} is a variable and \texttt{List} is a list whose head
is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{List} is a list whose head \texttt{H} is neither an atom
nor a variable and whose tail is not the empty list}
\ErrTerm{type\_error(atom, H)}

\ErrCond{\texttt{List} is a list whose head \texttt{H} is a compound term
and whose tail is the empty list}
\ErrTerm{type\_error(atomic, H)}

\ErrCond{\texttt{Term} is a variable and \texttt{List} is the empty list}
\ErrTerm{domain\_error(non\_empty\_list, [])}

\ErrCond{\texttt{Term} is a variable and the tail of \texttt{List} has a
length $>$ \texttt{max\_arity} flag \RefSP{set-prolog-flag/2}}
\ErrTerm{representation\_error(max\_arity)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{copy\_term/2}}

\begin{TemplatesOneCol}
copy\_term(?term, ?term)

\end{TemplatesOneCol}

\Description

\texttt{copy\_term(Term1, Term2)} succeeds if \texttt{Term2} unifies with a
term \texttt{T} which is a renamed copy of \texttt{Term1}.

\PlErrorsNone

\Portability

ISO predicate.

\subsubsection{\IdxPBD{term\_variables/2},
		\IdxPBD{term\_variables/3}}

\label{term_variables/2-3}

\begin{TemplatesOneCol}
term\_variables(?term, ?list)\\
term\_variables(?term, ?list, ?list)\\

\end{TemplatesOneCol}

\Description

\texttt{term\_variables(Term, List)} succeeds if \texttt{List} unifies with a
list of variables (including FD variables), each sharing with a unique
variable of \texttt{Term}. The variables in \texttt{List} are ordered in
order of appearance traversing \texttt{Term} depth-first and left-to-right.

\texttt{term\_variables(Term, List, Tail)} is a difference-list version of
the above predicate, i.e. \texttt{Tail} is the tail of the variable-list
\texttt{List}.

\begin{PlErrors}

\ErrCond{in \texttt{term\_variables/2} \texttt{List} is neither a partial list nor a list}
\ErrTerm{type\_error(list, List)}

\end{PlErrors}


\Portability

\texttt{term\_variables/2} is an ISO Predicate. \texttt{term\_variables/3} is a 
GNU Prolog predicate.

\subsubsection{\IdxPBD{subsumes\_term/2}}

\begin{TemplatesOneCol}
subsumes\_term(?term, ?term)

\end{TemplatesOneCol}

\Description

\texttt{subsumes\_term(General, Specific)} succeeds if \texttt{General} can
be made equivalent to \texttt{Specific} by binding variables in
\texttt{General} leaving \texttt{Specific} unaffected. The current implementation performs the unification (with
occurs check) and ensures that the variable set of \texttt{Specific} is not
changed by the unification (which is then undone). Note that this predicate
fails in the presence of FD variables in \texttt{Specific}.

\PlErrorsNone

\Portability

ISO predicate.

\subsubsection{\IdxPBD{acyclic\_term/1}}

\begin{TemplatesOneCol}
acyclic\_term(?term)

\end{TemplatesOneCol}

\Description

\texttt{acyclic\_term(Term)} succeeds if \texttt{Term} does not contain a
cyclic (sub-)term. In this case, Term may be processed safely. If
\texttt{acyclic\_term(Term)} fails, \texttt{Term} contains a cycle and
processing Term is not safe, because GNU Prolog does not support the
unification of cyclic terms but permits their creation. Cycles can be safely
undone by failing over their creation. The use of \texttt{acyclic\_term/1}
shall thus be reserved to protect critical predicates against cyclic terms.

\PlErrorsNone

\Portability

ISO predicate.

\subsubsection{\IdxPBD{term\_hash/4},\label{term-hash/4}
            \IdxPBD{term\_hash/2}}


\begin{TemplatesOneCol}
term\_hash(?term, +integer, +integer, ?integer) \\
term\_hash(?term, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{term\_hash(Term, Depth, Range, Hash)} succeeds if \texttt{Hash} is
the \Idx{hash code} of \texttt{Term}. If \texttt{Term} is not ground (see
\texttt{ground/1} \RefSP{var/1}), the predicate simply succeeds
(\texttt{Hash} is not unified). \texttt{Depth} is the depth limit to scan
\texttt{Term} (starting from 1 for the top-level term). With \texttt{Depth} =
0 nothing is hashed, with 1 only atomic terms and the main functors/arity are
hashed,... With \texttt{Depth} = -1 the full term is considered.

The hash code is as follows: $0 \leq$ \texttt{Hash} $<$ \texttt{Range}. If \texttt{Range} = 0 then
\texttt{Hash} is not restricted (currently it is $<$ 268435456).

\texttt{term\_hash(Term, Hash)} is equivalent to \texttt{term\_hash(Term, -1, 0, Hash)}.

NB: the computed hash code is independent of any runtime context (i.e. it is
constant across different executions). It is also independent on the
underlying machine.

These predicates are useful to implement hash tables or argument indexing.

\begin{PlErrors}

\ErrCond{\texttt{Depth} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Depth} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Depth)}

\ErrCond{\texttt{Range} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Range} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Range)}

\ErrCond{\texttt{Range} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Range)}

\ErrCond{\texttt{Hash} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Hash)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{setarg/4},
               \IdxPBD{setarg/3}}

\begin{TemplatesOneCol}
setarg(+integer, +compound\_term, +term, +boolean)\\
setarg(+integer, +compound\_term, +term)

\end{TemplatesOneCol}

\Description

\texttt{setarg(N, Term, NewValue, Undo)} replaces destructively the
\texttt{N}\emph{th} argument of \texttt{Term} with \texttt{NewValue}. This
assignment is undone on backtracking if \texttt{Undo} = \texttt{true}. This
should only used if there is no further use of the old value of the replaced
argument. If \texttt{Undo} = \texttt{false} then \texttt{NewValue} must be
either an atom or an integer.

\texttt{setarg(N, Term, NewValue)} is equivalent to \texttt{setarg(N, Term,
NewValue, true)}.

\begin{PlErrors}

\ErrCond{\texttt{N} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{N} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, N)}

\ErrCond{\texttt{N} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, N)}

\ErrCond{\texttt{Term} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Term} is neither a variable nor a compound term}
\ErrTerm{type\_error(compound, Term)}

\ErrCond{\texttt{NewValue} is neither an atom nor an integer and
\texttt{Undo} = \texttt{false}}
\ErrTerm{type\_error(atomic, NewValue)}

\ErrCond{\texttt{Undo} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Undo} is neither a variable nor a boolean}
\ErrTerm{type\_error(boolean, Undo)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{Variable naming/numbering}
\label{Variable-naming/numbering}

\subsubsection{\IdxPBD{name\_singleton\_vars/1}\label{name-singleton-vars/1}}

\begin{TemplatesOneCol}
name\_singleton\_vars(?term)

\end{TemplatesOneCol}

\Description

\texttt{name\_singleton\_vars(Term)} binds each singleton variable appearing
in \texttt{Term} with a term of the form \texttt{'\$VARNAME'('\_')}. Such a
term can be output by \texttt{write\_term/3} as a variable name
\RefSP{write-term/3}.

\PlErrorsNone

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{name\_query\_vars/2}\label{name-query-vars/2}}

\begin{TemplatesOneCol}
name\_query\_vars(+list, ?list)

\end{TemplatesOneCol}

\Description

\texttt{name\_query\_vars(List, Rest)} for each element of \texttt{List} of
the form \texttt{Name = Var} where \texttt{Name} is an atom and \texttt{Var}
a variable, binds \texttt{Var} with the term \texttt{'\$VARNAME'(Name)}.
Such a term can be output by \texttt{write\_term/3} as a variable name
\RefSP{write-term/3}. \texttt{Rest} is unified with the list of elements of
\texttt{List} that have not given rise to a binding. This predicate is
provided as a way to name the variable lists obtained returned by
\texttt{read\_term/3} with \AddPO{variable\_names}\texttt{variable\_names(List)} or
\AddPO{singletons}\texttt{singletons(List)} options \RefSP{read-term/3}.

\begin{PlErrors}

\ErrCond{\texttt{List} is a partial list}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{List} is neither a partial list nor a list}
\ErrTerm{type\_error(list, List)}

\ErrCond{\texttt{Rest} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Rest)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{bind\_variables/2},\label{bind-variables/2}
               \IdxPBD{numbervars/3},
               \IdxPBD{numbervars/1}}


\begin{TemplatesOneCol}
bind\_variables(?term, +var\_binding\_option\_list)\\
numbervars(?term, +integer, ?integer)\\
numbervars(?term)

\end{TemplatesOneCol}

\Description

\texttt{bind\_variables(Term, Options)} binds each variable appearing in
\texttt{Term} according to the options given by \texttt{Options}.

\SPart{Variable binding options}: \texttt{Options} is a list of variable
binding options. If this list contains contradictory options, the rightmost
option is the one which applies. Possible options are:

\begin{itemize}

\item \IdxPOD{numbervars}: specifies that each variable appearing in
\texttt{Term} should be bound to a term of the form \texttt{'\$VAR'(N)}
where \texttt{N} is an integer. Such a term can be output by
\texttt{write\_term/3} as a variable name \RefSP{write-term/3}. This is
the default.

\item \IdxPOD{namevars}: specifies that each variables appearing in
\texttt{Term} shall be bound to a term of the form
\texttt{'\$VARNAME'(Name)} where \texttt{Name} is the atom that would be
output by \texttt{write\_term/3} seeing a term of the \texttt{'\$VAR'(N)}
where \texttt{N} is an integer. Such a term can be output by
\texttt{write\_term/3} as a variable name \RefSP{write-term/3}. This is
the alternative to \texttt{numbervars}.

\item \AddPOD{from}\texttt{from(From)}: the first integer \texttt{N} to use for
number/name variables of \texttt{Term} is \texttt{From}. The default value
is \texttt{0}.

\item \AddPOD{next}\texttt{next(Next)}: when \texttt{bind\_variables/2} succeeds,
\texttt{Next} is unified with the (last integer \texttt{N})+1 used
to bind the variables of \texttt{Term}.

\item \AddPOD{exclude}\texttt{exclude(List)}: collects all variable names appearing
in \texttt{List} to avoid a clash when binding a variable of \texttt{Term}.
Precisely a number \texttt{N} $\geq$ \texttt{From} will not be used to bind a
variable of \texttt{Term} if:

\begin{itemize}

\item there is a sub-term of \texttt{List} of the form \texttt{'\$VAR'(N)}
or \texttt{'\$VARNAME'(Name)} where \texttt{Name} is the constant that would
be output by \texttt{write\_term/3} seeing a term of the
\texttt{'\$VAR'(N)}.

\item an element of \texttt{List} is of the form \texttt{Name = Var} where
\texttt{Name} is an atom that would be output by \texttt{write\_term/3} on
seeing a term of the from \texttt{'\$VAR'(N)}. This case allows for lists
returned by \texttt{read\_term/3}
(with \AddPO{variable\_names}\texttt{variable\_names(List)} or
\AddPO{singletons}\texttt{singletons(List)} options) \RefSP{read-term/3} and by
\texttt{name\_query\_vars/2} \RefSP{name-query-vars/2}.

\end{itemize}

\end{itemize}

\texttt{numbervars(Term, From, Next)} is equivalent to
\texttt{bind\_variables(Term, [from(From), next(Next)]}, i.e. each variable
of \texttt{Term} is bound to \texttt{'\$VAR'(N)} where \texttt{From $\leq$}
\texttt{N} $<$ \texttt{Next}.


\texttt{numbervars(Term)} is equivalent to \texttt{numbervars(Term, 0, \_)}.

See also \texttt{term\_variables} \RefSP{term_variables/2-3} which returns the set of variables of a
term.

\begin{PlErrors}

\ErrCond{\texttt{Options} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Options} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Options)}

\ErrCond{an element \texttt{E} of the \texttt{Options} list is neither a
variable nor a variable binding option}
\ErrTerm{domain\_error(var\_binding\_option, E)}

\ErrCond{\texttt{From} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{From} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, From)}

\ErrCond{\texttt{Next} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Next)}

\ErrCond{\texttt{List} is a partial list}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{List} is neither a partial list nor a list}
\ErrTerm{type\_error(list, List)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{term\_ref/2}}

\begin{TemplatesOneCol}
term\_ref(+term, ?integer)\\
term\_ref(?term, +integer)

\end{TemplatesOneCol}

\Description

\texttt{term\_ref(Term, Ref)} succeeds if the internal reference of
\texttt{Term} is \texttt{Ref}. This predicate can be used either to obtain
the internal reference of a term or to obtain the term associated with a given
reference. Note that two identical terms can have different internal
references. A good way to use this predicate is to first record the internal
reference of a given term and to later re-obtain the term via this
reference.

\begin{PlErrors}

\ErrCond{\texttt{Term} and \texttt{Ref} are both variables}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Ref} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Ref)}

\ErrCond{\texttt{Ref} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Ref)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{Arithmetic}

\subsubsection{Evaluation of an arithmetic expression}
\label{Evaluation-of-an-arithmetic-expression}
An arithmetic expression is a Prolog term built from numbers,
variables, and functors (or operators) that represent arithmetic functions.
When an expression is evaluated each variable must be bound to a
non-variable expression. An expression evaluates to a number, which may be
an integer or a floating point number. The following table details the
components of an arithmetic expression, how they are evaluated, the types
expected/returned and if they are ISO or an extension:


\newpage
\tablehead{\hline Expression & Result = \textit{eval}(Expression) & Signature & ISO \\\hline\hline}

\begin{supertabular}{|l|L{7.5cm}|c|c|}
%HEVEA\hline Expression & Result = \textit{eval}(Expression) & Signature & ISO \\\hline\hline
a variable & bound to an expression \texttt{E}, result is \textit{eval}(\texttt{E}) & IF $\rightarrow$ IF & Y \\

\hline

an integer number & this number & I & Y \\

\hline

a floating point number & this number & F & Y \\

\hline

\texttt{pi} & the value of $\pi = 3.141592...$ & F & Y \\

\hline

\texttt{e} & the value of $e = 2.718281...$ & F & N \\

\hline

\texttt{epsilon} & difference between 1.0 and minimum float $>$ 1.0 & F & N \\

\hline

\texttt{+ E} & \textit{eval}(\texttt{E}) & IF $\rightarrow$ IF & Y \\

\hline

\texttt{- E} & - \textit{eval}(\texttt{E}) & IF $\rightarrow$ IF & Y \\

\hline

\texttt{inc(E)} & \textit{eval}(\texttt{E}) + 1 & IF $\rightarrow$ IF & N \\

\hline

\texttt{dec(E)} & \textit{eval}(\texttt{E}) - 1 & IF $\rightarrow$ IF & N \\

\hline

\texttt{E1 + E2} & \textit{eval}(\texttt{E1}) + \textit{eval}(\texttt{E2}) &
IF, IF $\rightarrow$ IF & Y \\

\hline

\texttt{E1 - E2} & \textit{eval}(\texttt{E1}) - \textit{eval}(\texttt{E2}) &
IF, IF $\rightarrow$ IF & Y \\

\hline

\texttt{E1 * E2} & \textit{eval}(\texttt{E1}) * \textit{eval}(\texttt{E2}) &
IF, IF $\rightarrow$ IF & Y \\

\hline

\texttt{E1 / E2} & \textit{eval}(\texttt{E1}) / \textit{eval}(\texttt{E2}) &
IF, IF $\rightarrow$ F & Y \\

\hline

\texttt{E1 // E2} & \textit{rnd}(\textit{eval}(\texttt{E1}) /
\textit{eval}(\texttt{E2})) & I, I $\rightarrow$ I & Y \\

\hline

\texttt{E1 rem E2} & \textit{eval}(\texttt{E1}) -
(\textit{rnd}(\textit{eval}(\texttt{E1}) /
\textit{eval}(\texttt{E2})) * \textit{eval}(\texttt{E2})) & I, I $\rightarrow$
I & Y \\

\hline

\texttt{E1 div E2} & $\lfloor$(\textit{eval}(\texttt{E1}) -
\textit{eval}(\texttt{E1}) \texttt{mod} \textit{eval}(\texttt{E2})) /
\textit{eval}(\texttt{E2})$\rfloor$ & I, I $\rightarrow$ I & Y \\

\hline

\texttt{E1 mod E2} & \textit{eval}(\texttt{E1}) -
($\lfloor$\textit{eval}(\texttt{E1}) / \textit{eval}(\texttt{E2})$\rfloor$
 * \textit{eval}(\texttt{E2})) & I, I $\rightarrow$ I & Y \\

\hline

\texttt{E1 /{\bs} E2} & \textit{eval}(\texttt{E1}) bitwise\_and
\textit{eval}(\texttt{E2}) & I, I $\rightarrow$ I & Y \\

\hline

\texttt{E1 {\bs}/ E2} & \textit{eval}(\texttt{E1}) bitwise\_or
\textit{eval}(\texttt{E2}) & I, I $\rightarrow$ I & Y \\

\hline

\texttt{xor(E1,E2)} & \textit{eval}(\texttt{E1}) bitwise\_xor
\textit{eval}(\texttt{E2}) & I, I $\rightarrow$ I & Y \\

\hline

\texttt{{\bs} E} & bitwise\_not \textit{eval}(\texttt{E}) & I $\rightarrow$
I & Y \\

\hline

\texttt{E1 {\lt}{\lt} E2} & \textit{eval}(\texttt{E1}) integer\_shift\_left
\textit{eval}(\texttt{E2}) & I, I $\rightarrow$ I & Y \\

\hline

\texttt{E1 {\gt}{\gt} E2} & \textit{eval}(\texttt{E1}) integer\_shift\_right
\textit{eval}(\texttt{E2}) & I, I $\rightarrow$ I & Y \\

\hline

\texttt{lsb(E)} & least significant bit (from 0) of \textit{eval}(\texttt{E}) or -1 & I
$\rightarrow$ I & N \\

\hline

\texttt{msb(E)} & most significant bit (from 0) of \textit{eval}(\texttt{E}) or -1 & I
$\rightarrow$ I & N \\

\hline

\texttt{popcount(E)} & number of 1-bits in \textit{eval}(\texttt{E}) & I
$\rightarrow$ I & N \\

\hline

\texttt{abs(E)} & absolute value of \textit{eval}(\texttt{E}) & IF
$\rightarrow$ IF & Y \\

\hline

\texttt{sign(E)} & sign of \textit{eval}(\texttt{E}) (-1 if $<$ 0, 0 if = 0,
+1 if $>$ 0) & IF $\rightarrow$ IF & Y \\

\hline

\texttt{min(E1,E2)} & minimal value between \textit{eval}(\texttt{E1}) and
\textit{eval}(\texttt{E2}) & IF, IF $\rightarrow$ ? & Y \\

\hline

\texttt{max(E1,E2)} & maximal value between \textit{eval}(\texttt{E1}) and
\textit{eval}(\texttt{E2}) & IF, IF $\rightarrow$ ? & Y \\

\hline

\texttt{gcd(E1,E2)} & greatest common divisor of \textit{eval}(\texttt{E1}) and
\textit{eval}(\texttt{E2}) & I, I $\rightarrow$ I & N \\

\hline

\texttt{E1 \^{} E2}  & \textit{eval}(\texttt{E1}) raised to the power of
\textit{eval}(\texttt{E2}) & IF, IF $\rightarrow$ IF & Y \\

\hline

\texttt{E1 ** E2} & \textit{eval}(\texttt{E1}) raised to the power of
\textit{eval}(\texttt{E2}) & IF, IF $\rightarrow$ F & Y \\

\hline

\texttt{sqrt(E)} & square root of \textit{eval}(\texttt{E}) & IF
$\rightarrow$ F & Y \\

\hline

\texttt{tan(E)} & tangent of \textit{eval}(\texttt{E}) & IF
$\rightarrow$ F & Y \\

\hline

\texttt{atan(E)} & arc tangent of \textit{eval}(\texttt{E}) & IF
$\rightarrow$ F & Y \\

\hline

\texttt{atan2(Y,X)} & principal value of arc tangent
of \textit{eval}(\texttt{Y}) / \textit{eval}(\texttt{X}) using both signs for the quadrant & IF
$\rightarrow$ F & Y \\

\hline

\texttt{cos(E)} & cosine of \textit{eval}(\texttt{E}) & IF $\rightarrow$ F &
Y \\

\hline

\texttt{acos(E)} & arc cosine of \textit{eval}(\texttt{E}) & IF, IF $\rightarrow$ F &
Y \\

\hline

\texttt{sin(E)} & sine of \textit{eval}(\texttt{E}) & IF $\rightarrow$ F & Y \\

\hline

\texttt{asin(E)} & arc sine of \textit{eval}(\texttt{E}) & IF $\rightarrow$ F & Y \\

\hline

\texttt{tanh(E)} & hyperbolic tangent of \textit{eval}(\texttt{E}) & IF
$\rightarrow$ F & N \\

\hline

\texttt{atanh(E)} & hyperbolic arc tangent of \textit{eval}(\texttt{E}) & IF
$\rightarrow$ F & N \\

\hline

\texttt{cosh(E)} & hyperbolic cosine of \textit{eval}(\texttt{E}) & IF $\rightarrow$ F & N \\

\hline

\texttt{acosh(E)} & hyperbolic arc cosine of \textit{eval}(\texttt{E}) & IF, IF $\rightarrow$ F & N \\

\hline

\texttt{sinh(E)} & hyperbolic sine of \textit{eval}(\texttt{E}) & IF $\rightarrow$ F & N \\

\hline

\texttt{asinh(E)} & hyperbolic arc sine of \textit{eval}(\texttt{E}) & IF $\rightarrow$ F & N \\

\hline

\texttt{exp(E)} & $e$ raised to the power of \textit{eval}(\texttt{E}) &
IF $\rightarrow$ F & Y \\

\hline

\texttt{log(E)} & natural logarithm of \textit{eval}(\texttt{E}) & IF
$\rightarrow$ F & Y \\

\hline

\texttt{log10(E)} & base 10 logarithm of \textit{eval}(\texttt{E}) & IF
$\rightarrow$ F & N \\

\hline

\texttt{log(R, E)} & base \textit{eval}(\texttt{R}) logarithm of \textit{eval}(\texttt{E})  & F, IF
$\rightarrow$ F & N \\

\hline

\texttt{float(E)} & the floating point number equal to
\textit{eval}(\texttt{E}) & IF $\rightarrow$ F & Y \\

\hline

\texttt{ceiling(E)} & rounds \textit{eval}(\texttt{E}) upward to the
nearest integer & F $\rightarrow$ I & Y \\

\hline

\texttt{floor(E)} & rounds \textit{eval}(\texttt{E}) downward to the
nearest integer & F $\rightarrow$ I & Y \\

\hline

\texttt{round(E)} & rounds \textit{eval}(\texttt{E}) to the nearest integer
& F $\rightarrow$ I & Y \\

\hline

\texttt{truncate(E)} & the integer value of \textit{eval}(\texttt{E}) & F
$\rightarrow$ I & Y \\

\hline

\texttt{float\_fractional\_part(E)} & the float equal to the fractional part
of \textit{eval}(\texttt{E}) & F $\rightarrow$ F & Y \\

\hline

\texttt{float\_integer\_part(E)} & the float equal to the integer part of
\textit{eval}(\texttt{E}) & F $\rightarrow$ F & Y \\

\hline
\end{supertabular}

The meaning of the signature field is as follows:

\begin{itemize}

\item I $\rightarrow$ I: unary function, the operand must be an integer and
the result is an integer.

\item F $\rightarrow$ F: unary function, the operand must be a floating
point number and the result is a floating point number.

\item F $\rightarrow$ I: unary function, the operand must be a floating
point number and the result is an integer.

\item IF $\rightarrow$ F: unary function, the operand can be an integer or a
floating point number and the result is a floating point number.

\item IF $\rightarrow$ IF: unary function, the operand can be an integer or
a floating point number and the result has the same type as the operand.

\item I, I $\rightarrow$ I: binary function: each operand must be an integer
and the result is an integer.

\item IF, IF $\rightarrow$ IF: binary function: each operand can be an
integer or a floating point number and the result is a floating point number
if at least one operand is a floating point number, an integer otherwise.

\item IF, IF $\rightarrow$ ?: binary function: each operand can be an
integer or a floating point number and the result has the same type as the
selected operand. This is used for \texttt{min} and \texttt{max}. Note that
in case of equality between an integer and a floating point number the
result is an integer.

\end{itemize}

\texttt{is}, \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{//},
\texttt{div}, \texttt{rem}, \texttt{mod}, \texttt{/{\bs}}, \texttt{{\bs}/},
\texttt{{\lt}{\lt}}, \texttt{{\gt}{\gt}}, \texttt{**} and \texttt{\^{}} are predefined infix
operators. \texttt{+}, \texttt{-} and \texttt{{\bs}}, are predefined prefix
operators \RefSP{op/3:(Term-input/output)}.

\SPart{Integer division rounding function}: the integer division rounding
function \texttt{\textit{rnd}(X)} rounds the floating point number
\texttt{X} to an integer. There are two possible definitions (depending on
the target machine) for this function which differ on negative numbers:

\begin{itemize}

\item \texttt{\textit{rnd}(X)} = integer part of \texttt{X}, e.g.
\texttt{\textit{rnd}(-1.5)} = \texttt{-1} (round toward 0)

\item \texttt{\textit{rnd}(X)} = $\lfloor$\texttt{X}$\rfloor$, e.g.
\texttt{\textit{rnd}(-1.5)} = \texttt{-2} (round toward $-\infty$)

\end{itemize}

The definition of this function determines the definition of the integer
division and remainder (\texttt{(//)/2} and \texttt{(rem)/2}). It is
possible to test the value (\texttt{toward\_zero} or \texttt{down}) of the
\IdxPF{integer\_rounding\_function} \Idx{Prolog flag} to determine which
function being used \RefSP{set-prolog-flag/2}. Since rounding toward zero is
the most common case, two additional evaluable functors (\texttt{(div)/2} and
\texttt{(mod)/2}) are available which consider rounding toward $-\infty$.


\SPart{Fast mathematical mode}: in order to speed-up integer computations,
the GNU Prolog compiler can generate faster code when invoked with the
\IdxK{--fast-math} option \RefSP{Using-the-compiler}. In this mode only
integer operations are allowed and a variable in an expression must be bound
at evaluation time to an integer. No type checking is done.

\begin{PlErrors}

\ErrCond{a sub-expression \texttt{E} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{a sub-expression \texttt{E} is neither a number nor an evaluable
functor}
\ErrTerm{type\_error(evaluable, E)}

\ErrCond{a sub-expression \texttt{E} is a floating point number while an
integer is expected}
\ErrTerm{type\_error(integer, E)}

\ErrCond{a sub-expression \texttt{E} is an integer while a floating point
number is expected}
\ErrTerm{type\_error(float, E)}

\ErrCond{a division by zero occurs}
\ErrTerm{evaluation\_error(zero\_divisor)}

\end{PlErrors}

\Portability

Refer to the above table to determine which evaluable functors are ISO
and which are GNU Prolog extensions. For efficiency reasons, GNU
Prolog does not detect the following ISO arithmetic errors:
\texttt{float\_overflow},
\texttt{int\_overflow, int\_underflow}, and \texttt{undefined}.

\subsubsection{\IdxPBD{(is)/2} - evaluate expression}

\begin{TemplatesOneCol}
is(?term, +evaluable)

\end{TemplatesOneCol}

\Description

\texttt{Result is Expression} succeeds if \texttt{Result} can be
unified with \textit{eval}(\texttt{Expression}). Refer to the
evaluation of an arithmetic expression for the definition of the
\textit{eval} function
\RefSP{Evaluation-of-an-arithmetic-expression}.

\texttt{is} is a predefined infix operator \RefSP{op/3:(Term-input/output)}.

\Errors

Refer to the evaluation of an arithmetic expression for possible errors
\RefSP{Evaluation-of-an-arithmetic-expression}.

\Portability

ISO predicate.

\subsubsection{\IdxPBD{(=:=)/2} - arithmetic equal, \label{(=:=)/2}
               \IdxPBD{(={\bs}=)/2} - arithmetic not equal, \\
               \IdxPBD{({\lt})/2} - arithmetic less than,
               \IdxPBD{(={\lt})/2} - arithmetic less than or equal to, \\
               \IdxPBD{({\gt})/2} - arithmetic greater than,
               \IdxPBD{({\gt}=)/2} - arithmetic greater than or equal to}

\begin{TemplatesTwoCols}
=:=(+evaluable, +evaluable)\\
={\bs}=(+evaluable, +evaluable)\\
{\lt}(+evaluable, +evaluable)\\
={\lt}(+evaluable, +evaluable)\\
{\gt}(+evaluable, +evaluable)\\
{\gt}=(+evaluable, +evaluable)

\end{TemplatesTwoCols}

\Description

\texttt{Expr1 =:= Expr2} succeeds if \textit{eval}(\texttt{Expr1}) =
\textit{eval}(\texttt{Expr2}).

\texttt{Expr1 ={\bs}= Expr2} succeeds if \textit{eval}(\texttt{Expr1})
$\neq$ \textit{eval}(\texttt{Expr2}).

\texttt{Expr1 {\lt} Expr2} succeeds if \textit{eval}(\texttt{Expr1}) $<$
\textit{eval}(\texttt{Expr2}).

\texttt{Expr1 ={\lt} Expr2} succeeds if \textit{eval}(\texttt{Expr1})
$\leq$ \textit{eval}(\texttt{Expr2}).

\texttt{Expr1 {\gt} Expr2} succeeds if \textit{eval}(\texttt{Expr1}) $>$
\textit{eval}(\texttt{Expr2}).

\texttt{Expr1 {\gt}= Expr2} succeeds if \textit{eval}(\texttt{Expr1})
$\geq$ \textit{eval}(\texttt{Expr2}).

Refer to the evaluation of an arithmetic expression for the definition of
the \textit{eval} function \RefSP{Evaluation-of-an-arithmetic-expression}.

\texttt{=:=}, \texttt{={\bs}=}, \texttt{{\lt}}, \texttt{={\lt}},
\texttt{{\gt}} and \texttt{{\gt}=} are predefined infix operators
\RefSP{op/3:(Term-input/output)}.

\Errors

Refer to the evaluation of an arithmetic expression for possible errors
\RefSP{Evaluation-of-an-arithmetic-expression}.

\Portability

ISO predicates.



\subsubsection{\IdxPBD{succ/2}}

\begin{TemplatesOneCol}
succ(+integer, ?integer) \\
succ(-integer, +integer) 

\end{TemplatesOneCol}

\Description

\texttt{succ(X, Y)} is true iff \texttt{Y} is the successor of the non-negative integer \texttt{X}. 

\begin{PlErrors}

\ErrCond{\texttt{X} and \texttt{Y} are both variables}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{X} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, X)}

\ErrCond{\texttt{Y} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Y)}

\ErrCond{\texttt{X} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, X)}

\ErrCond{\texttt{Y} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Y)}

\end{PlErrors}

\Portability

GNU Prolog predicate.


\subsection{Dynamic clause management}

\subsubsection{Introduction}
\label{Introduction:(Dynamic-clause-management)}
\SPart{Static and dynamic procedures}: a procedure is either dynamic or
static. All built-in predicates are static. A user-defined procedure is
static by default unless a \IdxDi{dynamic/1} directive precedes its
definition \RefSP{dynamic/1}. Adding a clause to a non-existent procedure
creates a dynamic procedure. The clauses of a dynamic procedure can be
altered (e.g. using \texttt{asserta/1}), the clauses of a static procedure
cannot be altered.

\SPart{Private and public procedures}: each procedure is either public or
private. A dynamic procedure is always public. Each built-in predicate is
private, and a static user-defined procedure is private by default unless a
\IdxDi{public/1} directive precedes its definition \RefSP{public/1}. If a
dynamic declaration exists it is unnecessary to add a public declaration
since a dynamic procedure is also public. A clause of a public procedure can
be inspected (e.g. using \texttt{clause/2}), a clause of a private procedure
cannot be inspected.

\SPart{A logical database update view}: any change in the database that
occurs as the result of executing a goal (e.g. when a sub-goal is a call of
\texttt{assertz/1} or \texttt{retract/1}) only affects subsequent
activations. The change does not affect any activation that is currently
being executed. Thus the database is frozen during the execution of a goal,
and the list of clauses defining a predication is fixed at the moment of its
execution.

\subsubsection{\IdxPBD{asserta/1},
               \IdxPBD{assertz/1}}

\begin{TemplatesOneCol}
asserta(+clause)\\
assertz(+clause)

\end{TemplatesOneCol}

\Description

\texttt{asserta(Clause)} first converts the term \texttt{Clause} to a clause
and then adds it to the current internal database. The predicate concerned
must be dynamic \RefSP{Introduction:(Dynamic-clause-management)} or
undefined and the clause is inserted before the first clause of the
predicate. If the predicated is undefined it is created as a dynamic
procedure.

\texttt{assertz(Clause)} acts like \texttt{asserta/1} except that the clause
is added at the end of all existing clauses of the concerned predicate.

\SPart{Converting a term \texttt{Clause} to a clause \texttt{Clause1}:}

\begin{itemize}

\item extract the head and the body of \texttt{Clause}: either
\texttt{Clause} = \texttt{(Head :- Body)} or \texttt{Clause} = \texttt{Head}
and \texttt{Body} = \texttt{true}.

\item \texttt{Head} must be a callable term (or else the conversion fails).

\item convert \texttt{Body} to a body clause (i.e. a goal) \texttt{Body1}.

\item the converted clause \texttt{Clause1} = \texttt{(Head :- Body1)}.

\end{itemize}

\SPart{Converting a term \texttt{T} to a goal:}

\begin{itemize}

\item if \texttt{T} is a variable it is replaced by the term
\texttt{call(T)}.

\item if \texttt{T} is a control construct \texttt{(',')/2}, \texttt{(;)/2}
or \texttt{(-{\gt})/2} each argument of the control construct is recursively
converted to a goal.

\item if \texttt{T} is a callable term it remains unchanged.

\item otherwise the conversion fails (\texttt{T} is neither a variable nor a
callable term).

\end{itemize}

\begin{PlErrors}

\ErrCond{\texttt{Head} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Head} is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, Head)}

\ErrCond{\texttt{Body} cannot be converted to a goal}
\ErrTerm{type\_error(callable, Body)}

\ErrCond{The predicate indicator \texttt{Pred} of \texttt{Head} is that of a
static procedure}
\ErrTerm{permission\_error(modify, static\_procedure, Pred)}

\end{PlErrors}

\Portability

ISO predicates.

\subsubsection{\IdxPBD{retract/1}}

\begin{TemplatesOneCol}
retract(+clause)

\end{TemplatesOneCol}

\Description

\texttt{retract(Clause)} erases the first clause of the database
that unifies with \texttt{Clause}. The concerned predicate must be a
dynamic procedure
\RefSP{Introduction:(Dynamic-clause-management)}. Removing all clauses
of a procedure does not erase the procedure definition. To achieve
this use \texttt{abolish/1} \RefSP{abolish/1}. \texttt{retract/1} is
re-executable on backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Head} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Head} is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, Head)}

\ErrCond{The predicate indicator \texttt{Pred} of \texttt{Head} is that of a
static procedure}
\ErrTerm{permission\_error(modify, static\_procedure, Pred)}

\end{PlErrors}

\Portability

ISO predicate. In the ISO reference, the operation associated with the
\texttt{permission\_error} is \texttt{access} while it is \texttt{modify} in
GNU Prolog. This seems to be an error of the ISO reference since for
\texttt{asserta/1} (which is similar in spirit to \texttt{retract/1}) the
operation is also \texttt{modify}.

\subsubsection{\IdxPBD{retractall/1}}

\begin{TemplatesOneCol}
retractall(+head)

\end{TemplatesOneCol}

\Description

\texttt{retractall(Head)} erases all clauses whose head unifies with
\texttt{Head}. The concerned predicate must be a dynamic procedure
\RefSP{Introduction:(Dynamic-clause-management)}. The procedure definition
is not removed so that it is found by \IdxPB{current\_predicate/1}
\RefSP{current-predicate/1}. \texttt{abolish/1} should be used to remove the
procedure \RefSP{abolish/1}.

\begin{PlErrors}

\ErrCond{\texttt{Head} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Head} is not a callable term}
\ErrTerm{type\_error(callable, Head)}

\ErrCond{The predicate indicator \texttt{Pred} of \texttt{Head} is that of a
static procedure}
\ErrTerm{permission\_error(modify, static\_procedure, Pred)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{clause/2}}

\begin{TemplatesOneCol}
clause(+head, ?callable\_term)

\end{TemplatesOneCol}

\Description

\texttt{clause(Head, Body)} succeeds if there exists a clause in the
database that unifies with \texttt{Head :- Body}. The predicate in question
must be a public procedure \RefSP{Introduction:(Dynamic-clause-management)}. Clauses are delivered from the first to the last. This
predicate is re-executable on backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Head} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Head} is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, Head)}

\ErrCond{The predicate indicator \texttt{Pred} of \texttt{Head} is that of a
private procedure}
\ErrTerm{permission\_error(access, private\_procedure, Pred)}

\ErrCond{\texttt{Body} is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, Body)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{abolish/1}\label{abolish/1}}

\begin{TemplatesOneCol}
abolish(+predicate\_indicator)

\end{TemplatesOneCol}

\Description

\texttt{abolish(Pred)} removes from the database the procedure whose
predicate indicator is \texttt{Pred}. The concerned predicate must be a
dynamic procedure \RefSP{Introduction:(Dynamic-clause-management)}.

\begin{PlErrors}

\ErrCond{\texttt{Pred} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Pred} is a term \texttt{Name/Arity} and either
\texttt{Name} or \texttt{Arity} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Pred} is neither a variable nor a predicate indicator}
\ErrTerm{type\_error(predicate\_indicator, Pred)}

\ErrCond{\texttt{Pred} is a term \texttt{Name/Arity} and \texttt{Arity} is
neither a variable nor an integer}
\ErrTerm{type\_error(integer, Arity)}

\ErrCond{\texttt{Pred} is a term \texttt{Name/Arity} and \texttt{Name} is
neither a variable nor an atom}
\ErrTerm{type\_error(atom, Name)}

\ErrCond{\texttt{Pred} is a term \texttt{Name/Arity} and \texttt{Arity} is
an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Arity)}

\ErrCond{\texttt{Pred} is a term \texttt{Name/Arity} and \texttt{Arity} is
an integer $>$ \texttt{max\_arity} flag \RefSP{set-prolog-flag/2}}
\ErrTerm{representation\_error(max\_arity)}

\ErrCond{The predicate indicator \texttt{Pred} is that of a static
procedure}
\ErrTerm{permission\_error(modify, static\_procedure, Pred)}

\end{PlErrors}

\Portability

ISO predicate.

\subsection{Predicate information}

\subsubsection{\IdxPBD{current\_predicate/1}\label{current-predicate/1}}

\begin{TemplatesOneCol}
current\_predicate(?predicate\_indicator)

\end{TemplatesOneCol}

\Description

\texttt{current\_predicate(Pred)} succeeds if there
exists a predicate indicator of a defined procedure that unifies with
\texttt{Pred}. All user defined procedures are found, whether static or
dynamic. Internal system procedures whose name begins
with \texttt{'\$'} are not found. A user-defined procedure is found
even when it has no clauses. A user-defined procedure is not found if
it has been abolished. To conform to the ISO reference, built-in predicates
are not found except if the \IdxPF{strict\_iso} \Idx{Prolog flag} is switched off \RefSP{set-prolog-flag/2}. This predicate is re-executable on
backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Pred} is neither a variable nor a predicate indicator}
\ErrTerm{type\_error(predicate\_indicator, Pred)}

\ErrCond{\texttt{Pred} is a term \texttt{Name/Arity} and \texttt{Arity} is
neither a variable nor an integer}
\ErrTerm{type\_error(integer, Arity)}

\ErrCond{\texttt{Pred} is a term \texttt{Name/Arity} and \texttt{Name} is
neither a variable nor an atom}
\ErrTerm{type\_error(atom, Name)}

\ErrCond{\texttt{Pred} is a term \texttt{Name/Arity} and \texttt{Arity} is
an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Arity)}

\ErrCond{\texttt{Pred} is a term \texttt{Name/Arity} and \texttt{Arity} is
an integer $>$ \texttt{max\_arity} flag \RefSP{set-prolog-flag/2}}
\ErrTerm{representation\_error(max\_arity)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{predicate\_property/2}\label{predicate-property/2}}

\begin{TemplatesOneCol}
predicate\_property(?callable, ?predicate\_property)

\end{TemplatesOneCol}

\Description

\texttt{predicate\_property(Head, Property)} succeeds if \texttt{Head} refers
to a predicate that has a property \texttt{Property}. All user defined
procedures and built-in predicates are found. Internal system procedures
whose name begins with \texttt{'\$'} are not found. This predicate is
re-executable on backtracking.

Since version 1.4.0, \texttt{predicate\_property/2} no longer accepts a
predicate indicator. Control constructs are now returned. Properties
\texttt{built\_in\_fd} and \texttt{control\_construct} now imply the property
\texttt{built\_in}.

\SPart{Predicate properties}:

\begin{itemize}

\item \IdxPPD{static}: if the procedure is static.

\item \IdxPPD{dynamic}: if the procedure is dynamic.

\item \IdxPPD{private}: if the procedure is private.

\item \IdxPPD{public}: if the procedure is public.

\item \IdxPPD{monofile}: if the procedure is monofile.

\item \IdxPPD{multifile}: if the procedure is multifile.

\item \IdxPPD{user}: if the procedure is a user-defined procedure.

\item \IdxPPD{built\_in}: if the procedure is a built-in predicate or a control construct.

\item \IdxPPD{built\_in\_fd}: if the procedure is an FD built-in predicate.

\item \IdxPPD{control\_construct}: if the procedure is a control construct \RefSP{control-construct}.

\item \IdxPPD{native\_code}: if the procedure is compiled in native code.

\item \AddPPD{prolog\_file}\texttt{prolog\_file(File)}: source file from which the
procedure has been read.

\item \AddPPD{prolog\_line}\texttt{prolog\_line(Line)}: line number of the source
file.

\item \AddPPD{meta\_predicate}\texttt{meta\_predicate(Head)}: if the procedure is a
  meta-predicate unify \texttt{Head} with the head-pattern. The head-pattern
  is a compound term with the same name and arity as the predicate where each
  argument of the term is a meta argument specifier as follows:

\BL

\begin{description}

\item [integer \texttt{N}] the argument is a term that is used to reference a
  predicate with \texttt{N} more arguments than the given argument term (e.g. \texttt{call(0)}).

\item [\texttt{:}] the argument is module sensitive, but does not directly
  refer to a predicate (e.g. \texttt{consult(:)}).

\item [\texttt{-}] the argument is not module sensitive and unbound on entry.


\item [\texttt{?}] the argument is not module sensitive and the mode is unspecified.

\item [\texttt{+}] the argument is not module sensitive and bound (i.e., nonvar) on entry.

\end{description}

\end{itemize}

\begin{PlErrors}

\ErrCond{\texttt{Head} is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, Head)}

\ErrCond{\texttt{Property} is neither a variable nor a predicate property
term}
\ErrTerm{domain\_error(predicate\_property, Property)}

\ErrCond{\texttt{Property} = \texttt{prolog\_file(File)} and \texttt{File}
is neither a variable nor an atom}
\ErrTerm{type\_error(atom, File)}

\ErrCond{\texttt{Property} = \texttt{prolog\_line(Line)} and \texttt{Line}
is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Line)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{All solutions}

\subsubsection{Introduction}
\label{Introduction:(All-solutions)}
It is sometimes useful to collect all solutions for a goal. This can be done
by repeatedly backtracking and gradually building the list of solutions. The
following built-in predicates are provided to automate this process.

The built-in predicates described in this section invoke \texttt{call/1}
\RefSP{call/1} on the argument \texttt{Goal}. When efficiency is crucial
and \texttt{Goal} is complex it is better to define an auxiliary predicate
which can then be compiled, and have \texttt{Goal} call this predicate.

\subsubsection{\IdxPBD{findall/3}}

\begin{TemplatesOneCol}
findall(?term, +callable\_term, ?list)

\end{TemplatesOneCol}

\Description

\texttt{findall(Template, Goal, Instances)} succeeds if \texttt{Instances}
unifies with the list of values to which a variable \texttt{X} not occurring
in \texttt{Template} or \texttt{Goal} would be instantiated by successive
re-executions of \texttt{call(Goal), X = Template} after systematic
replacement of all variables in \texttt{X} by new variables. Thus, the order
of the list \texttt{Instances} corresponds to the order in which the proofs
are found.

\begin{PlErrors}

\ErrCond{\texttt{Goal} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Goal} is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, Goal)}

\ErrCond{The predicate indicator \texttt{Pred} of \texttt{Goal} does not
correspond to an existing procedure and the value of the \texttt{unknown}
Prolog flag is \texttt{error} \RefSP{set-prolog-flag/2}}
\ErrTerm{existence\_error(procedure, Pred)}

\ErrCond{\texttt{Instances} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Instances)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{bagof/3},
               \IdxPBD{setof/3}}

\begin{TemplatesOneCol}
bagof(?term, +callable\_term, ?list)\\
setof(?term, +callable\_term, ?list)

\end{TemplatesOneCol}

\Description

\texttt{bagof(Template, Goal, Instances)} assembles as a list the
set of solutions of \texttt{Goal} for each different instantiation of the
free variables in \texttt{Goal}. The elements of each list are in order of
solution, but the order in which each list is found is undefined.
This predicate is re-executable on backtracking.

\SPart{Free variable set}: \texttt{bagof/3} groups the solutions of
\texttt{Goal} according to the free variables in \texttt{Goal}. This set
corresponds to all variables occurring in \texttt{Goal} but not in
\texttt{Template}. It is sometimes useful to exclude some additional
variables of \texttt{Goal}. For that, \texttt{bagof/3} recognizes a goal of
the form \texttt{T\^{}Goal} and exclude all variables occurring in \texttt{T}
from the free variable set. \texttt{(\^{})/2} can be viewed as an
\emph{existential quantifier} (the logical reading of \texttt{X\^{}Goal}
being ``there exists an \texttt{X} such that \texttt{Goal} is true''). The
use of this existential qualifier is superfluous outside \texttt{bagof/3}
(and \texttt{setof/3}) and then is not recognized.

\texttt{(\^{})/2} is a predefined infix operator \RefSP{op/3:(Term-input/output)}.

\texttt{setof(Template, Goal, Instances)} is equivalent to
\texttt{bagof(Template,Goal,I), sort(I,Instances)}. Each list is then a
sorted list (duplicate elements are removed).

From the implementation point of view \texttt{setof/3} is as fast as
\texttt{bagof/3}. Both predicates use an in-place (i.e. destructive) sort
\RefSP{sort/2} and require the same amount of memory.

\begin{PlErrors}

\ErrCond{\texttt{Goal} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Goal} is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, Goal)}

\ErrCond{The predicate indicator \texttt{Pred} of \texttt{Goal} does not
correspond to an existing procedure and the value of the \texttt{unknown}
Prolog flag is \texttt{error} \RefSP{set-prolog-flag/2}}
\ErrTerm{existence\_error(procedure, Pred)}

\ErrCond{\texttt{Instances} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Instances)}

\end{PlErrors}

\Portability

ISO predicates.

\subsection{Streams}
\label{Streams}

\subsubsection{Introduction}
\label{Introduction:(Streams)}
A stream provides a logical view of a source/sink.

\SPart{Sources and sinks}: a program can output results to a sink or input
data from a source. A source/sink may be a file (regular file, terminal,
device,\ldots), a constant term, a pipe, a socket,\ldots

\SPart{Associating a stream to a source/sink}: to manipulate a source/sink
it must be associated with a stream. This provides a logical and uniform view
of the source/sink whatever its type. Once this association has been
established, i.e. a stream has been created, all subsequent references to
the source/sink are made by referring the stream. A stream is
unidirectional: it is either an input stream or an output stream. For a
classical file, the association is done by opening the file (whose name is
specified as an atom) with the \IdxPB{open/4} \RefSP{open/4}. GNU Prolog
makes it possible to treat a Prolog constant term as a source/sink and
provides built-in predicates to associate a stream to such a term
\RefSP{Constant-term-streams}. GNU Prolog provides operating system interface
predicates defining pipes between GNU Prolog and child processes with streams
associated with these pipes, e.g. \IdxPB{popen/3} \RefSP{popen/3}.
Similarly, socket interface predicates associate streams to a socket to
allow the communication, e.g. \IdxPB{socket\_connect/4}
\RefSP{socket-connect/4}.

\SPart{Stream-term}: a stream-term identifies a stream during a call of an
input/output built-in predicate. It is created as a result of associating a
stream to a source/sink (section above). A stream-term is a compound term of
the form \texttt{'\$stream'(I)} where \texttt{I} is an integer.

\SPart{Stream aliases}: any stream may be associated with a stream alias
which is an atom which may be used to refer to that stream. The association
can be done at open time or using \IdxPB{add\_stream\_alias/2}
\RefSP{add-stream-alias/2}. Such an association automatically ends when the
stream is closed. A particular alias only refers to at most one stream at any
one time. However, more than one alias can be associated with a stream. Most
built-in predicates which have a stream-term as an input argument also accept
a stream alias as that argument. However, built-in predicates which return a
stream-term do not accept a stream alias.

\SPart{Standard streams}: three streams are predefined and open during the
execution of every goal: the standard input stream which has the alias
\IdxPKD{user\_input}, the standard output stream which has the alias
\IdxPKD{user\_output} and the standard error stream which has the alias
\IdxPKD{user\_error}. A goal which attempts to close either standard stream
succeeds, but does not close the stream.

\SPart{Current streams}: during execution there is a current input stream
and a current output stream. By default, the current input and output
streams are the standard input and output streams, but the built-in
predicates \IdxPB{set\_input/1} \RefSP{set-input/1} and
\IdxPB{set\_output/1} \RefSP{set-output/1} can be used to change them.
When the current input stream is closed, the standard input stream becomes
the current input stream. When the current output stream is closed, the
standard output stream becomes the current output stream.

\SPart{Text streams and binary streams}: a text stream is a sequence of
characters. A text stream is also regarded as a sequence of lines where each
line is a possibly empty sequence of characters followed by a new line
character. GNU Prolog may add or remove space characters at the ends of lines
in order to conform to the conventions for representing text streams in the
operating system. A binary stream is a sequence of bytes. Only a few
built-in predicates can deal with binary streams, e.g.
\IdxPB{get\_byte/2} \RefSP{Byte-input/output}.

\SPart{Stream positions}: the stream position of a stream identifies an
absolute position of the source/sink to which the stream is connected and
defines where in the source/sink the next input or output will take place. A
stream position is a ground term of the form
\texttt{'\$stream\_position'(I1, I2, I3, I4)} where \texttt{I1},
\texttt{I2}, \texttt{I3} and \texttt{I4} are integers. Stream positions are
used to reposition a stream (when possible) using for instance
\IdxPB{set\_stream\_position/2} \RefSP{set-stream-position/2}.

\SPart{The position end of stream}: when all data of a stream
\Param{S} has been input \Param{S} has a stream position
end-of-stream. At this stream position a goal to input more data will return
a specific value to indicate that end of stream has been reached (e.g.
\texttt{-1} for \texttt{get\_code/2} or \texttt{end\_of\_file} for
\texttt{get\_char/2},\ldots). When this terminating value has been input, the
stream has a stream position past-end-of-stream.

\SPart{Buffering mode}: input/output on a stream can be buffered
(line-buffered or block-buffered) or not buffered at all. The buffering mode
can be specified at open time or using \IdxPB{set\_stream\_buffering/2}
\RefSP{set-stream-buffering/2}. Line buffering is used on output streams,
output data are only written to the sink when a new-line character is output
(or at the close time). Block buffering is used on input or output. On input
streams, when an input is requested on the source, if the buffer is empty,
all available characters are read (within the limits of the size of the
buffer), subsequent reads will first use the characters in the buffer. On
output streams, output data are stored in the buffer and only when the
buffer is full is it physically written on the sink. Thus, an output to a
buffered stream may not be sent immediately to the sink connected to that
stream. When it is necessary to be certain that output has been delivered,
the built-in predicate \IdxPB{flush\_output/1} \RefSP{flush-output/1}
should be used. Finally, it is also possible to use non-buffered streams, in
that case input/output are directly done on the connected source/sink. This
can be useful for communication purposes (e.g. sockets) or when a precise
control is needed, e.g. \IdxPB{select/5} \RefSP{wait/2}.

\SPart{Stream mirrors}: any stream may be associated with mirror streams
specified at open time or using \IdxPB{add\_stream\_mirror/2}
\RefSP{add-stream-mirror/2}. Then, all characters/bytes read from/written to
the stream are also written on each mirror stream.  The association
automatically ends when either the stream or the mirror stream is closed. It
is also possible to explicitly remove a mirror stream using
\IdxPB{remove\_stream\_mirror/2}
\RefSP{remove-stream-mirror/2}.


\subsubsection{\IdxPBD{current\_input/1}}

\begin{TemplatesOneCol}
current\_input(?stream)

\end{TemplatesOneCol}

\Description

\texttt{current\_input(Stream)} unifies \texttt{Stream} with the stream-term
identifying the current input stream.

\begin{PlErrors}

\ErrCond{\texttt{Stream} is neither a variable nor a stream}
\ErrTerm{domain\_error(stream, Stream)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{current\_output/1}}

\begin{TemplatesOneCol}
current\_output(?stream)

\end{TemplatesOneCol}

\Description

\texttt{current\_output(Stream)} unifies \texttt{Stream} with the
stream-term identifying the current output stream.

\begin{PlErrors}

\ErrCond{\texttt{Stream} is neither a variable nor a stream}
\ErrTerm{domain\_error(stream, Stream)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{set\_input/1}\label{set-input/1}}

\begin{TemplatesOneCol}
set\_input(+stream\_or\_alias)

\end{TemplatesOneCol}

\Description

\texttt{set\_input(SorA)} sets the current input stream to be the stream
associated with the stream-term or alias \texttt{SorA}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{set\_output/1}\label{set-output/1}}

\begin{TemplatesOneCol}
set\_output(+stream\_or\_alias)

\end{TemplatesOneCol}

\Description

\texttt{set\_output(SorA)} sets the current output stream to be the stream
associated with the stream-term or alias \texttt{SorA}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an input stream}
\ErrTerm{permission\_error(output, stream, SorA)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{open/4},\label{open/4}
               \IdxPBD{open/3}}


\begin{TemplatesOneCol}
open(+source\_sink, +io\_mode, -stream, +stream\_option\_list)\\
open(+source\_sink, +io\_mode, -stream)

\end{TemplatesOneCol}

\Description

\texttt{open(SourceSink, Mode, Stream, Options)} opens the source/sink
\texttt{SourceSink} for input or output as indicated by \texttt{Mode} and
the list of stream-options \texttt{Options} and unifies \texttt{Stream} with
the stream-term which is associated with this stream. See
\IdxPB{absolute\_file\_name/2} for information about the syntax of
\texttt{SourceSink} \RefSP{absolute-file-name/2}.

\SPart{Input/output modes}: \texttt{Mode} is an atom which defines the
input/output operations that may be performed the stream. Possible modes
are:

\begin{itemize}

\item \IdxPMD{read}: the source/sink is a source and must already exist.
Input starts at the beginning of the source.

\item \IdxPMD{write}: the source/sink is a sink. If the sink already exists
then it is emptied else an empty sink is created. Output starts at the
beginning of that sink.

\item \IdxPMD{append}: the source/sink is a sink. If the sink does not exist
it is created. Output starts at the end of that sink.

\end{itemize}

\SPart{Stream options}: \texttt{Options} is a list of stream options. If
this list contains contradictory options, the rightmost option is the one
which applies. Possible options are:

\begin{itemize}

\item \AddPOD{type}\texttt{type(}\IdxPOD{text}/\IdxPOD{binary}\texttt{)}: specifies whether the
stream is a text stream or a binary stream. The default value is
\texttt{text}.

\item \AddPOD{reposition}\texttt{reposition(true}/\texttt{false)}: specifies
whether it is possible to reposition the stream. The default value is
\texttt{true} except if the stream cannot be repositioned (e.g. a terminal).

\item \AddPOD{eof\_action}\texttt{eof\_action(error}/\texttt{eof\_code}/\texttt{reset)}:
specifies the effect of attempting to input from a stream whose stream
position is past-end-of-stream:

\begin{itemize}

\item \IdxPOD{error}: a \texttt{permission\_error} is raised signifying that
no more input exists in this stream.

\item \IdxPOD{eof\_code}: the result of input is as if the stream position
is end-of-stream.

\item \IdxPOD{reset}: the stream position is reset so that it is not
past-end-of-stream, and another attempt is made to input from it (this is
useful when inputting from a terminal).

\end{itemize}

The default value is \texttt{eof\_code}.

\item \AddPOD{alias}\texttt{alias(Alias)}: specifies that the atom \texttt{Alias}
is to be an alias for the stream. By default no alias is attached to the
stream. Several aliases can be defined for a same stream.

\item \AddPOD{mirror}\texttt{mirror(Mirror)}: specifies the stream associated with
the stream-term or alias \texttt{Mirror} is a mirror for the stream. By
default no mirror is attached to the stream. Several mirrors can be defined
for a same stream.

\item \AddPOD{buffering}\texttt{buffering(none}/\texttt{line}/\texttt{block)}:
specifies which type of buffering is used by input/output operations on
this stream:

\begin{itemize}

\item \IdxPOD{none}: no buffering.

\item \IdxPOD{line}: output operations buffer data emitted until a new-line
occurs

\item \IdxPOD{block}: input/output operations buffer data until a given
number (implementation dependant) of characters/bytes have been treated.

\end{itemize}

The default value is \texttt{line} for a terminal (TTY), \texttt{block}
otherwise.

\end{itemize}

\texttt{open(SourceSink, Mode, Stream)} is equivalent to
\texttt{open(SourceSink, Mode, Stream, [])}.

\begin{PlErrors}

\ErrCond{\texttt{SourceSink} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Mode} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Options} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Mode} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Mode)}

\ErrCond{\texttt{Options} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Options)}

\ErrCond{\texttt{Stream} is not a variable}
\ErrTerm{uninstantiation\_error(Stream)}

\ErrCond{\texttt{SourceSink} is neither a variable nor a source/sink}
\ErrTerm{domain\_error(source\_sink, SourceSink)}

\ErrCond{\texttt{Mode} is an atom but not an input/output mode}
\ErrTerm{domain\_error(io\_mode, Mode)}

\ErrCond{an element \texttt{E} of the \texttt{Options} list is neither a
variable nor a stream-option}
\ErrTerm{domain\_error(stream\_option, E)}

\ErrCond{the source/sink specified by \texttt{SourceSink} does not exist}
\ErrTerm{existence\_error(source\_sink, SourceSink)}

\ErrCond{the source/sink specified by \texttt{SourceSink} cannot be opened}
\ErrTerm{permission\_error(open, source\_sink, SourceSink)}

\ErrCond{an element \texttt{E} of the \texttt{Options} list is
\texttt{alias(A)} and \texttt{A} is already associated with an open stream}
\ErrTerm{permission\_error(open, source\_sink, alias(A))}

\ErrCond{an element \texttt{E} of the \texttt{Options} list is
\texttt{mirror(M)} and \texttt{M} is not associated with an open stream}
\ErrTerm{existence\_error(stream, M)}

\ErrCond{an element \texttt{E} of the \texttt{Options} list is
\texttt{mirror(M)} and \texttt{M} is an input stream}
\ErrTerm{permission\_error(output, stream, M)}

\ErrCond{an element \texttt{E} of the \texttt{Options} list is
\texttt{reposition(true)} and it is not possible to reposition this stream}
\ErrTerm{permission\_error(open, source\_sink, reposition(true))}

\end{PlErrors}

\Portability

ISO predicates. The \texttt{mirror} and \texttt{buffering} stream options
are GNU Prolog extensions.

\subsubsection{\IdxPBD{close/2},\label{close/2}
               \IdxPBD{close/1}}


\begin{TemplatesOneCol}
close(+stream\_or\_alias, +close\_option\_list)\\
close(+stream\_or\_alias)

\end{TemplatesOneCol}

\Description

\texttt{close(SorA, Options)} closes the stream associated with the stream-term
or alias \texttt{SorA}. If \texttt{SorA} is the standard input stream or the
standard output stream \texttt{close/2} simply succeeds else the associated
source/sink is physically closed. If \texttt{SorA} is the current input
stream the current input stream becomes the standard input stream
\IdxPK{user\_input}. If \texttt{SorA} is the current output stream the
current output stream becomes the standard output stream
\IdxPK{user\_output}.

\SPart{Close options}: \texttt{Options} is a list of close options. For the
moment only one option is available:

\begin{itemize}

\item \AddPOD{force}\texttt{force(true}/\texttt{false)}: with \texttt{false}, if
an error occurs when trying to close the source/sink, the stream is not
closed and an error (\texttt{system\_error} or \texttt{resource\_error}) is
raised (but \texttt{close/2} succeeds). With \texttt{true}, if an error
occurs it is ignored and the stream is closed. The purpose of
\texttt{force/1} option is to allow an error handling routine to do its best
to reclaim resources. The default value is \texttt{false}.

\end{itemize}

\texttt{close(SorA)} is equivalent to \texttt{close(SorA, [])}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Options} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Options} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Options)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{an element \texttt{E} of the \texttt{Options} list is neither a
variable nor a close-option}
\ErrTerm{domain\_error(close\_option, E)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} needs a special close \RefSP{Constant-term-streams}}
\ErrTerm{system\_error(needs\_special\_close)}

\end{PlErrors}

\Portability

ISO predicates. The \texttt{system\_error(needs\_special\_close)} is a
GNU Prolog extension.

\subsubsection{\IdxPBD{flush\_output/1},\label{flush-output/1}
               \IdxPBD{flush\_output/0}}


\begin{TemplatesOneCol}
flush\_output(+stream\_or\_alias)\\
flush\_output

\end{TemplatesOneCol}

\Description

\texttt{flush\_output(SorA)} sends any buffered output characters/bytes to
the stream.

\texttt{flush\_output/0} applies to the current output stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an input stream}
\ErrTerm{permission\_error(output, stream, SorA)}

\end{PlErrors}

\Portability

ISO predicates.

\subsubsection{\IdxPBD{current\_stream/1}\label{current-stream/1}}

\begin{TemplatesOneCol}
current\_stream(?stream)

\end{TemplatesOneCol}

\Description

\texttt{current\_stream(Stream)} succeeds if there exists
a stream-term that unifies with \texttt{Stream}. This predicate is
re-executable on backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Stream} is neither a variable nor a stream-term}
\ErrTerm{domain\_error(stream, Stream)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{stream\_property/2}\label{stream-property/2}}


\begin{TemplatesOneCol}
stream\_property(?stream, ?stream\_property)

\end{TemplatesOneCol}

\Description

\texttt{stream\_property(Stream, Property)} succeeds if
\texttt{current\_stream(Stream)} succeeds \RefSP{current-stream/1} and if
\texttt{Property} unifies with one of the properties of the stream. This
predicate is re-executable on backtracking.

\SPart{Stream properties}:

\begin{itemize}

\item \AddPPD{file\_name}\texttt{file\_name(F)}: the name of the connected
source/sink.

\item \AddPPD{mode}\texttt{mode(M)}: \texttt{M} is the open mode (\texttt{read},
\texttt{write}, \texttt{append}).

\item \IdxPPD{input}: if it is an input stream.

\item \IdxPPD{output}: if it is an output stream.

\item \AddPPD{alias}\texttt{alias(A)}: \texttt{A} is an alias of the stream.

\item \AddPPD{mirror}\texttt{mirror(M)}: \texttt{M} is a mirror stream of the
stream.

\item \AddPPD{type}\texttt{type(T)}: \texttt{T} is the type of the stream
(\texttt{text}, \texttt{binary}).

\item \AddPPD{reposition}\texttt{reposition(R)}: \texttt{R} is the reposition
boolean (\texttt{true}, \texttt{false}).

\item \AddPPD{eof\_action}\texttt{eof\_action(A)}: \texttt{A} is the end-of-file
action (\texttt{error}, \texttt{eof\_code}, \texttt{reset}).

\item \AddPPD{buffering}\texttt{buffering(B)}: \texttt{B} is the buffering mode
(\texttt{none}, \texttt{line}, \texttt{block}).

\item \AddPPD{end\_of\_stream}\texttt{end\_of\_stream(E)}: \texttt{E} is the
current end-of-stream status (\texttt{not}, \texttt{at}, \texttt{past}). If
the stream position is end-of-stream then \texttt{E} is unified with
\texttt{at} else if the stream position is past-end-of-stream then \texttt{E}
is unified with \texttt{past} else \texttt{E} is unified with \texttt{not}.

\item \AddPPD{position}\texttt{position(P)}: \texttt{P} is the stream-position
term associated with the current position.

\end{itemize}

\begin{PlErrors}

\ErrCond{\texttt{Stream} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Stream} is neither a variable nor a stream-term}
\ErrTerm{domain\_error(stream, Stream)}

\ErrCond{\texttt{Property} is neither a variable nor a stream property}
\ErrTerm{domain\_error(stream\_property, Property)}

\ErrCond{\texttt{Property} = \texttt{file\_name(E)},\texttt{ mode(E)},
\texttt{alias(E)}, \texttt{end\_of\_stream(E)}, \texttt{eof\_action(E)},
\texttt{reposition(E)}, \texttt{type(E)} or \texttt{buffering(E)} and
\texttt{E} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, E)}

\end{PlErrors}

\Portability

ISO predicate. The \texttt{buffering/1} property is a GNU Prolog extension.

\subsubsection{\IdxPBD{at\_end\_of\_stream/1},
               \IdxPBD{at\_end\_of\_stream/0}}


\begin{TemplatesOneCol}
at\_end\_of\_stream(+stream\_or\_alias)\\
at\_end\_of\_stream

\end{TemplatesOneCol}

\Description

\texttt{at\_end\_of\_stream(SorA)} succeeds if the stream associated with
stream-term or alias \texttt{SorA} has a stream position end-of-stream or
past-end-of-stream. This predicate can be defined using
\IdxPB{stream\_property/2} \RefSP{stream-property/2}.

\texttt{at\_end\_of\_stream/0} applies to the current input stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\end{PlErrors}

\Portability

ISO predicates. The \texttt{permission\_error(input, stream, SorA)} is a
GNU Prolog extension.

\subsubsection{\IdxPBD{stream\_position/2}\label{stream-position/2}}

\begin{TemplatesOneCol}
stream\_position(+stream\_or\_alias, ?stream\_position)

\end{TemplatesOneCol}

\Description

\texttt{stream\_position(SorA, Position)} succeeds unifying
\texttt{Position} with the stream-position term associated with the current
position of the stream-term or alias \texttt{SorA}. This predicate can be
defined using \IdxPB{stream\_property/2} \RefSP{stream-property/2}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{Position} is neither a variable nor a stream-position term}
\ErrTerm{domain\_error(stream\_position, Position)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{set\_stream\_position/2}\label{set-stream-position/2}}

\begin{TemplatesOneCol}
set\_stream\_position(+stream\_or\_alias, +stream\_position)

\end{TemplatesOneCol}

\Description

\texttt{set\_stream\_position(SorA, Position)} sets the position of
the stream associated with the stream-term or alias \texttt{SorA} to
\texttt{Position}. \texttt{Position} should have previously been returned by
\IdxPB{stream\_property/2} \RefSP{stream-property/2} or by
\IdxPB{stream\_position/2} \RefSP{stream-position/2}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Position} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{Position} is neither a variable nor a stream-position term}
\ErrTerm{domain\_error(stream\_position, Position)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} has stream property \texttt{reposition(false)}}
\ErrTerm{permission\_error(reposition, stream, SorA)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{seek/4}}

\begin{TemplatesOneCol}
seek(+stream\_or\_alias, +stream\_seek\_method, +integer, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{seek(SorA, Whence, Offset, NewOffset)} sets the position of
the stream associated with the stream-term or alias \texttt{SorA} to
\texttt{Offset} according to \texttt{Whence} and unifies \texttt{NewOffset}
with the new offset from the beginning of the file. \texttt{seek/4} can only
be used on binary streams. \texttt{Whence} is an atom from:

\begin{itemize}

\item \IdxPWD{bof}: the position is set relatively to the begin of the file
(\texttt{Offset} should be $\geq$ 0).

\item \IdxPWD{current}: the position is set relatively to the current
position (\texttt{Offset} can be $\geq$ 0 or $\leq$ 0).

\item \IdxPWD{eof}: the position is set relatively to the end of the file
(\texttt{Offset} should be $\leq$ 0).

\end{itemize}

This predicate is an interface to the C Unix function \texttt{lseek(2)}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Whence} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Offset} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{Whence} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Whence)}

\ErrCond{\texttt{Whence} is an atom but not a valid stream seek method}
\ErrTerm{domain\_error(stream\_seek\_method, Whence)}

\ErrCond{\texttt{Offset} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Offset)}

\ErrCond{\texttt{NewOffset} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, NewOffset)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} has stream property \texttt{reposition(false)}}
\ErrTerm{permission\_error(reposition, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a text stream}
\ErrTerm{permission\_error(reposition, text\_stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{character\_count/2}}

\begin{TemplatesOneCol}
character\_count(+stream\_or\_alias, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{character\_count(SorA, Count)} unifies \texttt{Count} with the
number of characters/bytes read/written on the stream associated with
stream-term or alias \texttt{SorA}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Count} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Count)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{line\_count/2}\label{line-count/2}}

\begin{TemplatesOneCol}
line\_count(+stream\_or\_alias, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{line\_count(SorA, Count)} unifies \texttt{Count} with the number of
lines read/written on the stream associated with the stream-term or alias
\texttt{SorA}. This predicate can only be used on text streams.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Count} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Count)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(access, binary\_stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{line\_position/2}\label{line-position/2}}

\begin{TemplatesOneCol}
line\_position(+stream\_or\_alias, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{line\_position(SorA, Count)} unifies
\texttt{Count} with the number of characters read/written on the current
line of the stream associated with the stream-term or alias
\texttt{SorA}. This predicate can only be used on text streams.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Count} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Count)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(access, binary\_stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{stream\_line\_column/3}}

\begin{TemplatesOneCol}
stream\_line\_column(+stream\_or\_alias, ?integer, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{stream\_line\_column(SorA, Line, Column)} unifies \texttt{Line}
(resp. \texttt{Column}) with the current line number (resp. column number)
of the stream associated with the stream-term or alias \texttt{SorA}. This
predicate can only be used on text streams. Note that \texttt{Line}
corresponds to the value returned by \IdxPB{line\_count/2} + 1
\RefSP{line-count/2} and \texttt{Column} to the value returned
by \texttt{line\_position/2} + 1 \RefSP{line-position/2}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Line} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Line)}

\ErrCond{\texttt{Column} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Column)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(access, binary\_stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{set\_stream\_line\_column/3}}

\begin{TemplatesOneCol}
set\_stream\_line\_column(+stream\_or\_alias, +integer, +integer)

\end{TemplatesOneCol}

\Description

\texttt{set\_stream\_line\_column(SorA, Line, Column)} sets the stream
position of the stream associated with the stream-term or alias \texttt{SorA}
according to the line number \texttt{Line} and the column number
\texttt{Column}. This predicate can only be used on text streams. It first
repositions the stream to the beginning of the file and then reads character
by character until the required position is reached.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Line} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Column} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Line} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Line)}

\ErrCond{\texttt{Column} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Column)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(reposition, binary\_stream, SorA)}

\ErrCond{\texttt{SorA} has stream property \texttt{reposition(false)}}
\ErrTerm{permission\_error(reposition, stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{add\_stream\_alias/2}\label{add-stream-alias/2}}

\begin{TemplatesOneCol}
add\_stream\_alias(+stream\_or\_alias, +atom)

\end{TemplatesOneCol}

\Description

\texttt{add\_stream\_alias(SorA, Alias)} adds \texttt{Alias} as a new alias
to the stream associated with the stream-term or alias \texttt{SorA}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Alias} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Alias} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Alias)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{Alias} is already associated with an open stream}
\ErrTerm{permission\_error(add\_alias, source\_sink, alias(Alias))}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{current\_alias/2}}

\begin{TemplatesOneCol}
current\_alias(?stream, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{current\_alias(Stream, Alias)} succeeds if
\texttt{current\_stream(Stream)} succeeds \RefSP{current-stream/1} and if
\texttt{Alias} unifies with one of the aliases of the stream. It can be
defined using \IdxPB{stream\_property/2} \RefSP{stream-property/2}. This
predicate is re-executable on backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Stream} is neither a variable nor a stream-term}
\ErrTerm{domain\_error(stream, Stream)}

\ErrCond{\texttt{Alias} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Alias)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{add\_stream\_mirror/2}\label{add-stream-mirror/2}}

\begin{TemplatesOneCol}
add\_stream\_mirror(+stream\_or\_alias, +stream\_or\_alias)

\end{TemplatesOneCol}

\Description

\texttt{add\_stream\_mirror(SorA, Mirror)} adds the stream associated with
the stream-term or alias \texttt{Mirror} as a new mirror to the stream
associated with the stream-term or alias \texttt{SorA}. After this, all
characters (or bytes) read from (or written to) \texttt{SorA} are also
written to \texttt{Mirror}. This mirroring occurs until \texttt{Mirror} is
explicitly removed using \IdxPB{remove\_stream\_mirror/2}
\RefSP{remove-stream-mirror/2} or implicitly when \texttt{Mirror} is closed.
Several mirror streams can be associated with a same stream. If \texttt{Mirror}
represents the same stream as \texttt{SorA} or if \texttt{Mirror} is already
a mirror for \texttt{SorA}, no mirror is added.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Mirror} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{Mirror} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, Mirror)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{Mirror} is not associated with an open stream}
\ErrTerm{existence\_error(stream, Mirror)}

\ErrCond{\texttt{Mirror} is an input stream}
\ErrTerm{permission\_error(output, stream, Mirror)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{remove\_stream\_mirror/2}\label{remove-stream-mirror/2}}

\begin{TemplatesOneCol}
remove\_stream\_mirror(+stream\_or\_alias, +stream\_or\_alias)

\end{TemplatesOneCol}

\Description

\texttt{remove\_stream\_mirror(SorA, Mirror)} removes the stream associated
with the stream-term or alias \texttt{Mirror} from the list of mirrors of the
stream associated with the stream-term or alias \texttt{SorA}. This predicate
fails if \texttt{Mirror} is not a mirror stream for \texttt{SorA}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Mirror} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{Mirror} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, Mirror)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{Mirror} is not associated with an open stream}
\ErrTerm{existence\_error(stream, Mirror)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{current\_mirror/2}}

\begin{TemplatesOneCol}
current\_mirror(?stream, ?stream)

\end{TemplatesOneCol}

\Description

\texttt{current\_mirror(Stream, M)} succeeds if
\texttt{current\_stream(Stream)} succeeds \RefSP{current-stream/1} and if
\texttt{M} unifies with one of the mirrors of the stream. It can be
defined using \IdxPB{stream\_property/2} \RefSP{stream-property/2}. This
predicate is re-executable on backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Stream} is neither a variable nor a stream-term}
\ErrTerm{domain\_error(stream, Stream)}

\ErrCond{\texttt{M} is neither a variable nor a stream-term}
\ErrTerm{domain\_error(stream, M)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{set\_stream\_type/2}\label{set-stream-type/2}}

\begin{TemplatesOneCol}
set\_stream\_type(+stream\_or\_alias, +atom)

\end{TemplatesOneCol}

\Description

\texttt{set\_stream\_type(SorA, Type)} updates the type associated with
stream-term or alias \texttt{SorA}. The value of \texttt{Type} is an atom in
\IdxPO{text} or \IdxPO{binary} as for \IdxPB{open/4} \RefSP{open/4}.
The type of a stream can only be changed before any input/output operation
is executed.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Type} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Type} is neither a variable nor a valid type}
\ErrTerm{domain\_error(stream\_type, Type)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{An I/O operation has already been executed on \texttt{SorA}}
\ErrTerm{permission\_error(modify, stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{set\_stream\_eof\_action/2}}

\begin{TemplatesOneCol}
set\_stream\_eof\_action(+stream\_or\_alias, +atom)

\end{TemplatesOneCol}

\Description

\texttt{set\_stream\_eof\_action(SorA, Action)}
updates the \texttt{eof\_action} option associated with the stream-term or
alias \texttt{SorA}. The value of \texttt{Action} is one of the atoms
\IdxPO{error}, \IdxPO{eof\_code}, \IdxPO{reset} as for \IdxPB{open/4} \RefSP{open/4}.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Action} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Action} is neither a variable nor a valid eof action}
\ErrTerm{domain\_error(eof\_action, Action)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(modify, stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{set\_stream\_buffering/2}\label{set-stream-buffering/2}}

\begin{TemplatesOneCol}
set\_stream\_buffering(+stream\_or\_alias, +atom)

\end{TemplatesOneCol}

\Description

\texttt{set\_stream\_buffering(SorA, Buffering)}
updates the buffering mode associated with the stream-term or alias
\texttt{SorA}. The value of \texttt{Buffering} is one of the atoms
\IdxPO{none}, \IdxPO{line} or \IdxPO{block} as for \IdxPB{open/4}
\RefSP{open/4}. This predicate may only be used after opening a stream
and before any other operations have been performed on it.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Buffering} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Buffering} is neither a variable nor a valid buffering
mode}
\ErrTerm{domain\_error(buffering\_mode, Buffering)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{Constant term streams}
\label{Constant-term-streams}

\subsubsection{Introduction}
\label{Introduction:(Constant-term-streams)}
Constant term streams allow the user to consider a constant term (atom,
character list or character code list) as a source/sink by associating to
them a stream. Reading from a constant term stream will deliver the
characters of the constant term as if they had been read from a standard
file. Characters written on a constant term stream are stored to form the
final constant term when the stream is closed. The built-in predicates
described in this section allow the user to open and close a constant term
stream for input or output. However, very often, a constant term stream is
created to be only read or written once and then closed. To avoid the
creation and the destruction of such a stream, GNU Prolog offers several
built-in predicates to perform single input/output from/to constant terms
\RefSP{Input/output-from/to-constant-terms}.

\subsubsection{\IdxPBD{open\_input\_atom\_stream/2},
               \IdxPBD{open\_input\_chars\_stream/2}, \\
               \IdxPBD{open\_input\_codes\_stream/2}}

\begin{TemplatesOneCol}
open\_input\_atom\_stream(+atom, -stream)\\
open\_input\_chars\_stream(+character\_list, -stream)\\
open\_input\_codes\_stream(+character\_code\_list, -stream)

\end{TemplatesOneCol}

\Description

\texttt{open\_input\_atom\_stream(Atom, Stream)} unifies \texttt{Stream}
with the stream-term which is associated with a new input text-stream whose
data are the characters of \texttt{Atom}.

\texttt{open\_input\_chars\_stream(Chars, Stream)} is similar to
\texttt{open\_input\_atom\_stream/2} except that data are the content of the
character list \texttt{Chars}.

\texttt{open\_input\_codes\_stream(Codes, Stream)} is similar to
\texttt{open\_input\_atom\_stream/2} except that data are the content of the
character code list \texttt{Codes}.

\begin{PlErrors}

\ErrCond{\texttt{Stream} is not a variable}
\ErrTerm{uninstantiation\_error(Stream)}

\ErrCond{\texttt{Atom} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Chars} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Codes} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Atom} is neither a variable nor a an atom}
\ErrTerm{type\_error(atom, Atom)}

\ErrCond{\texttt{Chars} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Chars)}

\ErrCond{\texttt{Codes} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Codes)}

\ErrCond{an element \texttt{E} of the \texttt{Chars} list is neither a
variable nor a character}
\ErrTerm{type\_error(character, E)}

\ErrCond{an element \texttt{E} of the \texttt{Codes} list is neither a
variable nor an integer}
\ErrTerm{type\_error(integer, E)}

\ErrCond{an element \texttt{E} of the \texttt{Codes} list is an integer but
not a character code}
\ErrTerm{representation\_error(character\_code)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{close\_input\_atom\_stream/1},
               \IdxPBD{close\_input\_chars\_stream/1}, \\
               \IdxPBD{close\_input\_codes\_stream/1}}

\begin{TemplatesOneCol}
close\_input\_atom\_stream(+stream\_or\_alias)\\
close\_input\_chars\_stream(+stream\_or\_alias)\\
close\_input\_codes\_stream(+stream\_or\_alias)

\end{TemplatesOneCol}

\Description

\texttt{close\_input\_atom\_stream(SorA)} closes the constant term stream
associated with the stream-term or alias \texttt{SorA}. \texttt{SorA} must a
stream open with \texttt{open\_input\_atom\_stream/2}
\RefSP{Introduction:(Constant-term-streams)}.

\texttt{close\_input\_chars\_stream(SorA)} acts similarly for a character
list stream.

\texttt{close\_input\_codes\_stream(SorA)} acts similarly for a character
code list stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(close, stream, SorA)}

\ErrCond{\texttt{SorA} is a stream-term or alias but does not refer to a
constant term stream.}
\ErrTerm{domain\_error(term\_stream\_or\_alias, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{open\_output\_atom\_stream/1},\label{open-output-atom-stream/1}
               \IdxPBD{open\_output\_chars\_stream/1}, \\
               \IdxPBD{open\_output\_codes\_stream/1}}


\begin{TemplatesOneCol}
open\_output\_atom\_stream(-stream)\\
open\_output\_chars\_stream(-stream)\\
open\_output\_codes\_stream(-stream)

\end{TemplatesOneCol}

\Description

\texttt{open\_output\_atom\_stream(Stream)} unifies \texttt{Stream} with the
stream-term which is associated with a new output text-stream. All characters
written to this stream are collected and will be returned as an atom when
the stream is closed by \texttt{close\_output\_atom\_stream/2}
\RefSP{close-output-atom-stream/2}.

\texttt{open\_output\_chars\_stream(Stream)} is similar to
\texttt{open\_output\_atom\_stream/1} except that the result will be a
character list.

\texttt{open\_output\_codes\_stream(Stream)} is similar to
\texttt{open\_output\_atom\_stream/1} except that the result will be a
character code list.

\begin{PlErrors}

\ErrCond{\texttt{Stream} is not a variable}
\ErrTerm{uninstantiation\_error(Stream)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{close\_output\_atom\_stream/2},\label{close-output-atom-stream/2}
               \IdxPBD{close\_output\_chars\_stream/2}, \\
               \IdxPBD{close\_output\_codes\_stream/2}}


\begin{TemplatesOneCol}
close\_output\_atom\_stream(+stream\_or\_alias, ?atom)\\
close\_output\_chars\_stream(+stream\_or\_alias, ?character\_list)\\
close\_output\_codes\_stream(+stream\_or\_alias, ?character\_code\_list)

\end{TemplatesOneCol}

\Description

\texttt{close\_output\_atom\_stream(SorA, Atom)} closes the constant term
stream associated with the stream-term or alias \texttt{SorA}. \texttt{SorA} must
be associated with a stream open with \texttt{open\_output\_atom\_stream/1}
\RefSP{open-output-atom-stream/1}.  \texttt{Atom} is unified with an atom
formed with all characters written on the stream.

\texttt{close\_output\_chars\_stream(SorA, Chars)} acts similarly for a
character list stream.

\texttt{close\_output\_codes\_stream(SorA, Codes)} acts similarly for a
character code list stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Atom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom)}

\ErrCond{\texttt{Chars} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Chars)}

\ErrCond{\texttt{Codes} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Codes)}

\ErrCond{an element \texttt{E} of the \texttt{Chars} list is neither a
variable nor a character}
\ErrTerm{type\_error(character, E)}

\ErrCond{an element \texttt{E} of the \texttt{Codes} list is neither a
variable nor an integer}
\ErrTerm{type\_error(integer, E)}

\ErrCond{an element \texttt{E} of the \texttt{Codes} list is an integer but
not a character code}
\ErrTerm{representation\_error(character\_code)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an input stream}
\ErrTerm{permission\_error(close, stream, SorA)}

\ErrCond{\texttt{SorA} is a stream-term or alias but does not refer to a
constant term stream}
\ErrTerm{domain\_error(term\_stream\_or\_alias, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsection{Character input/output}
These built-in predicates enable a single character or character code to be
input from and output to a text stream. The atom \texttt{end\_of\_file} is
returned as character to indicate the end-of-file. \texttt{-1} is returned
as character code to indicate the end-of-file.

\subsubsection{\IdxPBD{get\_char/2},\label{get-char/2}
               \IdxPBD{get\_char/1},
               \IdxPBD{get\_code/1},
               \IdxPBD{get\_code/2}}


\begin{TemplatesOneCol}
get\_char(+stream\_or\_alias, ?in\_character)\\
get\_char(?in\_character)\\
get\_code(+stream\_or\_alias, ?in\_character\_code)\\
get\_code(?in\_character\_code)

\end{TemplatesOneCol}

\Description

\texttt{get\_char(SorA, Char)} succeeds if \texttt{Char} unifies with the
next character read from the stream associated with the stream-term or alias
\texttt{SorA}.

\texttt{get\_code/2} is similar to \texttt{get\_char/2} but deals with
character codes.

\texttt{get\_char/1} and \texttt{get\_code/1} apply to the current input
stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Char} is neither a variable nor an in-character}
\ErrTerm{type\_error(in\_character, Char)}

\ErrCond{\texttt{Code} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Code)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(input, binary\_stream, SorA)}

\ErrCond{\texttt{SorA} has stream properties \texttt{end\_of\_stream(past)}
and \texttt{eof\_action(error)}}
\ErrTerm{permission\_error(input, past\_end\_of\_stream, SorA)}

\ErrCond{The entity input from the stream is not a character}
\ErrTerm{representation\_error(character)}

\ErrCond{\texttt{Code} is an integer but not an in-character code}
\ErrTerm{representation\_error(in\_character\_code)}

\end{PlErrors}

\Portability

ISO predicates.

\subsubsection{\IdxPBD{get\_key/2},
               \IdxPBD{get\_key/1}
	       \IdxPBD{get\_key\_no\_echo/2},
               \IdxPBD{get\_key\_no\_echo/1}}

\begin{TemplatesOneCol}
get\_key(+stream\_or\_alias, ?integer)\\
get\_key(?integer)\\
get\_key\_no\_echo(+stream\_or\_alias, ?integer)\\
get\_key\_no\_echo(?integer)

\end{TemplatesOneCol}

\Description

\texttt{get\_key(SorA, Code)} succeeds if \texttt{Code} unifies with the
character code of the next key read from the stream associated with the
stream-term or alias \texttt{SorA}. It is intended to read a single key from
the keyboard (thus \texttt{SorA} should refer to current input stream). No
buffering is performed (a character is read as soon as available) and
function keys can also be read (in that case, \texttt{Code} is an integer $>$
255). The read character is echoed if it is printable.

This facility is only possible if the \IdxK{linedit} facility has been
installed \RefSP{The-line-editor} otherwise \texttt{get\_key/2} behaves
similarly to \IdxPB{get\_code/2} \RefSP{get-char/2} (the code of the first
character is returned) but also pumps remaining characters until a character
$<$ space (0x20) is read (in particular RETURN). The same behavior
occurs if \texttt{SorA} does not refer to the current input stream or if
this stream is not attached to a terminal.

\texttt{get\_key\_no\_echo/2} behaves similarly to \texttt{get\_key/2}
except that the read character is not echoed.

\texttt{get\_key/1} and \texttt{get\_key\_no\_echo/1} apply to the current
input stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Code} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Code)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(input, binary\_stream, SorA)}

\ErrCond{\texttt{SorA} has stream properties \texttt{end\_of\_stream(past)}
and \texttt{eof\_action(error)}}
\ErrTerm{permission\_error(input, past\_end\_of\_stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{peek\_char/2},
               \IdxPBD{peek\_char/1},
               \IdxPBD{peek\_code/1},
               \IdxPBD{peek\_code/2}}

\begin{TemplatesOneCol}
peek\_char(+stream\_or\_alias, ?in\_character)\\
peek\_char(?in\_character)\\
peek\_code(+stream\_or\_alias, ?in\_character\_code)\\
peek\_code(?in\_character\_code)

\end{TemplatesOneCol}

\Description

\texttt{peek\_char(SorA, Char)} succeeds if \texttt{Char} unifies with the
next character that will be read from the stream associated with the stream-term
or alias \texttt{SorA}. The character is not read.

\texttt{peek\_code/2} is similar to \texttt{peek\_char/2} but deals with
character codes.

\texttt{peek\_char/1} and \texttt{peek\_code/1} apply to the current input
stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Char} is neither a variable nor an in-character}
\ErrTerm{type\_error(in\_character, Char)}

\ErrCond{\texttt{Code} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Code)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(input, binary\_stream, SorA)}

\ErrCond{\texttt{SorA} has stream properties \texttt{end\_of\_stream(past)}
and \texttt{eof\_action(error)}}
\ErrTerm{permission\_error(input, past\_end\_of\_stream, SorA)}

\ErrCond{The entity input from the stream is not a character}
\ErrTerm{representation\_error(character)}

\ErrCond{\texttt{Code} is an integer but not an in-character code}
\ErrTerm{representation\_error(in\_character\_code)}

\end{PlErrors}

\Portability

ISO predicates.

\subsubsection{\IdxPBD{unget\_char/2},
               \IdxPBD{unget\_char/1},
               \IdxPBD{unget\_code/2},
               \IdxPBD{unget\_code/1}}

\begin{TemplatesOneCol}
unget\_char(+stream\_or\_alias, +character)\\
unget\_char(+character)\\
unget\_code(+stream\_or\_alias, +character\_code)\\
unget\_code(+character\_code)

\end{TemplatesOneCol}

\Description

\texttt{unget\_char(SorA, Char)} pushes back \texttt{Char}
onto the stream associated with the stream-term or alias \texttt{SorA}.
\texttt{Char} will be the next character read by \texttt{get\_char/2}. The
maximum number of characters that can be cumulatively pushed back is given by
the \IdxPF{max\_unget} \Idx{Prolog flag} \RefSP{set-prolog-flag/2}.

\texttt{unget\_code/2} is similar to \texttt{unget\_char/2} but deals with
character codes.

\texttt{unget\_char/1} and \texttt{unget\_code/1} apply to the current input
stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Char} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Code} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Char} is neither a variable nor a character}
\ErrTerm{type\_error(character, Char)}

\ErrCond{\texttt{Code} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Code)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(input, binary\_stream, SorA)}

\ErrCond{\texttt{Code} is an integer but not a character code}
\ErrTerm{representation\_error(character\_code)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{put\_char/2},\label{put-char/2}
               \IdxPBD{put\_char/1},
               \IdxPBD{put\_code/1},
               \IdxPBD{put\_code/2},
               \IdxPBD{nl/1},
               \IdxPBD{nl/0}}


\begin{TemplatesOneCol}
put\_char(+stream\_or\_alias, +character)\\
put\_char(+character)\\
put\_code(+stream\_or\_alias, +character\_code)\\
put\_code(+character\_code)\\
nl(+stream\_or\_alias)\\
nl

\end{TemplatesOneCol}

\Description

\texttt{put\_char(SorA, Char)} writes \texttt{Char} onto the
stream associated with the stream-term or alias \texttt{SorA}.

\texttt{put\_code/2} is similar to \texttt{put\_char/2} but deals with
character codes.

\texttt{nl(SorA)} writes a new-line character onto the stream
associated with the stream-term or alias \texttt{SorA}. This is equivalent to
\texttt{put\_char(SorA, '{\bs}n')}.

\texttt{put\_char/1}, \texttt{put\_code/1} and \texttt{nl/0} apply to the
current output stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Char} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Code} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Char} is neither a variable nor a character}
\ErrTerm{type\_error(character, Char)}

\ErrCond{\texttt{Code} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Code)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an input stream}
\ErrTerm{permission\_error(output, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(output, binary\_stream, SorA)}

\ErrCond{\texttt{Code} is an integer but not a character code}
\ErrTerm{representation\_error(character\_code)}

\end{PlErrors}

\Portability

ISO predicates.

\subsection{Byte input/output}
\label{Byte-input/output}

These built-in predicates enable a single byte to be input from and output
to a binary stream. \texttt{-1} is returned to indicate the end-of-file.

\subsubsection{\IdxPBD{get\_byte/2},
               \IdxPBD{get\_byte/1}}

\begin{TemplatesOneCol}
get\_byte(+stream\_or\_alias, ?in\_byte)\\
get\_byte(?in\_byte)

\end{TemplatesOneCol}

\Description

\texttt{get\_byte(SorA, Byte)} succeeds if \texttt{Byte} unifies with the
next byte read from the stream associated with the stream-term or alias
\texttt{SorA}.

\texttt{get\_byte/1} applies to the current input stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Byte} is neither a variable nor an in-byte}
\ErrTerm{type\_error(in\_byte, Byte)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a text stream}
\ErrTerm{permission\_error(input, text\_stream, SorA)}

\ErrCond{\texttt{SorA} has stream properties \texttt{end\_of\_stream(past)}
and \texttt{eof\_action(error)}}
\ErrTerm{permission\_error(input, past\_end\_of\_stream, SorA)}

\end{PlErrors}

\Portability

ISO predicates.

\subsubsection{\IdxPBD{peek\_byte/2},
               \IdxPBD{peek\_byte/1}}

\begin{TemplatesOneCol}
peek\_byte(+stream\_or\_alias, ?in\_byte)\\
peek\_byte(?in\_byte)

\end{TemplatesOneCol}

\Description

\texttt{peek\_byte(SorA, Byte)} succeeds if \texttt{Byte} unifies with the
next byte that will be read from the stream associated with the stream-term or
alias \texttt{SorA}. The byte is not read.

\texttt{peek\_byte/1} applies to the current input stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Byte} is neither a variable nor an in-byte}
\ErrTerm{type\_error(in\_byte, Byte)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a text stream}
\ErrTerm{permission\_error(input, text\_stream, SorA)}

\ErrCond{\texttt{SorA} has stream properties \texttt{end\_of\_stream(past)}
and \texttt{eof\_action(error)}}
\ErrTerm{permission\_error(input, past\_end\_of\_stream, SorA)}

\end{PlErrors}

\Portability

ISO predicates.

\subsubsection{\IdxPBD{unget\_byte/2},
               \IdxPBD{unget\_byte/1}}

\begin{TemplatesOneCol}
unget\_byte(+stream\_or\_alias, +byte)\\
unget\_byte(+byte)

\end{TemplatesOneCol}

\Description

\texttt{unget\_byte(SorA, Byte)} pushes back \texttt{Byte} onto the stream
associated with the stream-term or alias \texttt{SorA}. \texttt{Byte} will be
the next byte read by \texttt{get\_byte/2}. The maximum number of bytes that
can be successively pushed back is given by the \IdxPF{max\_unget}
\Idx{Prolog flag} \RefSP{set-prolog-flag/2}.

\texttt{unget\_byte/1} applies to the current input stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Byte} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Byte} is neither a variable nor a byte}
\ErrTerm{type\_error(byte, Byte)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a text stream}
\ErrTerm{permission\_error(input, text\_stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{put\_byte/2},
               \IdxPBD{put\_byte/1}}

\begin{TemplatesOneCol}
put\_byte(+stream\_or\_alias, +byte)\\
put\_byte(+byte)

\end{TemplatesOneCol}

\Description

\texttt{put\_byte(SorA, Byte)} writes \texttt{Byte} onto the stream
associated with the stream-term or alias \texttt{SorA}.

\texttt{put\_byte/1} applies to the current output stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Byte} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Byte} is neither a variable nor a byte}
\ErrTerm{type\_error(byte, Byte)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(output, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a text stream}
\ErrTerm{permission\_error(output, text\_stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsection{Term input/output}
\label{Term-input/output}
These built-in predicates enable a Prolog term to be input from or output to
a text stream. The atom \texttt{end\_of\_file} is returned as term to
indicate the end-of-file. The syntax of such terms can also be altered by
changing the operators \RefSP{op/3:(Term-input/output)}, and making some
characters equivalent to others \RefSP{char-conversion/2} if the
\IdxPF{char\_conversion} \Idx{Prolog flag} is \texttt{on}
\RefSP{set-prolog-flag/2}. Double quoted tokens will be returned as an atom
or a character list or a character code list depending on the value of the
\IdxPF{double\_quotes} Prolog flag \RefSP{set-prolog-flag/2}. Similarly, back quoted tokens are returned depending on the value of the
\IdxPF{back\_quotes} Prolog flag.

\subsubsection{\IdxPBD{read\_term/3},\label{read-term/3}
               \IdxPBD{read\_term/2},
               \IdxPBD{read/2},
               \IdxPBD{read/1}}


\begin{TemplatesOneCol}
read\_term(+stream\_or\_alias, ?term, +read\_option\_list)\\
read\_term(?term, +read\_option\_list)\\
read(+stream\_or\_alias, ?term)\\
read(?term)

\end{TemplatesOneCol}

\Description

\texttt{read\_term(SorA, Term, Options)} is true if
\texttt{Term} unifies with the next term read from the stream associated
with the stream-term or alias \texttt{SorA} according to the options given by
\texttt{Options}.

\SPart{Read options}: \texttt{Options} is a list of read options. If this
list contains contradictory options, the rightmost option is the one which
applies. Possible options are:

\begin{itemize}

\item \AddPOD{variables}\texttt{variables(VL)}: \texttt{VL} is unified with the
list of all variables of the input term, in left-to-right traversal
order. Anonymous variables are included in the list \texttt{VL}.

\item \AddPOD{variable\_names}\texttt{variable\_names(VNL)}: \texttt{VNL} is
unified with the list of pairs \texttt{Name = Var} where \texttt{Var} is a
named variable of the term and \texttt{Name} is the atom associated with the
name of \texttt{Var}.  Anonymous variables are not included in the list
\texttt{VNL}.

\item \AddPOD{singletons}\texttt{singletons(SL)}: \texttt{SL} is unified with the
list of pairs \texttt{Name = Var} where \texttt{Var} is a named variable
which occurs only once in the term and \texttt{Name} is the atom associated
to the name of \texttt{Var}. Anonymous variables are not included in the list
\texttt{SL}.

\item \AddPOD{syntax\_error}\texttt{syntax\_error(error}/\texttt{warning}/\texttt{fail)}:
specifies the effect of a syntax error:

\begin{itemize}

\item \IdxPOD{error}: a \texttt{syntax\_error} is raised.

\item \IdxPOD{warning}: a warning message is displayed and the predicate
fails.

\item \IdxPOD{fail}: the predicate quietly fails.

\end{itemize}

The default value is the value of the \IdxPF{syntax\_error}
\Idx{Prolog flag} \RefSP{set-prolog-flag/2}.

\item \AddPOD{end\_of\_term}\texttt{end\_of\_term(dot}/\texttt{eof)}: specifies the
end-of-term delimiter: \texttt{dot} is the classical full-stop delimiter (a
dot followed with a layout character), \texttt{eof} is the end-of-file
delimiter. This option is useful for predicates like
\IdxPB{read\_term\_from\_atom/3} \RefSP{read-term-from-atom/3} to avoid to add a
terminal dot at the end of the atom. The default value is \texttt{dot}.

\end{itemize}

\texttt{read(SorA, Term)} is equivalent to
\texttt{read\_term(SorA, Term, [])}.

\texttt{read\_term/2} and \texttt{read/1} apply to the current input stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Options} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{Options} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Options)}

\ErrCond{an element \texttt{E} of the \texttt{Options} list is neither a
variable nor a valid read option}
\ErrTerm{domain\_error(read\_option, E)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(input, binary\_stream, SorA)}

\ErrCond{\texttt{SorA} has stream properties \texttt{end\_of\_stream(past)}
and \texttt{eof\_action(error)}}
\ErrTerm{permission\_error(input, past\_end\_of\_stream, SorA)}

\ErrCond{a syntax error occurs and the value of the \texttt{syntax\_error}
Prolog flag is \texttt{error} \RefSP{set-prolog-flag/2}}
\ErrTerm{syntax\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

ISO predicates. The ISO reference raises a
\texttt{representation\_error(Flag)} where \texttt{Flag} is
\texttt{max\_arity},\texttt{ max\_integer}, or\texttt{ min\_integer} when
the read term breaches an implementation defined limit specified by
\texttt{Flag}. GNU Prolog detects neither \texttt{min\_integer} nor
\texttt{max\_integer} violation and treats a \texttt{max\_arity} violation
as a syntax error. The read options \texttt{syntax\_error} and
\texttt{end\_of\_term} are GNU Prolog extensions.

\subsubsection{\IdxPBD{read\_atom/2},\label{read-atom/2}
               \IdxPBD{read\_atom/1},
               \IdxPBD{read\_integer/2},
               \IdxPBD{read\_integer/1}, \\
               \IdxPBD{read\_number/2},
               \IdxPBD{read\_number/1}}


\begin{TemplatesOneCol}
read\_atom(+stream\_or\_alias, ?atom)\\
read\_atom(?atom)\\
read\_integer(+stream\_or\_alias, ?integer)\\
read\_integer(?integer)\\
read\_number(+stream\_or\_alias, ?number)\\
read\_number(?number)

\end{TemplatesOneCol}

\Description

\texttt{read\_atom(SorA, Atom)} succeeds if \texttt{Atom}
unifies with the next atom read from the stream associated with the
stream-term or alias \texttt{SorA}.

\texttt{read\_integer(SorA, Integer)} succeeds if
\texttt{Integer} unifies with the next integer read from the stream
associated with the stream-term or alias \texttt{SorA}.

\texttt{read\_number(SorA, Number)} succeeds if
\texttt{Number} unifies with the next number (integer or floating point
number) read from the stream associated with the stream-term or alias
\texttt{SorA}.

\texttt{read\_atom/1}, \texttt{read\_integer/1} and \texttt{read\_number/1}
apply to the current input stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Atom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom)}

\ErrCond{\texttt{Integer} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Integer)}

\ErrCond{\texttt{Number} is neither a variable nor a number}
\ErrTerm{type\_error(number, Number)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(input, binary\_stream, SorA)}

\ErrCond{\texttt{SorA} has stream properties \texttt{end\_of\_stream(past)}
and \texttt{eof\_action(error)}}
\ErrTerm{permission\_error(input, past\_end\_of\_stream, SorA)}

\ErrCond{a syntax error occurs and the value of the \texttt{syntax\_error}
Prolog flag is \texttt{error} \RefSP{set-prolog-flag/2}}
\ErrTerm{syntax\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{read\_token/2},\label{read-token/2}
               \IdxPBD{read\_token/1}}


\begin{TemplatesOneCol}
read\_token(+stream\_or\_alias, ?nonvar)\\
read\_token(?nonvar)

\end{TemplatesOneCol}

\Description

\texttt{read\_token(SorA, Token)} succeeds if \texttt{Token} unifies with
the encoding of the next Prolog token read from the stream associated with
stream-term or alias \texttt{SorA}.

\SPart{Token encoding}:

\begin{itemize}

\item \AddPTD{var}\texttt{var(A)}: a variable is read whose name is the atom
\texttt{A}.

\item an atom \texttt{A}: an atom \texttt{A} is read.

\item integer \texttt{N}: an integer \texttt{N} is read.

\item floating point number \texttt{N}: a floating point number \texttt{N}
is read.

\item \AddPTD{string}\texttt{string(A)}: a string (double quoted item) is read whose
characters forms the atom \texttt{A}.

\item \AddPTD{punct}\texttt{punct(P)}: a punctuation character \texttt{P} is read
(\texttt{P} is a one-character atom in \texttt{()[]{\lb}|{\rb}}, the atom
\texttt{full\_stop} or the atom \texttt{end\_of\_file}).

\item \AddPTD{back\_quotes}\texttt{back\_quotes(A)}: a back quoted item is read
whose characters forms the atom \texttt{A}.

\item \AddPTD{extended}\texttt{extended(A)}: an extended character \texttt{A} (an
atom) is read.

\end{itemize}

As for \texttt{read\_term/3}, the behavior of \texttt{read\_token/2} can be
affected by some \Add{Prolog flag}\texttt{Prolog flags} \RefSP{Term-input/output}.

\texttt{read\_token/1} applies to the current input stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an output stream}
\ErrTerm{permission\_error(input, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(input, binary\_stream, SorA)}

\ErrCond{\texttt{SorA} has stream properties \texttt{end\_of\_stream(past)}
and \texttt{eof\_action(error)}}
\ErrTerm{permission\_error(input, past\_end\_of\_stream, SorA)}

\ErrCond{a syntax error occurs and the value of the \texttt{syntax\_error}
Prolog flag is \texttt{error} \RefSP{set-prolog-flag/2}}
\ErrTerm{syntax\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{syntax\_error\_info/4}\label{syntax-error-info/4}}

\begin{TemplatesOneCol}
syntax\_error\_info(?atom, ?integer, ?integer, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{syntax\_error\_info(FileName, Line, Column, Error)} returns the
information associated with the last syntax error. \texttt{Line} is the line
number of the error, \texttt{Column} is the column number of the error and
\texttt{Error} is an atom explaining the error.

\begin{PlErrors}

\ErrCond{\texttt{FileName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, FileName)}

\ErrCond{\texttt{Line} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Line)}

\ErrCond{\texttt{Column} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Column)}

\ErrCond{\texttt{Error} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Error)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{last\_read\_start\_line\_column/2}}

\begin{TemplatesOneCol}
last\_read\_start\_line\_column(?integer, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{last\_read\_start\_line\_column(Line, Column)} unifies \texttt{Line}
and \texttt{Column} with the line number and the column number associated with
the start of the last read predicate. This predicate can be used after
calling one of the following predicates: \IdxPB{read\_term/3},
\IdxPB{read\_term/2}, \IdxPB{read/2}, \IdxPB{read/1}
\RefSP{read-term/3}, \IdxPB{read\_atom/2}, \IdxPB{read\_atom/1},
\IdxPB{read\_integer/2}, \IdxPB{read\_integer/1}, \IdxPB{read\_number/2},
\IdxPB{read\_number/1} \RefSP{read-atom/2} or \IdxPB{read\_token/2},
\IdxPB{read\_token/1} \RefSP{read-token/2}.

\begin{PlErrors}

\ErrCond{\texttt{Line} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Line)}

\ErrCond{\texttt{Column} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Column)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{write\_term/3},\label{write-term/3}
               \IdxPBD{write\_term/2},
               \IdxPBD{write/2},
               \IdxPBD{write/1},
               \IdxPBD{writeq/2},
               \IdxPBD{writeq/1}, \\
               \IdxPBD{write\_canonical/2},
               \IdxPBD{write\_canonical/1},
               \IdxPBD{display/2},
               \IdxPBD{display/1},
               \IdxPBD{print/2}, \\
               \IdxPBD{print/1}}


\begin{TemplatesOneCol}
write\_term(+stream\_or\_alias, ?term, +write\_option\_list)\\
write\_term(?term, +write\_option\_list)\\
write(+stream\_or\_alias, ?term)\\
write(?term)\\
writeq(+stream\_or\_alias, ?term)\\
writeq(?term)\\
write\_canonical(+stream\_or\_alias, ?term)\\
write\_canonical(?term)\\
display(+stream\_or\_alias, ?term)\\
display(?term)\\
print(+stream\_or\_alias, ?term)\\
print(?term)

\end{TemplatesOneCol}

\Description

\texttt{write\_term(SorA, Term, Options)} writes
\texttt{Term} to the stream associated with the stream-term or alias
\texttt{SorA} according to the options given by \texttt{Options}.

\SPart{Write options}: \texttt{Options} is a list of write options. If this
list contains contradictory options, the rightmost option is the one which
applies. Possible options are:

\begin{itemize}

\item \AddPOD{quoted}\texttt{quoted(true}/\texttt{false)}: if \texttt{true} each
atom and functor is quoted if this would be necessary for the term to be
input by \texttt{read\_term/3}. If \texttt{false} no extra quotes are
written. The default value is \texttt{false}.

\item \AddPOD{ignore\_ops}\texttt{ignore\_ops(true}/\texttt{false)}: if
\texttt{true} each compound term is output in functional notation (neither
operator notation nor list notation is used). If \texttt{false} operator and
list notations are used. The default value is \texttt{false}.

\item \AddPOD{numbervars}\texttt{numbervars(true}/\texttt{false)}: if
\texttt{true} a term of the form \texttt{'\$VAR'(N)}, where \texttt{N} is an
integer, is output as a variable name (see below). If \texttt{false}
such a term is output normally (according to the other options). The
default value is \texttt{false}.

\item \AddPOD{namevars}\texttt{namevars(true}/\texttt{false)}: if \texttt{true} a
term of the form \texttt{'\$VARNAME'(Name)}, where \texttt{Name} is an atom 
respecting the syntax of variable names, is output as a variable name (see
below). If \texttt{false} such a term is output normally (according to the
other options). The default value is \texttt{false}.

\item \AddPOD{variable\_names}\texttt{variable\_names(VNL)}: \texttt{VNL} is
a list of pairs \texttt{Name = Var} where \texttt{Var} is a
variable and \texttt{Name} is the atom associated with the
name of \texttt{Var}. Each variable \texttt{Var} is written as atom
\texttt{Name} (with \texttt{quoted(false)}) iff a term 
\texttt{Name = Var} is an element of the list \texttt{VNL}. If \texttt{Name}
is not atom or does not respect the syntax of variable names the pair is
ignored. If several pairs exist for the same variable name the first one applies.

\item \AddPOD{space\_args}\texttt{space\_args(true}/\texttt{false)}: if
\texttt{true} an extra space character is emitted after each comma
separating the arguments of a compound term in functional notation or of a
list. If \texttt{false} no extra space is emitted. The default value is
\texttt{false}.

\item \AddPOD{portrayed}\texttt{portrayed(true}/\texttt{false)}: if \texttt{true}
and if there exists a predicate \texttt{portray/1}, \texttt{write\_term/3}
acts as follows: if \texttt{Term} is a variable it is simply written. If
\texttt{Term} is non-variable then it is passed to \texttt{portray/1}. If
this succeeds then it is assumed that \texttt{Term} has been output.
Otherwise \texttt{write\_term/3} outputs the principal functor of
\texttt{Term} (\texttt{Term} itself if it is atomic) according to other
options and recursively calls \texttt{portray/1} on the components of
\texttt{Term} (if it is a compound term). With \texttt{ignore\_ops(false)} a
list is first passed to \texttt{portray/1} and only if this call fails each
element of the list is passed to \texttt{portray/1} (thus every sub-list is
not passed). The default value is \texttt{false}.

\item \AddPOD{max\_depth}\texttt{max\_depth(N)}: controls the depth of output for
compound terms. \texttt{N} is an integer specifying the depth. The output of
a term whose depth is greater than \texttt{N} gives rise to the output of
\texttt{...} (3 dots). By default there is no depth limit.

\item \AddPOD{priority}\texttt{priority(N)}: specifies the starting priority
to output the term. This option controls if \texttt{Term} should be enclosed
in brackets. \texttt{N} is a positive integer $\leq$ 1200. By default
\texttt{N} = 1200.

\end{itemize}

\SPart{Variable numbering}: when the \texttt{numbervars(true)} option is
passed to \texttt{write\_term/3} any term of the form \texttt{'\$VAR'(N)}
where \texttt{N} is an integer is output as a variable name consisting of a
capital letter possibly followed by an integer. The capital letter is the
\texttt{(I+1)}\emph{th} letter of the alphabet and the integer is
\texttt{J}, where \texttt{I = N mod 26} and \texttt{J = N // 26}. The
integer \texttt{J} is omitted if it is zero. For example:

\begin{CodeTwoCols}[2cm]
\Two{'\$VAR'(0)}{is written as \texttt{A}}
\Two{'\$VAR'(1)}{is written as \texttt{B}}
\One{...}
\Two{'\$VAR'(25)}{is written as \texttt{Z}}
\Two{'\$VAR'(26)}{is written as \texttt{A1}}
\Two{'\$VAR'(27)}{is written as \texttt{B1}}
\end{CodeTwoCols}

\SPart{Variable naming}: when the \texttt{namevars(true)} option is passed
to \texttt{write\_term/3} any term of the form \texttt{'\$VARNAME'(Name)}
where \texttt{Name} is an atom is output as a variable name consisting of
the characters \texttt{Name}. For example: \texttt{'\$VARNAME'('A')} is
written as \texttt{A} (even in the presence of the \texttt{quoted(true)}
option).

\texttt{write(SorA, Term)} is equivalent to
\texttt{write\_term(SorA, Term, [numbervars(true), \\
namevars(true)])}.

\texttt{writeq(SorA, Term)} is equivalent to
\texttt{write\_term(SorA, Term, [quoted(true), \\
numbervars(true), namevars(true)])}.

\texttt{write\_canonical(SorA, Term)} is equivalent to
\texttt{write\_term(SorA, Term, [quoted(true), \\
ignore\_ops(true), numbervars(false), namevars(false)])}.

\texttt{display(SorA, Term)} is equivalent to
\texttt{write\_term(SorA, Term, [ignore\_ops(true), \\
  numbervars(false), namevars(false)])}.

\texttt{print(SorA, Term)} is equivalent to
\texttt{write\_term(SorA, Term, [numbervars(false), \\
portrayed(true)])}.

\texttt{write\_term/2}, \texttt{write/1}, \texttt{writeq/1},
\texttt{write\_canonical/1}, \texttt{display/1} and \texttt{print/1} apply
to the current output stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Options} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Options} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Options)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{an element \texttt{E} of the \texttt{Options} list is neither a
variable nor a valid write-option}
\ErrTerm{domain\_error(write\_option, E)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an input stream}
\ErrTerm{permission\_error(output, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(output, binary\_stream, SorA)}

\end{PlErrors}

\Portability

ISO predicates except \texttt{display/1-2} and \texttt{print/1-2} that
are GNU Prolog predicates. \texttt{namevars}, \texttt{variable\_names} \texttt{space\_args},
\texttt{portrayed}, \texttt{max\_depth} and \texttt{priority}
options are GNU Prolog extensions.

\subsubsection{\IdxPBD{format/3},\label{format/3}
               \IdxPBD{format/2}}


\begin{TemplatesOneCol}
format(+stream\_or\_alias, +character\_code\_list\_or\_atom,
+list)\\
format(+character\_code\_list\_or\_atom, +list)

\end{TemplatesOneCol}

\Description

\texttt{format(SorA, Format, Arguments)} writes the \texttt{Format} string
replacing each format control sequence \texttt{F} by the corresponding
element of \texttt{Arguments} (formatted according to \texttt{F}) to the
stream associated with the stream-term or alias \texttt{SorA}.

\SPart{Format control sequences}: the general format of a control sequence
is \texttt{'\~{}NC'}. The character \texttt{C} determines the type of
the control sequence. \texttt{N} is an optional numeric argument. An
alternative form of \texttt{N} is \texttt{'*'}. \texttt{'*'} implies
that the next argument \texttt{Arg} in \texttt{Arguments} should be
used as a numeric argument in the control sequence. The use of C
\texttt{printf()} formatting sequence (beginning by the character
\texttt{\%}) is also allowed. The following control sequences are
available:

\begin{tabular}{|C{1.4cm}|C{2.8cm}|p{10.45cm}|}
\hline

Format sequence  & type of the argument & Description \\

\hline\hline

\texttt{\~{}Na} & atom & print the atom without quoting. \texttt{N} is minimal number of characters to print using spaces on the right if needed (default: the length of the atom) \\

\hline

\texttt{\~{}Nc} & character code & print the character associated with the
code. \texttt{N} is the number of times to print the character (default: 1)\\

\hline

\texttt{ \~{}Nf}
\linebreak
\texttt{\~{}Ne \~{}NE \~{}Ng \~{}NG}
               &  float expression & pass the argument \texttt{Arg} and
                                     \texttt{N} to the C \texttt{printf()}
                                     function as:
\linebreak
                               if \texttt{N} is not specified
                               \texttt{printf("\%f",Arg)} else
                               \texttt{printf("\%.Nf",Arg)}.
\linebreak
Similarly for \texttt{\~{}Ne}, \texttt{\~{}NE}, \texttt{\~{}Ng} and \texttt{\~{}NG} \\

\hline

\texttt{\~{}Nd} & integer expression & print the argument. \texttt{N} is the
number of digits after the decimal point. If \texttt{N} is 0 no
decimal point is printed (default: 0)\\

\hline

\texttt{\~{}ND} & integer expression & identical to \texttt{\~{}Nd} except
that \texttt{','} separates groups of three digits to the left of the
decimal point \\

\hline

\texttt{\~{}Nr} & integer expression & print the argument according to the
radix \texttt{N}. 2 $\leq$ \texttt{N} $\leq$ 36 (default: 8). The letters
\texttt{a-z} denote digits $>$ 9 \\

\hline

\texttt{\~{}NR} & integer expression & identical to \texttt{\~{}Nr} except
that the letters \texttt{A-Z} denote digits $>$ 9 \\

\hline

\texttt{\~{}Ns} & character code list & print exactly \texttt{N} characters
(default: the length of the list) \\

\hline

\texttt{\~{}NS} & character list & print exactly \texttt{N} characters
(default: the length of the list) \\

\hline

\texttt{\~{}i} & term & ignore the current argument \\

\hline

\texttt{\~{}k} & term & pass the argument to
\IdxPB{write\_canonical/1} \RefSP{write-term/3} \\

\hline

\texttt{\~{}p} & term & pass the argument to \IdxPB{print/1}
\RefSP{write-term/3} \\

\hline

\texttt{\~{}q} & term & pass the argument to \IdxPB{writeq/1}
\RefSP{write-term/3} \\

\hline

\texttt{\~{}w} & term & pass the argument to \IdxPB{write/1}
\RefSP{write-term/3} \\

\hline

\texttt{\~{}\~{}} & none & print the character \texttt{'\~{}'} \\

\hline

\texttt{\~{}Nn} & none & print \texttt{N} new-line characters (default: 1) \\

\hline

\texttt{\~{}N} & none & print a new-line character if not at the beginning
of a line \\

\hline

\texttt{\~{}?} & atom & use the argument as a nested format string \\

\hline

\texttt{\%F} & atom, integer or float expression & interface to the C
function \texttt{printf(3)} for outputting atoms (C string), integers and
floating point numbers. \texttt{*} are also allowed. \\

\hline
\end{tabular}

\texttt{format/2} applies to the current output stream.

\begin{PlErrors}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Format} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Arguments} is a partial list}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Format} is neither a partial list nor a list or an atom}
\ErrTerm{type\_error(list, Format)}

\ErrCond{\texttt{Arguments} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Arguments)}

\ErrCond{an element \texttt{E} of the \texttt{Format} list is neither a
variable nor a character code}
\ErrTerm{representation\_error(character\_code, E)}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{an element \texttt{E} of Format is not a valid format control
sequence}
\ErrTerm{domain\_error(format\_control\_sequence, E)}

\ErrCond{the \texttt{Arguments} list does not contain sufficient elements}
\ErrTerm{domain\_error(non\_empty\_list, [])}

\ErrCond{an element \texttt{E} of the \texttt{Arguments} list is a variable
while a non-variable term was expected}
\ErrTerm{instantiation\_error}

\ErrCond{an element \texttt{E} of the \texttt{Arguments} list is neither
variable nor an atom while an atom was expected}
\ErrTerm{type\_error(atom, E)}

\ErrCond{an element \texttt{E} of the \texttt{Arguments} cannot be evaluated
as an arithmetic expression while an integer or a floating point number was
expected}
\ErrTermRm{an arithmetic error \RefSP{Evaluation-of-an-arithmetic-expression}}

\ErrCond{an element \texttt{E} of the \texttt{Arguments} list is neither
variable nor character code while a character code was expected}
\ErrTerm{representation\_error(character\_code, E)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an input stream}
\ErrTerm{permission\_error(output, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(output, binary\_stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{portray\_clause/2},\label{portray-clause/2}
               \IdxPBD{portray\_clause/1}}


\begin{TemplatesOneCol}
portray\_clause(+stream\_or\_alias, +clause)\\
portray\_clause(+clause)

\end{TemplatesOneCol}

\Description

\texttt{portray\_clause(SorA, Clause)} pretty prints
\texttt{Clause} to the stream associated with the stream-term or alias
\texttt{SorA}.
\texttt{portray\_clause/2} uses the variable binding predicates
\IdxPB{name\_singleton\_vars/1} \RefSP{name-singleton-vars/1} and
\IdxPB{numbervars/1} \RefSP{bind-variables/2}. This predicate is
used by \IdxPB{listing/1} \RefSP{listing/1}.

\texttt{portray\_clause/1} applies to the current output stream.

\begin{PlErrors}

\ErrCond{\texttt{Clause} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Clause} is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, Clause)}

\ErrCond{\texttt{SorA} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{SorA} is neither a variable nor a stream-term or alias}
\ErrTerm{domain\_error(stream\_or\_alias, SorA)}

\ErrCond{\texttt{SorA} is not associated with an open stream}
\ErrTerm{existence\_error(stream, SorA)}

\ErrCond{\texttt{SorA} is an input stream}
\ErrTerm{permission\_error(output, stream, SorA)}

\ErrCond{\texttt{SorA} is associated with a binary stream}
\ErrTerm{permission\_error(output, binary\_stream, SorA)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{get\_print\_stream/1}}

\begin{TemplatesOneCol}
get\_print\_stream(?stream)

\end{TemplatesOneCol}

\Description

\texttt{get\_print\_stream(Stream)} unifies \texttt{Stream} with the
stream-term associated with the output stream used by \IdxPB{print/2}
\RefSP{write-term/3}. The purpose of this predicate is to allow a
user-defined \IdxPB{portray/1} predicate to identify the output stream in
use.

\begin{PlErrors}

\ErrCond{\texttt{Stream} is neither a variable nor a stream-term}
\ErrTerm{domain\_error(stream, Stream)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{op/3}\label{op/3:(Term-input/output)}}

\begin{TemplatesOneCol}
op(+integer, +operator\_specifier, +atom\_or\_atom\_list)

\end{TemplatesOneCol}

\Description

\texttt{op(Priority, OpSpecifier, Operator)} alters the operator table.
\texttt{Operator} is declared as an operator with properties defined by
specifier \texttt{OpSpecifier} and \texttt{Priority}. \texttt{Priority} must
be an integer $\geq$ 0 and $\leq$ 1200. If \texttt{Priority} is 0 then the
operator properties of \texttt{Operator} (if any) are canceled.
\texttt{Operator} may also be a list of atoms in which case all of them are
declared to be operators. In general, operators can be removed from
the operator table and their priority or specifier can be changed. However,
it is an error to attempt to change the \texttt{','} operator from its
initial status. An atom can have multiple operator definitions (e.g.
prefix and infix like \texttt{+}) however an atom cannot have both an
infix and a postfix operator definitions.

\SPart{Operator specifiers}: the following specifiers are available:

\begin{tabular}{|c|c|c|}
\hline

Specifier & Type & Associativity \\

\hline\hline

\texttt{fx} & prefix & no \\

\hline

\texttt{fy} & prefix & yes \\

\hline

\texttt{xf} & postfix & no \\

\hline

\texttt{yf} & postfix & yes \\

\hline

\texttt{xfx} & infix & no \\

\hline

\texttt{yfx} & infix & left \\

\hline

\texttt{xfy} & infix & right \\

\hline
\end{tabular}

\SPart{Prolog predefined operators}:

\begin{tabular}{|r|c|L{11cm}|}
\hline

Priority & Specifier & Operators \\

\hline\hline

\texttt{1200} & \texttt{xfx} & \texttt{:- ~--{\gt}} \\

\hline

\texttt{1200} & \texttt{fx} & \texttt{:-} \\

\hline

\texttt{1105} & \texttt{xfy} & \texttt{|} \\

\hline

\texttt{1100} & \texttt{xfy} & \texttt{;} \\

\hline

\texttt{1050} & \texttt{xfy} & \texttt{-{\gt} *-{\gt}} \\

\hline

\texttt{1000} & \texttt{xfy} & \texttt{,} \\

\hline

\texttt{900} & \texttt{fy} & \texttt{{\bs}+} \\

\hline

\texttt{700} & \texttt{xfx} & \texttt{= ~{\bs}= ~=.. ~== ~{\bs}== ~@{\lt}
~@={\lt} ~@{\gt} ~@{\gt}= ~is ~=:= ~={\bs}= ~{\lt} ~={\lt} ~{\gt} ~{\gt}=}
\\

\hline

\texttt{600} & \texttt{xfy} & \texttt{:} \\

\hline

\texttt{500} & \texttt{yfx} & \texttt{+ ~- ~/{\bs} ~{\bs}/} \\

\hline

\texttt{400} & \texttt{yfx} & \texttt{* ~/ ~// ~rem ~mod ~div ~{\lt}{\lt}
~{\gt}{\gt}} \\

\hline

\texttt{200} & \texttt{xfx} & \texttt{** ~\^{}} \\

\hline

\texttt{200} & \texttt{fy} & \texttt{+ ~- ~{\bs}} \\

\hline
\end{tabular}

\SPart{FD predefined operators}:

\begin{tabular}{|r|c|L{11cm}|}
\hline

Priority & Specifier & Operators \\

\hline\hline

\texttt{750} & \texttt{xfy} & \texttt{\#{\lt}={\gt} ~\#{\bs}{\lt}={\gt}} \\

\hline

\texttt{740} & \texttt{xfy} & \texttt{\#=={\gt} ~\#{\bs}=={\gt}} \\

\hline

\texttt{730} & \texttt{xfy} & \texttt{\#\# ~\#{\bs}/ ~\#{\bs}{\bs}/} \\

\hline

\texttt{720} & \texttt{yfx} & \texttt{\#/{\bs} ~\#{\bs}/{\bs}} \\

\hline

\texttt{710} & \texttt{fy} & \texttt{\#{\bs}} \\

\hline

\texttt{700} & \texttt{xfx} & \texttt{\#= ~\#{\bs}= ~\#{\lt} ~\#={\lt}
~\#{\gt} ~\#{\gt}= ~\#=\# ~\#{\bs}=\# ~\#{\lt}\# ~\#={\lt}\# ~\#{\gt}\#
~\#{\gt}=\#} \\

\hline

\texttt{500} & \texttt{yfx} & \texttt{+ ~-} \\

\hline

\texttt{400} & \texttt{yfx} & \texttt{* ~/ ~// ~rem} \\

\hline

\texttt{200} & \texttt{xfy} & \texttt{**} \\

\hline

\texttt{200} & \texttt{fy} & \texttt{+ ~-} \\

\hline
\end{tabular}

\begin{PlErrors}

\ErrCond{\texttt{Priority} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{OpSpecifier} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Operator} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Priority} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Priority)}

\ErrCond{\texttt{OpSpecifier} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, OpSpecifier)}

\ErrCond{\texttt{Operator} is neither a partial list nor a list nor an atom}
\ErrTerm{type\_error(list, Operator)}

\ErrCond{an element \texttt{E} of the \texttt{Operator} list is neither a
variable nor an atom}
\ErrTerm{type\_error(atom, E)}

\ErrCond{\texttt{Priority} is an integer not $\geq$ 0 and $\leq$ 1200}
\ErrTerm{domain\_error(operator\_priority, Priority)}

\ErrCond{\texttt{OpSpecifier} is not a valid operator specifier}
\ErrTerm{domain\_error(operator\_specifier, OpSpecifier)}

\ErrCond{\texttt{Operator} (or an element of the
\texttt{Operator} list) is \texttt{','}}
\ErrTerm{permission\_error(modify, operator, ',')}

\ErrCond{\texttt{OpSpecifier} is a specifier such that \texttt{Operator}
would have a postfix and an infix definition. }
\ErrTerm{permission\_error(create, operator, Operator)}

\ErrCond{\texttt{Operator} (or an element of the \texttt{Operator} list) is
\texttt{|} and it would have a prefix or a postfix definition or its
\texttt{Priority} would be $\leq$ 1100.}
\ErrTerm{permission\_error(create, operator, '|')}

\ErrCond{\texttt{Operator} (or an element of the \texttt{Operator} list) is
\texttt{[]} or \texttt{{\lb}{\rb}}.}
\ErrTerm{permission\_error(create, operator, Operator)}


\end{PlErrors}

\Portability

ISO predicate.

The ISO reference implies that if a program calls \texttt{current\_op/3},
then modifies an operator definition by calling \texttt{op/3} and backtracks
into the call to \texttt{current\_op/3}, then the changes are guaranteed not
to affect that \texttt{current\_op/3} goal.  This is not guaranteed by
GNU Prolog.

\subsubsection{\IdxPBD{current\_op/3}}

\begin{TemplatesOneCol}
current\_op(?integer, ?operator\_specifier, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{current\_op(Priority, OpSpecifier, Operator)} succeeds if
\texttt{Operator} is an operator with properties defined by specifier
\texttt{OpSpecifier} and \texttt{Priority}. This predicate is re-executable
on backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Priority} is neither a variable nor an operator priority}
\ErrTerm{domain\_error(operator\_priority, Priority)}

\ErrCond{\texttt{OpSpecifier} is neither a variable nor an operator
specifier}
\ErrTerm{domain\_error(operator\_specifier, OpSpecifier)}

\ErrCond{\texttt{Operator} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Operator)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{char\_conversion/2}\label{char-conversion/2}}

\begin{TemplatesOneCol}
char\_conversion(+character, +character)

\end{TemplatesOneCol}

\Description

\texttt{char\_conversion(InChar, OutChar)} alters the character-conversion
mapping. This mapping is used by the following read predicates:
\IdxPB{read\_term/3} \RefSP{read-term/3}, \IdxPB{read\_atom/2},
\IdxPB{read\_integer/2}, \IdxPB{read\_number/2} \RefSP{read-atom/2} and
\IdxPB{read\_token/2} \RefSP{read-token/2} to replace any occurrence of a
character \texttt{InChar} by \texttt{OutChar}. However the conversion
mechanism should have been previously activated by switching on the
\IdxPF{char\_conversion} \Idx{Prolog flag} \RefSP{set-prolog-flag/2}. When
\texttt{InChar} and \texttt{OutChar} are the same, the effect is to remove
any conversion of a character \texttt{InChar}.

Note that the single character read predicates (e.g. \texttt{get\_char/2})
never do character conversion. If such behavior is required, it must be
explicitly done using \texttt{current\_char\_conversion/2}
\RefSP{current-char-conversion/2}.

\begin{PlErrors}

\ErrCond{\texttt{InChar} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{OutChar} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{InChar} is neither a variable nor a character}
\ErrTerm{type\_error(character, InChar)}

\ErrCond{\texttt{OutChar} is neither a variable nor a character}
\ErrTerm{type\_error(character, OutChar)}

\end{PlErrors}

\Portability

ISO predicate. The \texttt{type\_error(character,\ldots)} is a GNU Prolog
behavior, the ISO reference instead defines a
\texttt{representation\_error(character)} in this case. This seems to be an
error of the ISO reference since, for many other built-in predicates
accepting a character (e.g. \texttt{char\_code/2}, \texttt{put\_char/2}), a
\texttt{type\_error} is raised.

The ISO reference implies that if a program calls
\texttt{current\_char\_conversion/2}, then modifies the character mapping by
calling \texttt{char\_conversion/2}, and backtracks into the call to
\texttt{current\_char\_conversion/2} then the changes are guaranteed not to
affect that \texttt{current\_char\_conversion/2} goal. This is not guaranteed
by GNU Prolog.

\subsubsection{\IdxPBD{current\_char\_conversion/2}\label{current-char-conversion/2}}

\begin{TemplatesOneCol}
current\_char\_conversion(?character, ?character)

\end{TemplatesOneCol}

\Description

\texttt{current\_char\_conversion(InChar, OutChar)} succeeds if the
conversion of \texttt{InChar} is \texttt{OutChar} according to the
character-conversion mapping. In that case, \texttt{InChar} and
\texttt{OutChar} are different. This predicate is re-executable on
backtracking.

\begin{PlErrors}

\ErrCond{\texttt{InChar} is neither a variable nor a character}
\ErrTerm{type\_error(character, InChar)}

\ErrCond{\texttt{OutChar} is neither a variable nor a character}
\ErrTerm{type\_error(character, OutChar)}

\end{PlErrors}

\Portability

ISO predicate. Same remark as for char\_conversion/2
\RefSP{char-conversion/2}.

\subsection{Input/output from/to constant terms}
\label{Input/output-from/to-constant-terms}
These built-in predicates enable a Prolog term to be input from or output to
a Prolog constant term (atom, character list or character code list). All
these predicates can be defined using constant term streams
\RefSP{Constant-term-streams}. They are however simpler to use.

\subsubsection{\IdxPBD{read\_term\_from\_atom/3},\label{read-term-from-atom/3}
               \IdxPBD{read\_from\_atom/2},
               \IdxPBD{read\_token\_from\_atom/2}}


\begin{TemplatesOneCol}
read\_term\_from\_atom(+atom ?term, +read\_option\_list)\\
read\_from\_atom(+atom, ?term)\\
read\_token\_from\_atom(+atom, ?nonvar)

\end{TemplatesOneCol}

\Description

\texttt{}%
\texttt{}%
\texttt{}%
Like \IdxPB{read\_term/3}, \IdxPB{read/2} \RefSP{read-term/3} and
\IdxPB{read\_token/2} \RefSP{read-token/2} except that characters are not
read from a text-stream but from \texttt{Atom}; the atom given as first
argument.

\begin{PlErrors}

\ErrCond{\texttt{Atom} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Atom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom)}

\ErrCond{see associated predicate errors}
\ErrTermRm{\RefSP{read-term/3} and \RefSP{read-token/2}}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{read\_term\_from\_chars/3},
               \IdxPBD{read\_from\_chars/2},
               \IdxPBD{read\_token\_from\_chars/2}}

\begin{TemplatesOneCol}
read\_term\_from\_chars(+character\_list ?term,
+read\_option\_list)\\
read\_from\_chars(+character\_list, ?term)\\
read\_token\_from\_chars(+character\_list, ?nonvar)

\end{TemplatesOneCol}

\Description

\texttt{}%
\texttt{}%
\texttt{}%
Like \IdxPB{read\_term/3}, \IdxPB{read/2} \RefSP{read-term/3} and
\IdxPB{read\_token/2} \RefSP{read-token/2} except that characters are not
read from a text-stream but from \texttt{Chars}; the character list given as
first argument.

\begin{PlErrors}

\ErrCond{\texttt{Chars} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Chars} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Chars)}

\ErrCond{an element \texttt{E} of the \texttt{Chars} list is neither a
variable nor a character}
\ErrTerm{type\_error(character, E)}

\ErrCond{see associated predicate errors}
\ErrTermRm{\RefSP{read-term/3} and \RefSP{read-token/2}}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{read\_term\_from\_codes/3},
               \IdxPBD{read\_from\_codes/2},
               \IdxPBD{read\_token\_from\_codes/2}}

\begin{TemplatesOneCol}
read\_term\_from\_codes(+character\_code\_list ?term,
+read\_option\_list)\\
read\_from\_codes(+character\_code\_list, ?term)\\
read\_token\_from\_codes(+character\_code\_list, ?nonvar)

\end{TemplatesOneCol}

\Description

\texttt{}%
\texttt{}%
\texttt{}%
Like \IdxPB{read\_term/3}, \IdxPB{read/2} \RefSP{read-term/3} and
\IdxPB{read\_token/2} \RefSP{read-token/2} except that characters are not
read from a text-stream but from \texttt{Codes}; the character code list
given as first argument.

\begin{PlErrors}

\ErrCond{\texttt{Codes} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Codes} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Codes)}

\ErrCond{an element \texttt{E} of the \texttt{Codes} list is neither a
variable nor an integer}
\ErrTerm{type\_error(integer, E)}

\ErrCond{an element \texttt{E} of the \texttt{Codes} list is an integer but
not a character code}
\ErrTerm{representation\_error(character\_code, E)}

\ErrCond{see associated predicate errors}
\ErrTermRm{\RefSP{read-term/3} and \RefSP{read-token/2}}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{write\_term\_to\_atom/3},
               \IdxPBD{write\_to\_atom/2},
               \IdxPBD{writeq\_to\_atom/2}, \\
               \IdxPBD{write\_canonical\_to\_atom/2},
               \IdxPBD{display\_to\_atom/2},
               \IdxPBD{print\_to\_atom/2}, \\
               \IdxPBD{format\_to\_atom/3}}

\begin{TemplatesOneCol}
write\_term\_to\_atom(?atom, ?term, +write\_option\_list)\\
write\_to\_atom(?atom, ?term)\\
writeq\_to\_atom(?atom, ?term)\\
write\_canonical\_to\_atom(?atom, ?term)\\
display\_to\_atom(?atom, ?term)\\
print\_to\_atom(?atom, ?term)\\
format\_to\_atom(?atom, +character\_code\_list\_or\_atom, +list)

\end{TemplatesOneCol}

\Description

\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
Similar to \IdxPB{write\_term/3}, \IdxPB{write/2}, \IdxPB{writeq/2},
\IdxPB{write\_canonical/2}, \IdxPB{display/2}, \IdxPB{print/2}
\RefSP{write-term/3} and \IdxPB{format/3} \RefSP{format/3} except that
characters are not written onto a text-stream but are collected as an atom
which is then unified with the first argument \texttt{Atom}.

\begin{PlErrors}

\ErrCond{\texttt{Atom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom)}

\ErrCond{see associated predicate errors}
\ErrTermRm{\RefSP{write-term/3} and \RefSP{format/3}}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{write\_term\_to\_chars/3},
               \IdxPBD{write\_to\_chars/2},
               \IdxPBD{writeq\_to\_chars/2}, \\
               \IdxPBD{write\_canonical\_to\_chars/2},
               \IdxPBD{display\_to\_chars/2},
               \IdxPBD{print\_to\_chars/2}, \\
               \IdxPBD{format\_to\_chars/3}}

\begin{TemplatesOneCol}
write\_term\_to\_chars(?character\_list, ?term, +write\_option\_list)\\
write\_to\_chars(?character\_list, ?term)\\
writeq\_to\_chars(?character\_list, ?term)\\
write\_canonical\_to\_chars(?character\_list, ?term)\\
display\_to\_chars(?character\_list, ?term)\\
print\_to\_chars(?character\_list, ?term)\\
format\_to\_chars(?character\_list, +character\_code\_list\_or\_atom, +list)

\end{TemplatesOneCol}

\Description

\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
Similar to \IdxPB{write\_term/3}, \IdxPB{write/2}, \IdxPB{writeq/2},
\IdxPB{write\_canonical/2}, \IdxPB{display/2}, \IdxPB{print/2}
\RefSP{write-term/3} and \IdxPB{format/3} \RefSP{format/3} except that
characters are not written onto a text-stream but are collected as a
character list which is then unified with the first argument \texttt{Chars}.

\begin{PlErrors}

\ErrCond{\texttt{Chars} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Chars)}

\ErrCond{An element \texttt{E} of the list \texttt{Chars} is neither a
  variable nor a one-char atom} \ErrTerm{type\_error(character, E)}

\ErrCond{see associated predicate errors}
\ErrTermRm{\RefSP{write-term/3} and \RefSP{format/3}}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPB{write\_term\_to\_codes/3},
               \IdxPBD{write\_to\_codes/2},
               \IdxPBD{writeq\_to\_codes/2}, \\
               \IdxPBD{write\_canonical\_to\_codes/2},
               \IdxPBD{display\_to\_codes/2},
               \IdxPBD{print\_to\_codes/2}, \\
               \IdxPBD{format\_to\_codes/3}}

\begin{TemplatesOneCol}
write\_term\_to\_codes(?character\_code\_list, ?term, +write\_option\_list)\\
write\_to\_codes(?character\_code\_list, ?term)\\
writeq\_to\_codes(?character\_code\_list, ?term)\\
write\_canonical\_to\_codes(?character\_code\_list, ?term)\\
display\_to\_codes(?character\_code\_list, ?term)\\
print\_to\_codes(?character\_code\_list, ?term)\\
format\_to\_codes(?character\_code\_list, +character\_code\_list\_or\_atom,
+list)

\end{TemplatesOneCol}

\Description

\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
\texttt{}%
Similar to \IdxPB{write\_term/3}, \IdxPB{write/2}, \IdxPB{writeq/2},
\IdxPB{write\_canonical/2}, \IdxPB{display/2}, \IdxPB{print/2}
\RefSP{write-term/3} and \IdxPB{format/3} \RefSP{format/3} except that
characters are not written onto a text-stream but are collected as a
character code list which is then unified with the first argument
\texttt{Codes}.

\begin{PlErrors}

\ErrCond{\texttt{Codes} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Codes)}

\ErrCond{An element \texttt{E} of the list \texttt{Codes} is neither a
  variable nor an integer} \ErrTerm{type\_error(integer, E)}

\ErrCond{An element \texttt{E} of the list \texttt{Codes} is an integer but
  not a character code} \ErrTerm{representation\_error(character\_code)}

\ErrCond{see associated predicate errors}
\ErrTermRm{\RefSP{write-term/3} and \RefSP{format/3}}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsection{DEC-10 compatibility input/output}

\subsubsection{Introduction}
The DEC-10 Prolog I/O predicates manipulate streams implicitly since they
only refer to current input/output streams \RefSP{Introduction:(Streams)}.
The current input and output streams are initially set to
\IdxPK{user\_input} and \IdxPK{user\_output} respectively. The predicate
\texttt{see/1}
(resp. \texttt{tell/1}, \texttt{append/1}) can be used for setting the
current input (resp. output) stream to newly opened streams for
particular files. The predicate \texttt{seen/0}
(resp. \texttt{told/0}) close the current input (resp. output) stream,
and resets it to the standard input (resp. output). The predicate
\texttt{seeing/1} (resp. \texttt{telling/1}) is used for retrieving
the file name associated with the current input (resp. output)
stream. The file name \IdxPKD{user} stands for the standard input or
output, depending on context (\IdxPK{user\_input} and
\IdxPK{user\_output} can also be used). The DEC-10 Prolog I/O predicates
are only provided for compatibility, they are now obsolete and
their use is discouraged. The predicates for explicit stream manipulation
should be used instead \RefSP{Streams}.

\subsubsection{\IdxPBD{see/1},
               \IdxPBD{tell/1},
               \IdxPBD{append/1}}

\begin{TemplatesOneCol}
see(+source\_sink)\\
see(+stream)\\
tell(+source\_sink)\\
tell(+stream)\\
append(+source\_sink)\\
append(+stream)

\end{TemplatesOneCol}

\Description

\texttt{see(FileName)} sets the current input stream to \texttt{FileName}.
If there is a stream opened by \texttt{see/1} associated with the same
\texttt{FileName} already, then it becomes the current input stream.
Otherwise, \texttt{FileName} is opened for reading and becomes the current
input stream.

\texttt{tell(FileName)} sets the current output stream to \texttt{FileName}.
If there is a stream opened by \texttt{tell/1} associated with the same
\texttt{FileName} already, then it becomes the current output stream.
Otherwise, \texttt{FileName} is opened for writing and becomes the current
output stream.

\texttt{append(FileName)} like \texttt{tell/1} but
\texttt{FileName} is opened for writing + append.

A stream-term (obtained with any other built-in predicate) can also be
provided as \texttt{FileName} to these predicates.

\Errors

See errors associated with \texttt{open/4} \RefSP{open/4}.

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{seeing/1},
               \IdxPBD{telling/1}}

\begin{TemplatesOneCol}
seeing(?source\_sink)\\
telling(?source\_sink)

\end{TemplatesOneCol}

\Description

\texttt{seeing(FileName)} succeeds if \texttt{FileName} unifies
with the name of the current input file, if it was opened by
\texttt{see/1}; else with the current input stream-term, if this is not
\IdxPK{user\_input}, otherwise with
\IdxPK{user}.

\texttt{telling(FileName)} succeeds if \texttt{FileName} unifies with the
name of the current output file, if it was opened by \texttt{tell/1} or
\texttt{append/1}; else with the current output stream-term, if this is not
\IdxPK{user\_output}, otherwise with \IdxPK{user}.

\PlErrorsNone

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{seen/0},
               \IdxPBD{told/0}}

\begin{TemplatesOneCol}
seen\\
told

\end{TemplatesOneCol}

\Description

\texttt{seen} closes the current input, and resets it to
\IdxPK{user\_input}.

\texttt{told} closes the current output, and resets it to
\IdxPK{user\_output}.

\PlErrorsNone

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{get0/1},
               \IdxPBD{get/1},
               \IdxPBD{skip/1}}

\begin{TemplatesOneCol}
get0(?in\_character\_code)\\
get(?in\_character\_code)\\
skip(+character\_code)

\end{TemplatesOneCol}

\Description

\texttt{get0(Code)} succeeds if \texttt{Code} unifies with the next
character code read from the current input stream. Thus it is equivalent to
\texttt{get\_code(Code)} \RefSP{get-char/2}.

\texttt{get(Code)} succeeds if \texttt{Code} unifies with the next character
code read from the current input stream that is not a layout character.

\texttt{skip(Code)} skips just past the next character code \texttt{Code}
from the current input stream.

\Errors

See errors for \texttt{get\_code/2} \RefSP{get-char/2}.

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{put/1},
               \IdxPBD{tab/1}}

\begin{TemplatesOneCol}
put(+character\_code)\\
tab(+evaluable)

\end{TemplatesOneCol}

\Description

\texttt{put(Code)} writes the character whose code is \texttt{Code} onto the
current output stream. It is equivalent to \texttt{put\_code(Code)}
\RefSP{put-char/2}.

\texttt{tab(N)} writes \texttt{N} spaces onto the current output
stream. \texttt{N} may be an arithmetic expression.

\Errors

See errors for \texttt{put\_code/2} \RefSP{put-char/2} and for arithmetic
expressions \RefSP{Evaluation-of-an-arithmetic-expression}.

\Portability

GNU Prolog predicates.

\subsection{Term expansion}
\label{Term-expansion}

\subsubsection{Definite clause grammars}
\label{DCG}
\index{Definite clause grammars|see {DCG}}

Definite clause grammars are a useful notation to express grammar rules.
However the ISO reference does not include them, so they should be considered
as a system dependent feature. Definite clause grammars are an extension of
context-free grammars. A grammar rule is of the form:

\OneLine{\textrm{head} \AddPKD{(--{\gt})/2}\texttt{--{\gt}} \textrm{body}.}

\texttt{--{\gt}} is a predefined infix operator \RefSP{op/3:(Term-input/output)}.

Here are some features of definite clause grammars:

\begin{itemize}

\item a non-terminal symbol may be any callable term.

\item a terminal symbol may be any Prolog term and is written as a list. The
  empty list represents an empty sequence of terminals.

\item a sequence is expressed using the Prolog conjunction operator
  \texttt((',')/2).

\item the head of a grammar rule consists of a non-terminal optionally
  followed by a sequence of terminals (i.e. a Prolog list).

\item the body of a grammar rule consists of a sequence of non-terminals,
  terminals, predicate call, disjunction (using \texttt{;/2}), if-then (using
  \texttt{(-{\gt})/2}) or cut (using \texttt{!}).

\item a predicate call must be enclosed in curly brackets (using
  \texttt{{\lb}{\rb}/1}). This makes it possible to express an extra
  condition.

\end{itemize}

A grammar rule is nothing but a ``syntactic sugar'' for a Prolog clause. Each
grammar rule accepts as input a list of terminals (tokens), parses a prefix
of this list and gives as output the rest of this list (possibly enlarged).
This rest is generally parsed later. So, each a grammar rule is translated
into a Prolog clause that explicitly the manages the list. Two arguments
are then added: the input list (\texttt{Start}) and the output list
(\texttt{End}). For instance:

\OneLine{p --{\gt} q.}

is translated into:

\OneLine{p(Start, End) :- q(Start, End).}

Extra arguments can be provided and the body of the rule can contain several
non-terminals. Example:

\begin{Indentation}
\begin{verbatim}
p(X, Y) -->
        q(X),
        r(X, Y),
        s(Y).
\end{verbatim}
\end{Indentation}

is translated into:

\begin{Indentation}
\begin{verbatim}
p(X, Y, Start, End) :-
        q(X, Start, A),
        r(X, Y, A, B),
        s(Y, B, End).
\end{verbatim}
\end{Indentation}

Terminals are translated using unification:

\OneLine{assign(X,Y) --{\gt} left(X), [:=], right(Y), [;].}

is translated into:

\begin{Indentation}
\begin{verbatim}
assign(X,Y,Start,End) :-
        left(X, Start, A),
        A=[:=|B],
        right(Y, B, C),
        C=[;|End].
\end{verbatim}
\end{Indentation}

Terminals appearing on the left-hand side of a rule are connected to the
output argument of the head.

It is possible to include a call to a prolog predicate enclosing it in curly
brackets (to distinguish them from non-terminals):

\OneLine{assign(X,Y) --{\gt} left(X), [:=], right(Y0), {\lb}Y is Y0 {\rb},
[;].}

is translated into:

\begin{Indentation}
\begin{verbatim}
assign(X,Y,Start,End) :-
        left(X, Start, A),
        A=[:=|B],
        right(Y0, B, C),
        Y is Y0,
        C=[;|End].
\end{verbatim}
\end{Indentation}

Cut, disjunction and if-then(-else) are translated literally (and do not need
to be enclosed in curly brackets).

\subsubsection{\IdxPBD{expand\_term/2},\label{expand-term/2}
               \IdxPBD{term\_expansion/2}}


\begin{TemplatesOneCol}
expand\_term(?term, ?term)\\
term\_expansion(?term, ?term)

\end{TemplatesOneCol}

\Description

\texttt{expand\_term(Term1, Term2)} succeeds if
\texttt{Term2} is a transformation of \texttt{Term1}. The transformation
steps are as follows:

\begin{itemize}

\item if \texttt{Term1} is a variable, it is unified with \texttt{Term2}

\item if \texttt{term\_expansion(Term1, Term2)} succeeds \texttt{Term2} is
  assumed to be the transformation of \texttt{Term1}.

\item if \texttt{Term1} is a DCG then \texttt{Term2} is its translation
  \RefSP{DCG}.

\item otherwise \texttt{Term2} is unified with \texttt{Term1}.

\end{itemize}

\texttt{term\_expansion(Term1, Term2)} is a hook predicate allowing the user
to define a specific transformation.

The GNU Prolog compiler \RefSP{The-GNU-Prolog-compiler} automatically calls
\texttt{expand\_term/2} on each \texttt{Term1} read in. However, in the
current release, only DCG transformation are done by the compiler (i.e.
\texttt{term\_expansion/2} cannot be used). To use
\texttt{term\_expansion/2}, it is necessary to call \texttt{expand\_term/2}
explicitly.

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{phrase/3},
               \IdxPBD{phrase/2}}

\begin{TemplatesOneCol}
phrase(?term, ?list, ?list)\\
phrase(?term, ?list)

\end{TemplatesOneCol}

\Description

\texttt{phrase(Phrase, List, Remainder)} succeeds if the list
\texttt{List} is in the language defined by the grammar rule body
\texttt{Phrase}. \texttt{Remainder} is what remains of the list after a
phrase has been found.

\texttt{phrase(Phrase, List)} is equivalent to
\texttt{phrase(Phrase, List, [])}.

\begin{PlErrors}

\ErrCond{\texttt{Phrase} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Phrase} is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, Phrase)}

\ErrCond{\texttt{List} is neither a list nor a partial list}
\ErrTerm{type\_error(list, List)}

\ErrCond{\texttt{Remainder} is neither a list nor a partial list}
\ErrTerm{type\_error(list, Remainder)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsection{Logic, control and exceptions}

\subsubsection{\IdxPBD{abort/0},\label{abort/0}
               \IdxPBD{stop/0},
               \IdxPBD{top\_level/0},
               \IdxPBD{break/0},
               \IdxPBD{halt/1},
               \IdxPBD{halt/0}}


\begin{TemplatesOneCol}
abort\\
stop\\
top\_level\\
break\\
halt(+integer)\\
halt

\end{TemplatesOneCol}

\Description

\texttt{abort} aborts the current execution. If this execution was initiated
under a \Idx{top-level} the control is given back to the top-level and the
message \texttt{{\lb}execution aborted{\rb}} is displayed. Otherwise,
e.g. execution started by a \texttt{initialization/1} directive
\RefSP{initialization/1}, \texttt{abort/0} is equivalent to
\texttt{halt(1)} (see below).

\texttt{stop} stops the current execution. If this execution was initiated
under a \Idx{top-level} the control is given back to the
top-level. Otherwise, \texttt{stop/0} is equivalent to \texttt{halt(0)}
(see below).

\texttt{top\_level} starts a new recursive \Idx{top-level} (including the
banner display). To end this new \Idx{top-level} simply type the end-of-file
key sequence (\texttt{Ctl-D}) or its term representation:
\texttt{end\_of\_file.}

\texttt{break} invokes a recursive top-level (no banner is displayed). To
end this new level simply type the end-of-file key sequence (\texttt{Ctl-D})
or its term representation: \texttt{end\_of\_file.}

\texttt{halt(Status)} causes the GNU Prolog process to immediately exit back to
the shell with the return code \texttt{Status}.

\texttt{halt} is equivalent to \texttt{halt(0)}.

\begin{PlErrors}

\ErrCond{\texttt{Status} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Status} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Status)}

\end{PlErrors}

\Portability

\texttt{halt/1} and \texttt{halt/0} are ISO predicates. \texttt{abort/0},
\texttt{stop/0}, \texttt{top\_level/0} and \texttt{break/0} are GNU Prolog
predicates.

\subsubsection{\IdxPBD{false/0}, \IdxPBD{once/1}, \IdxPBD{({\bs}+)/1} - not provable,
               \IdxPBD{call/2-11},
	       \IdxPBD{call\_with\_args/1-11}, \IdxPBD{call\_det/2}, \IdxPBD{forall/2}}

\begin{TemplatesOneCol}
false\\
once(+callable\_term)\\
{\bs}+(+callable\_term) \\
call(+callable\_term, +term,\ldots, +term)\\
call\_with\_args(+atom, +term,\ldots, +term)\\
call\_det(+callable\_term, ?boolean) \\
forall(+callable\_term, +callable\_term)

\end{TemplatesOneCol}

\Description

\texttt{false} always fails and enforces backtracking. It is equivalent to the
\IdxCC{fail/0} control construct \RefSP{true/0}.

\texttt{once(Goal)} succeeds if \texttt{call(Goal)} succeeds. However
\texttt{once/1} is not re-executable on backtracking since all alternatives
of \texttt{Goal} are cut. \texttt{once(Goal)} is equivalent to
\texttt{call(Goal), !}.

\texttt{{\bs}+ Goal} succeeds if \texttt{call(Goal)} fails and fails
otherwise. This built-in predicate gives negation by failure.

\texttt{call(Closure, Arg1,\ldots, ArgN)} calls the goal \texttt{call(Goal)}
where \texttt{Goal} is constructed by appending \texttt{Arg1,\ldots, ArgN}
($1 \leq \texttt{N} \leq 10$) additional arguments to the arguments (if any)
of \texttt{Closure}.

\texttt{call\_with\_args(Functor, Arg1,\ldots, ArgN)} calls the goal
whose functor is \texttt{Functor} and whose arguments are
\texttt{Arg1},\ldots, \texttt{ArgN} ($0 \leq \texttt{N} \leq 10$).

\texttt{call\_det(Goal, Deterministic)} succeeds if \texttt{call(Goal)}
succeeds and unifies \texttt{Deterministic} with \texttt{true} if
\texttt{Goal} has not created any choice-points, with \texttt{false}
otherwise.

\texttt{forall(Condition, Action)} succeeds if for all alternative bindings of
\texttt{Condition}, \texttt{Action} can be proven.
It is equivalent to \texttt{{\bs}+ (Condition, {\bs}+ Action)}.


\texttt{{\bs}+} is a predefined prefix operator \RefSP{op/3:(Term-input/output)}.

\begin{PlErrors}

\ErrCond{\texttt{Goal} (or \texttt{Condition} or \texttt{Action}) is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Goal} (or \texttt{Condition} or \texttt{Action}) is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, Goal)}

\ErrCond{The predicate indicator \texttt{Pred} of \texttt{Goal} does not
correspond to an existing procedure and the value of the \texttt{unknown}
Prolog flag is \texttt{error} \RefSP{set-prolog-flag/2}}
\ErrTerm{existence\_error(procedure, Pred)}

\ErrCond{\texttt{Functor} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Functor} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Functor)}

\ErrCond{\texttt{Deterministic} is neither a variable nor a boolean}
\ErrTerm{type\_error(boolean, Deterministic)}

\ErrCond{for \texttt{call/2-11} the resulting arity of \texttt{Goal} (arity of $\texttt{Closure} + \texttt{N}$) is an integer $>$ \texttt{max\_arity} flag \RefSP{set-prolog-flag/2}}
\ErrTerm{representation\_error(max\_arity)}

\end{PlErrors}

\Portability

\texttt{false/0}, \texttt{call/2-8}, \texttt{once/1} and \texttt{({\bs}+)/1}
are ISO predicates. \texttt{call/9-11}, \texttt{call\_with\_args/1-11},
\texttt{call\_det/2} and \texttt{forall/2} are GNU Prolog predicates.

\subsubsection{\IdxPBD{repeat/0}}

\begin{TemplatesOneCol}
repeat

\end{TemplatesOneCol}

\Description

\texttt{repeat} generates an infinite sequence of backtracking choices. The
purpose is to repeatedly perform some action on elements which are somehow
generated, e.g. by reading them from a stream, until some test becomes true.
Repeat loops cannot contribute to the logic of the program. They are only
meaningful if the action involves side-effects. The only reason for using
repeat loops instead of a more natural tail-recursive formulation is
efficiency: when the test fails back, the Prolog engine immediately reclaims
any working storage consumed since the call to \texttt{repeat/0}.

\PlErrorsNone

\Portability

ISO predicate.

\subsubsection{\IdxPBD{between/3}, \IdxPBD{for/3}}

\begin{TemplatesOneCol}
between(+integer, +integer, ?integer) \\
for(?integer, +integer, +integer)

\end{TemplatesOneCol}

\Description

\texttt{between(Lower, Upper, Counter)} generates an sequence of backtracking
choices instantiating \texttt{Counter} to the values \texttt{Lower},
\texttt{Lower+1},\ldots, \texttt{Upper}.  

\texttt{for(Counter, Lower, Upper)} is equivalent to
\texttt{between(Lower, Upper, Counter)}. This predicate is deprecated and new
code should use \texttt{between/3}.

\begin{PlErrors}

\ErrCond{\texttt{Counter} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Counter)}

\ErrCond{\texttt{Lower} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Lower} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Lower)}

\ErrCond{\texttt{Upper} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Upper} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Upper)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{Atomic term processing}
These built-in predicates enable atomic terms to be processed as a sequence
of characters and character codes. Facilities exist to split and join atoms,
to convert a single character to and from the corresponding character code,
and to convert a number to and from a list of characters and character
codes.

\subsubsection{\IdxPBD{atom\_length/2}}

\begin{TemplatesOneCol}
atom\_length(+atom, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{atom\_length(Atom, Length)} succeeds if \texttt{Length} unifies with
the number of characters of the name of \texttt{Atom}.

\begin{PlErrors}

\ErrCond{\texttt{Atom} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Atom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom)}

\ErrCond{\texttt{Length} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Length)}

\ErrCond{\texttt{Length} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Length)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{atom\_concat/3}}

\begin{TemplatesOneCol}
atom\_concat(+atom, +atom, ?atom)\\
atom\_concat(?atom, ?atom, +atom)

\end{TemplatesOneCol}

\Description

\texttt{atom\_concat(Atom1, Atom2, Atom12)} succeeds if the name of
\texttt{Atom12} is the concatenation of the name of \texttt{Atom1} with the
name of \texttt{Atom1}. This predicate is re-executable on backtracking
(e.g. if \texttt{Atom12} is instantiated and both \texttt{Atom1} and
\texttt{Atom2} are variables).

\begin{PlErrors}

\ErrCond{\texttt{Atom1} and \texttt{Atom12} are variables}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Atom2} and \texttt{Atom12} are variables}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Atom1} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom1)}

\ErrCond{\texttt{Atom2} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom2)}

\ErrCond{\texttt{Atom12} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom12)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{sub\_atom/5}}

\begin{TemplatesOneCol}
sub\_atom(+atom, ?integer, ?integer, ?integer, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{sub\_atom(Atom, Before, Length, After, SubAtom)} succeeds if atom
\texttt{Atom} can be split into three atoms, \texttt{AtomL},
\texttt{SubAtom} and \texttt{AtomR} such that \texttt{Before} is the number
of characters of the name of \texttt{AtomL}, \texttt{Length} is the number
of characters of the name of \texttt{SubAtom} and \texttt{After} is the
number of characters of the name of \texttt{AtomR}. This predicate is
re-executable on backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Atom} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Atom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom)}

\ErrCond{\texttt{SubAtom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, SubAtom)}

\ErrCond{\texttt{Before} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Before)}

\ErrCond{\texttt{Length} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Length)}

\ErrCond{\texttt{After} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, After)}

\ErrCond{\texttt{Before} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Before)}

\ErrCond{\texttt{Length} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Length)}

\ErrCond{\texttt{After} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, After)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{char\_code/2}\label{char-code/2}}

\begin{TemplatesOneCol}
char\_code(+character, ?character\_code)\\
char\_code(-character, +character\_code)

\end{TemplatesOneCol}

\Description

\texttt{char\_code(Char, Code)} succeeds if the character code for the
one-char atom \texttt{Char} is \texttt{Code}.

\begin{PlErrors}

\ErrCond{\texttt{Char} and \texttt{Code} are variables}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Char} is neither a variable nor a one-char atom}
\ErrTerm{type\_error(character, Char)}

\ErrCond{\texttt{Code} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Code)}

\ErrCond{\texttt{Code} is an integer but not a character code}
\ErrTerm{representation\_error(character\_code)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{lower\_upper/2}}

\begin{TemplatesOneCol}
lower\_upper(+character, ?character)\\
lower\_upper(-character, +character)

\end{TemplatesOneCol}

\Description

\texttt{lower\_upper(Char1, Char2)} succeeds if \texttt{Char1} and
\texttt{Char2} are one-char atoms and if \texttt{Char2} is the upper
conversion of \texttt{Char1}. If \texttt{Char1} (resp. \texttt{Char2}) is a
character that is not a lower (resp. upper) letter then \texttt{Char2} is
equal to \texttt{Char1}.

\begin{PlErrors}

\ErrCond{\texttt{Char1} and \texttt{Char2} are variables}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Char1} is neither a variable nor a one-char atom}
\ErrTerm{type\_error(character, Char1)}

\ErrCond{\texttt{Char2} is neither a variable nor a one-char atom}
\ErrTerm{type\_error(character, Char2)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{atom\_chars/2},\label{atom-chars/2}
               \IdxPBD{atom\_codes/2}}


\begin{TemplatesOneCol}
atom\_chars(+atom, ?character\_list)\\
atom\_chars(-atom, +character\_list)\\
atom\_codes(+atom, ?character\_code\_list)\\
atom\_codes(-atom, +character\_code\_list)

\end{TemplatesOneCol}

\Description

\texttt{atom\_chars(Atom, Chars)} succeeds if \texttt{Chars}
is the list of one-char atoms whose names are the successive characters of
the name of \texttt{Atom}.

\texttt{atom\_codes(Atom, Codes)} is similar to
\texttt{atom\_chars/2} but deals with a list of character codes.

\begin{PlErrors}

\ErrCond{\texttt{Atom} is a variable and \texttt{Chars} (or \texttt{Codes})
is a partial list or a list with an element which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Atom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom)}

\ErrCond{\texttt{Chars} is neither a list nor a partial list}
\ErrTerm{type\_error(list, Chars)}

\ErrCond{\texttt{Codes} is neither a list nor a partial list}
\ErrTerm{type\_error(list, Codes)}

\ErrCond{An element \texttt{E} of the list \texttt{Chars} is neither a
  variable nor a one-char atom} \ErrTerm{type\_error(character, E)}

\ErrCond{An element \texttt{E} of the list \texttt{Codes} is neither a
  variable nor an integer} \ErrTerm{type\_error(integer, E)}

\ErrCond{An element \texttt{E} of the list \texttt{Codes} is an integer but
  not a character code} \ErrTerm{representation\_error(character\_code)}

\end{PlErrors}

\Portability

ISO predicates. The ISO reference only causes a \texttt{type\_error(list,
Chars)} if \texttt{Atom} is a variable and \texttt{Chars} is neither a list
nor a partial list. GNU Prolog always checks if \texttt{Chars} is a list.
Similarly for \texttt{Codes}. The \texttt{type\_error(integer, E)} when an
element \texttt{E} of the \texttt{Codes} is not an integer is a GNU Prolog
extension. This seems to be an omission in the ISO reference since this
error is detected for many other built-in predicates accepting a character
code (e.g. \texttt{char\_code/2}, \texttt{put\_code/2}).

\subsubsection{\IdxPBD{number\_atom/2},\label{number-atom/2}
               \IdxPBD{number\_chars/2},
               \IdxPBD{number\_codes/2}}


\begin{TemplatesOneCol}
number\_atom(+number, ?atom)\\
number\_atom(-number, +atom)\\
number\_chars(+number, ?character\_list)\\
number\_chars(-number, +character\_list)\\
number\_codes(+number, ?character\_code\_list)\\
number\_codes(-number, +character\_code\_list)

\end{TemplatesOneCol}

\Description

\texttt{number\_atom(Number, Atom)} succeeds if
\texttt{Atom} is an atom whose name corresponds to the characters of
\texttt{Number}.

\texttt{number\_chars(Number, Chars)} is similar to
\texttt{number\_atom/2} but deals with a list of characters.

\texttt{number\_codes(Number, Codes)} is similar to
\texttt{number\_atom/2} but deals with a list of character codes.

\begin{PlErrors}

\ErrCond{\texttt{Number} and \texttt{Atom} are variables}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Number} is a variable and \texttt{Chars} (or
\texttt{Codes}) is a partial list or a list with an element which is a
variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Number} is neither a variable nor an number}
\ErrTerm{type\_error(number, Number)}

\ErrCond{\texttt{Atom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom)}

\ErrCond{\texttt{Chars} is neither a list nor a partial list}
\ErrTerm{type\_error(list, Chars)}

\ErrCond{\texttt{Codes} is neither a list nor a partial list}
\ErrTerm{type\_error(list, Codes)}

\ErrCond{An element \texttt{E} of the list \texttt{Chars} is neither a
  variable nor a one-char atom} \ErrTerm{type\_error(character, E)}

\ErrCond{An element \texttt{E} of the list \texttt{Codes} is neither a
  variable nor an integer} \ErrTerm{type\_error(integer, E)}

\ErrCond{An element \texttt{E} of the list \texttt{Codes} is an integer but
  not a character code} \ErrTerm{representation\_error(character\_code)}

\ErrCond{\texttt{Number} is a variable, \texttt{Atom} (or \texttt{Chars} or
\texttt{Codes}) cannot be parsed as a number and the value of the
\texttt{syntax\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{syntax\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

\texttt{number\_atom/2} is a GNU Prolog predicate. \texttt{number\_chars/2}
and \texttt{number\_codes/2} are ISO predicates.

GNU Prolog only raises an error about an element \texttt{E} of the
\texttt{Chars} (or \texttt{Codes}) list when \texttt{Number} is a variable
while the ISO reference always check this. This seems an error since
the list itself is only checked if \texttt{Number} is a variable.

The \texttt{type\_error(integer, E)} when an element \texttt{E} of the
\texttt{Codes} is not an integer is a GNU Prolog extension. This seems to be
an omission in the ISO reference since this error is detected for many other
built-in predicates accepting a character code (e.g. \texttt{char\_code/2},
\texttt{put\_code/2}).

\subsubsection{\IdxPBD{name/2}}

\begin{TemplatesOneCol}
name(+atomic, ?character\_code\_list)\\
name(-atomic, +character\_code\_list)

\end{TemplatesOneCol}

\Description

\texttt{name(Constant, Codes)} succeeds if \texttt{Codes} is a list whose
elements are the character codes corresponding to the successive characters
of \texttt{Constant} (a number or an atom). However, there atoms are for
which \texttt{name(Constant, Codes)} is true, but which will not be
constructed if \texttt{name/2} is called with \texttt{Constant}
uninstantiated, e.g. the atom \texttt{'1024'}. For this reason the use of
\texttt{name/2} is discouraged and should be limited to compatibility
purposes. It is preferable to use atom\_codes/2 \RefSP{atom-chars/2}
or number\_chars/2 \RefSP{number-atom/2}.

\begin{PlErrors}

\ErrCond{\texttt{Constant} is a variable and \texttt{Codes} is a partial
list or a list with an element which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Constant} is neither a variable nor an atomic term}
\ErrTerm{type\_error(atomic, Constant)}

\ErrCond{\texttt{Constant} is a variable and \texttt{Codes} is neither a list
nor a partial list}
\ErrTerm{type\_error(list, Codes)}

\ErrCond{\texttt{Constant} is a variable and an element \texttt{E} of the
list \texttt{Codes} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, E)}

\ErrCond{\texttt{Constant} is a variable and an element \texttt{E} of the
list \texttt{Codes} is an integer but not a character code}
\ErrTerm{representation\_error(character\_code)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{new\_atom/2},
               \IdxPBD{new\_atom/1}}

\begin{TemplatesOneCol}
new\_atom(+atom, -atom)\\
new\_atom(-atom)

\end{TemplatesOneCol}

\Description

\texttt{new\_atom(Prefix, Atom)} unifies \texttt{Atom} with a new atom
whose name begins with the characters of the name of \texttt{Prefix}. 
This predicate is then a symbol generator. It is guaranteed that \texttt{Atom} does not exist
before the invocation of \texttt{new\_atom/3}. The characters appended to
\texttt{Prefix} to form \texttt{Atom} are in: \texttt{A}-\texttt{Z} (capital
letter), \texttt{a}-\texttt{z} (small letter) and \texttt{0}-\texttt{9}
(digit).

\texttt{new\_atom/1} is similar to \texttt{new\_atom(term\_, Atom)}, i.e.
the generated atom begins with \texttt{term\_}.

\begin{PlErrors}

\ErrCond{\texttt{Prefix} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Prefix} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Prefix)}

\ErrCond{\texttt{Atom} is not a variable}
\ErrTerm{uninstantiation\_error(Atom)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{current\_atom/1}\label{current-atom/2}}

\begin{TemplatesOneCol}
current\_atom(?atom)

\end{TemplatesOneCol}

\Description

\texttt{current\_atom(Atom)} succeeds if there exists an atom that unifies
with \texttt{Atom}. All atoms are found except those beginning with a
\texttt{'\$'} (system atoms). This predicate is re-executable on
backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Atom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{atom\_property/2}\label{atom-property/2}}

\begin{TemplatesOneCol}
atom\_property(?atom, ?atom\_property)

\end{TemplatesOneCol}

\Description

\texttt{atom\_property(Atom, Property)} succeeds if
\texttt{current\_atom(Atom)} succeeds \RefSP{current-atom/2} and if
\texttt{Property} unifies with one of the properties of the atom. This
predicate is re-executable on backtracking.

\SPart{Atom properties}:

\begin{itemize}

\item \AddPPD{length}\texttt{length(Length)}: \texttt{Length} is the length of the
name of the atom.

\item \AddPPD{hash}\texttt{hash(Hash)}: \texttt{Hash} is the \Idx{hash code} of the
atom, see also \texttt{term\_hash/2} \RefSP{term-hash/4}.

\item \IdxPPD{prefix\_op}: if there is a prefix operator currently defined
with this name.

\item \IdxPPD{infix\_op}: if there is an infix operator currently defined
with this name.

\item \IdxPPD{postfix\_op}: if there is a postfix operator currently defined
with this name.

\item \IdxPPD{needs\_quotes}: if the atom must be quoted to be read later.

\item \IdxPPD{needs\_scan}: if the atom must be scanned when output to be
read later (e.g. contains special characters that must be output with a
\texttt{{\bs}} \Idx{escape sequence}).

\end{itemize}

\begin{PlErrors}

\ErrCond{\texttt{Atom} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Atom)}

\ErrCond{\texttt{Property} is neither a variable nor a n atom property term}
\ErrTerm{domain\_error(atom\_property, Property)}

\ErrCond{\texttt{Property} = \texttt{length(E)} or \texttt{hash(E)} and
\texttt{E} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, E)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{List processing}

These predicates manipulate lists. They are bootstrapped predicates (i.e.
written in Prolog) and no error cases are tested (for the moment). However,
since they are written in Prolog using other built-in predicates, some
errors can occur due to those built-in predicates.

\subsubsection{\IdxPBD{append/3}}

\begin{TemplatesOneCol}
append(?list, ?list, ?list)

\end{TemplatesOneCol}

\Description

\texttt{append(List1, List2, List12)} succeeds if the concatenation of the
list \texttt{List1} and the list \texttt{List2} is the list \texttt{List12}.
This predicate is re-executable on backtracking (e.g. if \texttt{List12} is
instantiated and both \texttt{List1} and \texttt{List2} are variable).

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{member/2}, \label{member/2}
               \IdxPBD{memberchk/2}}

\begin{TemplatesOneCol}
member(?term, ?list)\\
memberchk(?term, ?list)

\end{TemplatesOneCol}

\Description

\texttt{member(Element, List)} succeeds if \texttt{Element} belongs to the
\texttt{List}. This predicate is re-executable on backtracking and can be
thus used to enumerate the elements of \texttt{List}.

\texttt{memberchk/2} is similar to \texttt{member/2} but only succeeds once.

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{reverse/2}}

\begin{TemplatesOneCol}
reverse(?list, ?list)

\end{TemplatesOneCol}

\Description

\texttt{reverse(List1, List2)} succeeds if \texttt{List2} unifies with the
list \texttt{List1} in reverse order.

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{delete/3},
  \IdxPBD{select/3}}

\begin{TemplatesOneCol}
delete(?list, ?term, ?list)\\
select(?term, ?list, ?list)

\end{TemplatesOneCol}

\Description

\texttt{delete(List1, Element, List2)} removes all occurrences of
\texttt{Element} in \texttt{List1} to provide \texttt{List2}. A strict term
equality is required, cf. \IdxPB{(==)/2} \RefSP{(==)/2}.

\texttt{select(Element, List1, List2)} removes one occurrence of
\texttt{Element} in \texttt{List1} to provide \texttt{List2}. This predicate
is re-executable on backtracking.

\PlErrorsNone

\Portability

GNU Prolog predicate.


\subsubsection{\IdxPBD{subtract/3}}

\begin{TemplatesOneCol}
subtract(+list, +list, ?list)
\end{TemplatesOneCol}

\Description

\texttt{subtract(List1, List2, List3)} removes all elements in \texttt{List2}
from \texttt{List1} to provide \texttt{List3}. Membership is tested using
\texttt{memberchk/2} \RefSP{member/2}. The predicate runs in
$O(|\texttt{List2}| \times |\texttt{List1}|)$.

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{permutation/2}}

\begin{TemplatesOneCol}
permutation(?list, ?list)

\end{TemplatesOneCol}

\Description

\texttt{permutation(List1, List2)} succeeds if \texttt{List2}
is a permutation of the elements of \texttt{List1}. This predicate is
re-executable on backtracking.

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{prefix/2},
               \IdxPBD{suffix/2}}

\begin{TemplatesOneCol}
prefix(?list, ?list)\\
suffix(?list, ?list)

\end{TemplatesOneCol}

\Description

\texttt{prefix(Prefix, List)} succeeds if \texttt{Prefix} is a prefix of
\texttt{List}. This predicate is re-executable on backtracking.

\texttt{suffix(Suffix, List)} succeeds if \texttt{Suffix} is a suffix of
\texttt{List}. This predicate is re-executable on backtracking.

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{sublist/2}}

\begin{TemplatesOneCol}
sublist(?list, ?list)

\end{TemplatesOneCol}

\Description

\texttt{sublist(List1, List2)} succeeds if all elements of \texttt{List1} appear in \texttt{List2} in the same order. This predicate is re-executable on backtracking.

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{last/2}}

\begin{TemplatesOneCol}
last(?list, ?term)

\end{TemplatesOneCol}

\Description

\texttt{last(List, Element)} succeeds if \texttt{Element} is the last element
of \texttt{List}.

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{length/2}}

\begin{TemplatesOneCol}
length(?list, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{length(List, Length)} succeeds if \texttt{Length} is the length of
\texttt{List}.

\begin{PlErrors}

\ErrCond{\texttt{Length} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Length)}

\end{PlErrors}

GNU Prolog predicate.

\subsubsection{\IdxPBD{nth/3}}

\begin{TemplatesOneCol}
nth(?integer, ?list, ?term)

\end{TemplatesOneCol}

\Description

\texttt{nth(N, List, Element)} succeeds if the \texttt{N}\emph{th}
argument of \texttt{List} is \texttt{Element}.

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{max\_list/2},
               \IdxPBD{min\_list/2},
               \IdxPBD{sum\_list/2}}

\begin{TemplatesOneCol}
min\_list(+list, ?number)\\
max\_list(+list, ?number)\\
sum\_list(+list, ?number)

\end{TemplatesOneCol}

\Description

\texttt{min\_list(List, Min)} succeeds if \texttt{Min} is the
smallest number in \texttt{List}.

\texttt{max\_list(List, Max)} succeeds if \texttt{Max} is the
largest number in \texttt{List}.

\texttt{sum\_list(List, Sum)} succeeds if \texttt{Sum} is the
sum of all the elements in \texttt{List}.

\texttt{List} must be a list of arithmetic evaluable terms
\RefSP{Evaluation-of-an-arithmetic-expression}.

\PlErrorsNone

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{maplist/2-8}}

\begin{TemplatesOneCol}
maplist(+callable\_term, +list, \ldots, +list)

\end{TemplatesOneCol}

\Description

\texttt{maplist(Goal, List)} succeeds if \texttt{Goal} can succesfully be
applied on all elements of \texttt{List}.

\texttt{maplist(Goal, List1, List2)} succeeds if \texttt{Goal} can succesfully be
applied to all pairs of elements of \texttt{List1} and \texttt{List2}.

\texttt{maplist(Goal, List1, List2, List3)} succeeds if \texttt{Goal} can succesfully be
applied to all triples of elements of \texttt{List1}..\texttt{List3}.

\texttt{maplist(Goal, List1, List2, \ldots, List$N$)} succeeds if \texttt{Goal} can succesfully be
applied to all $N$-uples ($N \leq 8$) of elements of \texttt{List1}..\texttt{List$N$}.

\begin{PlErrors}

\ErrCond{an error occurs executing a directive}
\ErrTermRm{see \texttt{call/1} errors \RefSP{call/1}}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{sort/2},\label{sort/2}
               \IdxPBD{msort/2},
               \IdxPBD{keysort/2}
               \IdxPBD{sort/1},
               \IdxPBD{msort/1},
               \IdxPBD{keysort/1}}


\begin{TemplatesOneCol}
sort(+list, ?list)\\
msort(+list, ?list)\\
keysort(+list, ?list)\\
sort(+list)\\
msort(+list)\\
keysort(+list)

\end{TemplatesOneCol}

\Description

\texttt{sort(List1, List2)} succeeds if \texttt{List2} is the
sorted list corresponding to \texttt{List1} where duplicate elements are
merged.

\texttt{msort/2} is similar to \texttt{sort/2} except that duplicate elements
are not merged.

\texttt{keysort(List1, List2)} succeeds if \texttt{List2} is the
sorted list of \texttt{List1} according to the keys. The list \texttt{List1}
consists of pairs (items of the form \texttt{Key-Value}). These items are sorted
according to the value of \texttt{Key} yielding the \texttt{List2}. Duplicate
keys are not merged. This predicate is stable, i.e. if \texttt{K-A} occurs
before \texttt{K-B} in the input, then \texttt{K-A} will occur before
\texttt{K-B} in the output.

\texttt{sort/1}, \texttt{msort/1} and \texttt{keysort/1} are similar to
\texttt{sort/2}, \texttt{msort/2} and \texttt{keysort/2} but achieve a sort
in-place destructing the original \texttt{List1} (this in-place assignment is
not undone at backtracking). The sorted list occupies the same memory space
as the original list (saving thus memory consumption).

The time complexity of these sorts is $O(N~log~N)$, $N$ being the length of
the list to sort.

These predicates refer to the standard ordering of terms
\RefSP{Standard-total-ordering-of-terms}.

\begin{PlErrors}

\ErrCond{\texttt{List1} is a partial list}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{List1} is neither a partial list nor a list}
\ErrTerm{type\_error(list, List1)}

\ErrCond{\texttt{List2} is neither a partial list nor a list}
\ErrTerm{type\_error(list, List2)}

\ErrCond{for \texttt{keysort/2}: an element of \texttt{List1} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{for \texttt{keysort/2}: an element \texttt{E} of \texttt{List1} is neither a variable nor a pair}
\ErrTerm{type\_error(pair, E)}

\ErrCond{for \texttt{keysort/2}: an element \texttt{E} of \texttt{List2} is neither a variable nor a pair}
\ErrTerm{type\_error(pair, E)}

\end{PlErrors}

\Portability

\texttt{sort/2} and \texttt{keysort/2} are ISO predicates.

\texttt{sort/1}, \texttt{keysort/1} and \texttt{msort/1-2} are GNU Prolog predicates.


\subsection{Global variables}

\subsubsection{Introduction}
\label{Global-variables}

GNU Prolog provides a simple and powerful way to assign and read global
variables. A global variable is associated with each atom, its initial value is
the integer 0. A global variable can store 3 kinds of objects:

\begin{itemize}

\item a copy of a term (the assignment can be made backtrackable or not).

\item a link to a term (the assignment is always backtrackable).

\item an array of objects (recursively).

\end{itemize}

The space necessary for copies and arrays is dynamically allocated and
recovered as soon as possible. For instance, when an atom is associated with a
global variable whose current value is an array, the space for this array is
recovered (unless the assignment is to be undone when backtracking occurs).

When a link to a term is associated with a global variable, the reference to
this term is stored and thus the original term is returned when the content
of the variable is read.

\SPart{Global variable naming convention}: a global variable is referenced
by an atom.

If the variable contains an array, an index (ranging from 0) can be provided
using a compound term whose principal functor is the corresponding atom and
the argument is the index. In case of a multi-dimensional array, each index
is given as the arguments of the compound term.

If the variable contains a term (link or copy), it is possible to only
reference a sub-term by giving its argument number (also called \IdxD{argument
selector}). Such a sub-term is specified using a compound term whose
principal functor is \texttt{-/2} and whose first argument is a global
variable name and the second argument is the argument number (from 1). This
can be applied recursively to specify a sub-term of any depth. In case of a
list, a argument number I represents the Ith element of the list.  In the
rest of this section we use the operator notation since \texttt{-} is a
predefined infix operator \RefSP{op/3:(Term-input/output)}.

In the following, \Param{GVarName} represents a reference to a global
variable and its syntax is as follows:

\begin{Indentation}
\begin{tabular}{@{}llll}
\Param{GVarName} & ::= & \Param{atom} & whole content of a variable \\
                 &     & \Param{atom}\texttt{(}\Param{Integer}\texttt{,}\ldots\texttt{,}\Param{Integer}\texttt{)} & element of an array \\
                 &     & \Param{GVarName}\texttt{-}\Param{Integer} & sub-term selection \\
\Param{Integer}  & ::= & \Param{integer} & immediate value \\
                 &     & \Param{GVarName} & indirect value
\end{tabular}
\end{Indentation}

When a \Param{GVarName} is used as an index or an argument number
(i.e. indirection), the value of this variable must be an integer.

Here are some examples of the naming convention:

\begin{tabular}{ll}
\texttt{a} & the content of variable associated with \texttt{a} (any kind) \\
\texttt{t(1)} & the 2nd element of the array associated with \texttt{t} \\
\texttt{t(k)} & if the value associated with \texttt{k} is I, the Ith element of the array associated with \texttt{t} \\
\texttt{a-1-2} & if the value associated with \texttt{a} is \texttt{f(g(a,b,c),2)}, the sub-term \texttt{b} \\
\end{tabular}

Here are the errors associated with global variable names and common to all
predicates.

\begin{PlErrorsNoTitle}

\ErrCond{\texttt{GVarName} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{GVarName} is neither a variable nor a callable term}
\ErrTerm{type\_error(callable, GVarName)}

\ErrCond{\texttt{GVarName} contains an invalid argument number
(or \texttt{GVarName} is an array)}
\ErrTerm{domain\_error(g\_argument\_selector, GVarName)}

\ErrCond{\texttt{GVarName} contains an invalid index
(or \texttt{GVarName} is not an array)}
\ErrTerm{domain\_error(g\_array\_index, GVarName)}

\ErrCond{\texttt{GVarName} is used as an indirect index or argument selector
 and is not an integer}
\ErrTerm{type\_error(integer, GVarName)}

\end{PlErrorsNoTitle}

\SPart{Arrays}: the predicates \texttt{g\_assign/2}, \texttt{g\_assignb/2}
and \texttt{g\_link/2} \RefSP{g-assign/2} can be used to create an
array. They recognize some terms as values. For instance, a compound term
with principal functor \IdxPGD{g\_array} is used to define an array of fixed
size.  There are 3 forms for the term \texttt{g\_array}:

\begin{itemize}

\item \texttt{g\_array(Size)}: if \texttt{Size} is an integer $>$ 0 then
defines an array of \texttt{Size} elements which are all initialized with
the integer \texttt{0}.

\item \texttt{g\_array(Size, Initial)}: as above but the elements are
initialized with the term \texttt{Initial} instead of 0. \texttt{Initial}
can contain other array definitions allowing thus for multi-dimensional
arrays.

\item \texttt{g\_array(List)}: as above if \texttt{List} is a list of length
\texttt{Size} except that the elements of the array are initialized
according to the elements of \texttt{List} (which can contain other array
definitions).

\end{itemize}

An array can be extended explicitly using a compound term with principal
functor \IdxPGD{g\_array\_extend} which accept the same 3 forms detailed
above. In that case, the existing elements of the array are not
initialized. If \texttt{g\_array\_extend} is used with an object which is not
an array it is similar to \texttt{g\_array}.

Finally, an array can be \textit{automatically} expanded when needed. The
programmer does not need to explicitly control the expansion of an automatic
array. An array is expanded as soon as an index is outside the current size
of this array. Such an array is defined using a compound term with principal
functor \IdxPGD{g\_array\_auto}:

\begin{itemize}

\item \texttt{g\_array\_auto(Size)}: if \texttt{Size} is an integer $>$ 0
then defines an automatic array whose initial size is \texttt{Size}. All
elements are initialized with the integer \texttt{0}. Elements
created during implicit expansions will be initialized with \texttt{0}.

\item \texttt{g\_array\_auto(Size, Initial)}: as above but the elements are
initialized with the term \texttt{Initial} instead of 0. \texttt{Initial} can
contain other array definitions allowing thus for multi-dimensional
arrays. Elements created during implicit expansions will be initialized with
\texttt{Initial}.

\item \texttt{g\_array\_auto(List)}: as above if \texttt{List} is a list of
length \texttt{Size} except that the elements of the array are initialized
according to the elements of \texttt{List} (which can contain other array
definitions). Elements created during implicit expansions will be initialized
with \texttt{0}.

\end{itemize}

In any case, when an array is read, a term of the form
\texttt{g\_array([Elem0,..., ElemSize-1])} is returned.

Some examples using global variables are presented later \RefSP{Examples}.

\subsubsection{\IdxPBD{g\_assign/2},\label{g-assign/2}
               \IdxPBD{g\_assignb/2},
               \IdxPBD{g\_link/2}}


\begin{TemplatesOneCol}
g\_assign(+callable\_term, ?term)\\
g\_assignb(+callable\_term, ?term)\\
g\_link(+callable\_term, ?term)

\end{TemplatesOneCol}

\Description

\texttt{g\_assign(GVarName, Value)} assigns a copy of the term
\texttt{Value} to \texttt{GVarName}. This assignment is not undone when
backtracking occurs.

\texttt{g\_assignb/2} is similar to \texttt{g\_assign/2} but the assignment
is undone at backtracking.

\texttt{g\_link(GVarName, Value)} makes a link between \texttt{GVarName} to
the term \texttt{Value}. This allows the user to give a name to any Prolog
term (in particular non-ground terms). Such an assignment is always undone
when backtracking occurs (since the term may no longer exist). If
\texttt{Value} is an atom or an integer, \texttt{g\_link/2} and
\texttt{g\_assignb/2} have the same behavior. Since \texttt{g\_link/2} only
handles links to existing terms it does not require extra memory space and
is not expensive in terms of execution time.

NB: argument selectors can only be used with {g\_assign/2} (i.e. when using
an argument selector inside an assignment, this one must not be
backtrackable).

\Errors

See common errors detailed in the introduction \RefSP{Global-variables}

\begin{PlErrorsNoTitle}

\ErrCond{\texttt{GVarName} contains an argument selector and the assignment
is backtrackable}
\ErrTerm{domain\_error(g\_argument\_selector, GVarName)}

\end{PlErrorsNoTitle}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{g\_read/2}}

\begin{TemplatesOneCol}
g\_read(+callable\_term, ?term)

\end{TemplatesOneCol}

\Description

\texttt{g\_read(GVarName, Value)} unifies \texttt{Value} with the term
assigned to \texttt{GVarName}.

\Errors

See common errors detailed in the introduction \RefSP{Global-variables}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{g\_array\_size/2}}

\begin{TemplatesOneCol}
g\_array\_size(+callable\_term, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{g\_array\_size(GVarName, Value)} unifies \texttt{Size} with the
dimension (an integer $>$ 0) of the array assigned to \texttt{GVarName}.
Fails if \texttt{GVarName} is not an array.

\Errors

See common errors detailed in the introduction \RefSP{Global-variables}

\begin{PlErrorsNoTitle}

\ErrCond{\texttt{Size} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Size)}

\end{PlErrorsNoTitle}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{g\_inc/3},
               \IdxPBD{g\_inc/2},
               \IdxPBD{g\_inco/2},
               \IdxPBD{g\_inc/1},
               \IdxPBD{g\_dec/3},
               \IdxPBD{g\_dec/2},
               \IdxPBD{g\_deco/2},
               \IdxPBD{g\_dec/1}}

\begin{TemplatesOneCol}
g\_inc(+callable\_term, ?integer, ?integer) \\
g\_inc(+callable\_term, ?integer) \\
g\_inco(+callable\_term, ?integer) \\
g\_inc(+callable\_term) \\
g\_dec(+callable\_term, ?integer, ?integer) \\
g\_dec(+callable\_term, ?integer) \\
g\_deco(+callable\_term, ?integer) \\
g\_dec(+callable\_term)

\end{TemplatesOneCol}

\Description

\texttt{g\_inc(GVarName, Old, New)} unifies \texttt{Old} with the
integer assigned to \texttt{GVarName}, increments \texttt{GVarName} and
then unifies \texttt{New} with the incremented value.

\texttt{g\_inc(GVarName, New)} is equivalent to
\texttt{g\_inc(GVarName, \_, New)}.

\texttt{g\_inco(GVarName, Old)} is equivalent to
\texttt{g\_inc(GVarName, Old, \_)}.

\texttt{g\_inc(GVarName)} is equivalent to \texttt{g\_inc(GVarName, \_, \_)}.

Predicates \texttt{g\_dec} are similar but decrement the content of
\texttt{GVarName} instead.

\Errors

See common errors detailed in the introduction \RefSP{Global-variables}

\begin{PlErrorsNoTitle}

\ErrCond{\texttt{Old} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Old)}

\ErrCond{\texttt{New} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, New)}

\ErrCond{\texttt{GVarName} stores an array}
\ErrTerm{type\_error(integer, g\_array)}

\ErrCond{\texttt{GVarName} stores a term \texttt{T} which is not an integer}
\ErrTerm{type\_error(integer, T)}

\end{PlErrorsNoTitle}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{g\_set\_bit/2},
               \IdxPBD{g\_reset\_bit/2},
               \IdxPBD{g\_test\_set\_bit/2},
               \IdxPBD{g\_test\_reset\_bit/2}}

\begin{TemplatesOneCol}
g\_set\_bit(+callable\_term, +integer) \\
g\_reset\_bit(+callable\_term, +integer) \\
g\_test\_set\_bit(+callable\_term, +integer) \\
g\_test\_reset\_bit(+callable\_term, +integer)

\end{TemplatesOneCol}

\Description

\texttt{g\_set\_bit(GVarName, Bit)} sets to 1 the bit number specified by
\texttt{Bit} of the integer assigned to \texttt{GVarName} to 1. Bit numbers
range from 0 to the maximum number allowed for integers (this is architecture dependent). If \texttt{Bit} is greater than this limit,
the modulo with this limit is taken.

\texttt{g\_reset\_bit(GVarName, Bit)} is similar to \texttt{g\_set\_bit/2} but
sets the specified bit to 0.

\texttt{g\_test\_set\_bit/2} succeeds if the specified bit is set to 1.

\texttt{g\_test\_reset\_bit/2} succeeds if the specified bit is set to 0.

\Errors

See common errors detailed in the introduction \RefSP{Global-variables}

\begin{PlErrorsNoTitle}

\ErrCond{\texttt{Bit} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Bit} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Bit)}

\ErrCond{\texttt{Bit} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Bit)}

\ErrCond{\texttt{GVarName} stores an array}
\ErrTerm{type\_error(integer, g\_array)}

\ErrCond{\texttt{GVarName} stores a term \texttt{T} which is not an integer}
\ErrTerm{type\_error(integer, T)}

\end{PlErrorsNoTitle}

\Portability

GNU Prolog predicates.

\subsubsection{Examples}
\label{Examples}

\SPart{Simulating \texttt{g\_inc/3}}: this predicate behaves like:
global variable:

\begin{Indentation}
\begin{verbatim}
my_g_inc(Var, Old, New) :-
        g_read(Var, Old),
        N is Value + 1,
        g_assign(Var, X),
	New = N.
\end{verbatim}
\end{Indentation}

The query: \texttt{my\_g\_inc(c, X, \_)} will succeed unifying \texttt{X} with
\texttt{0}, another call to \texttt{my\_g\_inc(a, Y, \_)} will then unify
\texttt{Y} with \texttt{1}, and so on.

\SPart{Difference between \texttt{g\_assign/2} and \texttt{g\_assignb/2}}:
\texttt{g\_assign/2} does not undo its assignment when backtracking occurs
whereas \texttt{g\_assignb/2} undoes it.

\begin{Code}
\begin{tabular}{@{}p{6cm}@{\quad}l@{}}
test(Old) :-                 & testb(Old) :- \\
~~~~~~~~g\_assign(x,1),      & ~~~~~~~~g\_assign(x,1), \\
~~~~~~~~(~~~g\_read(x, Old), & ~~~~~~~~(~~~g\_read(x, Old), \\
~~~~~~~~~~~~\textit{g\_assign}(x, 2)  & ~~~~~~~~~~~~\textit{g\_assignb}(x, 2) \\
~~~~~~~~;~~~g\_read(x,~Old), & ~~~~~~~~;~~~g\_read(x, Old), \\
~~~~~~~~~~~~g\_assign(x, 3)  & ~~~~~~~~~~~~g\_assign(x, 3) \\
~~~~~~~~).                   & ~~~~~~~~).                  \\
\end{tabular}
\end{Code}

The query \texttt{test(Old)} will succeed unifying \texttt{Old} with
\texttt{1} and on backtracking with \texttt{2} (i.e. the assignment of the
value \texttt{2} has not been undone). The query \texttt{testb(Old)} will
succeed unifying \texttt{Old} with \texttt{1} and on backtracking with
\texttt{1} (i.e. the assignment of the value \texttt{2} has been undone).

\SPart{Difference between \texttt{g\_assign/2} and \texttt{g\_link/2}}:
\texttt{g\_assign/2} (and \texttt{g\_assignb/2}) creates a copy of the term
whereas \texttt{g\_link/2} does not. \texttt{g\_link/2} can be used to avoid
passing big data structures (e.g. dictionaries,\ldots) as arguments to
predicates.

\begin{Code}
\begin{tabular}{@{}p{6cm}@{\quad}l@{}}
test(B) :-                           & test(B) :-                \\
~~~~~~~~\textit{g\_assign}(b, f(X)), & ~~~~~~~~\textit{g\_link}(b, f(X)), \\
~~~~~~~~X = 12,                      & ~~~~~~~~X = 12,           \\
~~~~~~~~g\_read(b, B).               & ~~~~~~~~g\_read(b, B).    \\
\end{tabular}
\end{Code}

The query \texttt{test(B)} will succeed unifying \texttt{B} with
\texttt{f(\_)} (\texttt{g\_assign/2} assigns a copy of the value). The query
\texttt{test(B)} will succeed unifying \texttt{B} with \texttt{f(12)}
(\texttt{g\_link/2} assigns a pointer to the term).

\SPart{Simple array definition}: here are some queries to show how arrays
can be handled:

\begin{Indentation}
\begin{verbatim}
| ?- g_assign(w, g_array(3)), g_read(w, X).

X = g_array([0,0,0])

| ?- g_assign(w(0), 16), g_assign(w(1), 32), g_assign(w(2), 64), g_read(w, X).

X = g_array([16,32,64])
\end{verbatim}
\end{Indentation}

this is equivalent to:

\begin{Indentation}
\begin{verbatim}
| ?- g_assign(k, g_array([16,32,64])), g_read(k, X).

X = g_array([16,32,64])

| ?- g_assign(k, g_array(3,null)), g_read(k, X), g_array_size(k, S).

S = 3
X = g_array([null,null,null])
\end{verbatim}
\end{Indentation}

\SPart{2-D array definition}:

\begin{Indentation}
\begin{verbatim}
| ?- g_assign(w, g_array(2, g_array(3))), g_read(w, X).

X = g_array([g_array([0,0,0]),g_array([0,0,0])])

| ?- (   for(I,0,1), for(J,0,2), K is I*3+J, g_assign(w(I,J), K),
         fail
     ;   g_read(w, X)
     ).

X = g_array([g_array([0,1,2]),g_array([3,4,5])])

| ?- g_read(w(1),X).

X = g_array([3,4,5])
\end{verbatim}
\end{Indentation}

\SPart{Hybrid array}:

\begin{Indentation}
\begin{verbatim}
| ?- g_assign(w,g_array([1,2,g_array([a,b,c]), g_array(2,z),5])), g_read(w, X).

X = g_array([1,2,g_array([a,b,c]), g_array([z,z]),5])

| ?- g_read(w(1), X), g_read(w(2,1), Y), g_read(w(3,1), Z).

X = 2
Y = b
Z = z

| ?- g_read(w(1,2),X).
uncaught exception: error(domain_error(g_array_index,w(1,2)),g_read/2)
\end{verbatim}
\end{Indentation}

\SPart{Array extension}:

\begin{Indentation}
\begin{verbatim}
| ?- g_assign(a, g_array([10,20,30])), g_read(a, X).

X = g_array([10,20,30])

| ?- g_assign(a, g_array_extend(5,null)), g_read(a, X).

X = g_array([10,20,30,null,null])

| ?- g_assign(a, g_array([10,20,30])), g_read(a, X).

X = g_array([10,20,30])

| ?- g_assign(a, g_array_extend([1,2,3,4,5,6])), g_read(a, X).

X = g_array([10,20,30,4,5,6])
\end{verbatim}
\end{Indentation}

\SPart{Automatic array}:

\begin{Indentation}
\begin{verbatim}
| ?- g_assign(t, g_array_auto(3)), g_assign(t(1), foo), g_read(t,X).

X = g_array([0,foo,0])

| ?- g_assign(t(5), bar), g_read(t,X).

X = g_array([0,foo,0,0,0,bar,0,0])

| ?- g_assign(t, g_array_auto(2, g_array(2))), g_assign(t(1,1), foo),
     g_read(t,X).

X = g_array([g_array([0,0]),g_array([0,foo])])

| ?- g_assign(t(3,0), bar), g_read(t,X).

X = g_array([g_array([0,0]),g_array([0,foo]),g_array([0,0]),g_array([bar,0])])

| ?- g_assign(t(3,4), bar), g_read(t,X).
uncaught exception: error(domain_error(g_array_index,t(3,4)),g_assign/2)

| ?- g_assign(t, g_array_auto(2, g_array_auto(2))), g_assign(t(1,1), foo),
     g_read(t,X).

X = g_array([g_array([0,0]),g_array([0,foo])])

| ?- g_assign(t(3,3), bar), g_read(t,X).

X = g_array([g_array([0,0]),g_array([0,foo]),g_array([0,0]),
    g_array([0,0,0,bar])])

| ?- g_assign(t, g_array_auto(2, g_array_auto(2, null))), g_read(t(2,3), U),
     g_read(t, X).

U = null
X = g_array([g_array([null,null]),g_array([null,null]),
             g_array([null,null,null,null]),g_array([null,null])])
\end{verbatim}
\end{Indentation}

\subsection{Prolog state}

\subsubsection{\IdxPBD{set\_prolog\_flag/2}\label{set-prolog-flag/2}}

\begin{TemplatesOneCol}
set\_prolog\_flag(+flag, +term)

\end{TemplatesOneCol}

\Description

\texttt{set\_prolog\_flag(Flag, Value)} sets the value
of the \IdxD{Prolog flag} \texttt{Flag} to \texttt{Value}.

\index{flag|see {Prolog flag}}
\SPart{Prolog flags}: a Prolog flag is an atom
which is associated with a value that is either implementation defined
or defined by the user. Each flag has a permitted range of values; any
other value is a \texttt{domain\_error}. The following two tables
present available flags, the possible values, a description and if
they are ISO or an extension. The first table presents unchangeable
flags while the second one the changeable flags. For flags whose
default values is machine independent, this value is
\underline{underlined}.

\SPart{Unchangeable flags}:

\begin{tabular}{|L{4.5cm}|C{2.2cm}|L{6.5cm}|C{0,6cm}|}
\hline

Flag & Values & Description & ISO \\

\hline\hline

\IdxPFD{prolog\_name} & an atom &  name of the Prolog system & N \\

\hline

\IdxPFD{prolog\_version} & an atom & version number of the Prolog system & N \\

\hline

\IdxPFD{prolog\_date} & an atom & date of the Prolog system & N \\

\hline

\IdxPFD{prolog\_copyright} & an atom &  copyright message of the Prolog system & N \\

\hline

\IdxPFD{dialect} & an atom & fixed to \texttt{gprolog} & N \\

\hline

\IdxPFD{version} & an integer & $Major * 10000 + Minor * 100 + Patch$ & N \\

\hline

\IdxPFD{version\_data} & a structure & \texttt{gprolog(Major,Minor,Patch,Extra)} & N \\

\hline

\IdxPFD{bounded} & \texttt{\underline{true}} / \texttt{false} & are integers bounded ? & Y \\

\hline

\IdxPFD{max\_integer} & an integer & greatest integer & Y \\

\hline

\IdxPFD{min\_integer} & an integer & smallest integer & Y \\

\hline

\IdxPFD{integer\_rounding\_function} & \texttt{toward\_zero}
\linebreak
                                       \texttt{down} &
   \texttt{\textit{rnd}(X)} = integer part of \texttt{X}
   \linebreak
   \texttt{\textit{rnd}(X)} = $\lfloor$\texttt{X$\rfloor$}
   \RefSP{Evaluation-of-an-arithmetic-expression} & Y \\

\hline

\IdxPFD{max\_arity} & an integer & maximum arity for compound terms (255) & Y \\

\hline

\IdxPFD{max\_atom} & an integer & maximum number of atoms & N \\

\hline

\IdxPFD{max\_unget} & an integer & maximum number of successive ungets & N \\

\hline

\IdxPFD{home} & an atom & GNU Prolog home directory & N \\

\hline

\IdxPFD{host\_os} & an atom & Operating System identifier & N \\

\hline

\IdxPFD{host\_vendor} & an atom & Operating System vendor & N \\

\hline

\IdxPFD{host\_cpu} & an atom & processor identifier & N \\

\hline

\IdxPFD{host} & an atom & a combination of the OS-vendor-cpu & N \\

\hline

\IdxPFD{arch} & an atom & a combination of the OS-cpu & N \\

\hline

\IdxPFD{address\_bits} & an integer & address size of the machine (32 or 64) & N \\

\hline

\IdxPFD{unix} & \texttt{on}/\texttt{off} & is the architecture an Unix-like OS ? & N \\

\hline

\IdxPFD{compiled\_at} & an atom & compilation date using \texttt{\_\_DATE\_\_} and \texttt{\_\_TIME\_\_} C compiler macros & N \\

\hline

\IdxPFD{c\_cc} & an atom & C compiler used to compile GNU Prolog (\texttt{gcc}, \texttt{cc}, \texttt{clang}, \texttt{cl},...) & N \\

\hline

\IdxPFD{c\_cc\_version\_data} &  a structure & \texttt{\textit{c\_cc}(Major,Minor,Patch,Extra)} & N \\

\hline

\IdxPFD{c\_cflags} & an atom & \texttt{CFLAGS} used to compile GNU Prolog & N \\

\hline

\IdxPFD{c\_ldflags} & an atom & \texttt{LDFLAGS} used to compile GNU Prolog & N \\

\hline

\IdxPFD{argv} & a list of atoms & list of command-line arguments & N \\

\hline
\end{tabular}

\SPart{Changeable flags}:

\begin{tabular}{|L{4.5cm}|C{2.8cm}|L{6.2cm}|C{0,6cm}|}
\hline

Flag & Values & Description & ISO \\

\hline\hline

\IdxPFD{char\_conversion} & \texttt{on} / \texttt{\underline{off}} & is
character conversion activated ? & Y \\

\hline

\IdxPFD{singleton\_warning} & \texttt{\underline{on}} / \texttt{off} & warn about named singleton variables ? & N \\

\hline

\IdxPFD{suspicious\_warning} & \texttt{\underline{on}} / \texttt{off} & warn about suspicious predicate ? & N \\

\hline

\IdxPFD{multifile\_warning} & \texttt{\underline{on}} / \texttt{off} & warn about unsupported multifile directive ? & N \\

\hline

\IdxPFD{strict\_iso} & \texttt{\underline{on}} / \texttt{off} & strict ISO behavior ? & N \\

\hline

\IdxPFD{debug} & \texttt{on} / \texttt{\underline{off}} & is the debugger activated ? & Y \\

\hline

~
\linebreak
\IdxPFD{double\_quotes} &
  ~
\linebreak
  \texttt{atom}
\linebreak
  \texttt{chars}
\linebreak
  \texttt{\underline{codes}}
\linebreak
  \texttt{atom\_no\_escape}
\linebreak
  \texttt{chars\_no\_escape}
\linebreak
  \texttt{codes\_no\_escape} &
    a double quoted constant is returned as:
\linebreak
    an atom
\linebreak
    a list of characters
\linebreak
    a list of character codes
\linebreak
    as \texttt{atom} but ignore \IdxD{escape sequence}s
\linebreak
    as \texttt{chars} but ignore escape sequences
\linebreak
    as \texttt{code} but ignore escape sequences &
      ~
\linebreak
      Y
\linebreak
    ~
\linebreak
    ~
\linebreak
      N
 \\

\hline

~
\linebreak
\IdxPFD{back\_quotes} &
  ~
\linebreak
  \texttt{atom}
\linebreak
  \texttt{chars}
\linebreak
  \texttt{codes}
\linebreak
  \texttt{\underline{atom\_no\_escape}}
\linebreak
  \texttt{chars\_no\_escape}
\linebreak
  \texttt{codes\_no\_escape} &
    a back quoted constant is returned as:
\linebreak
    an atom
\linebreak
    a list of characters
\linebreak
    a list of character codes
\linebreak
    as \texttt{atom} but ignore escape sequences
\linebreak
    as \texttt{chars} but ignore escape sequences
\linebreak
    as \texttt{code} but ignore escape sequences &
      ~
\linebreak
      N
 \\
\hline

~
\linebreak
\IdxPFD{unknown} &
  ~
\linebreak
  \texttt{\underline{error}}
\linebreak
  \texttt{warning}
\linebreak
  \texttt{fail} &
    a predicate calls an unknown procedure:
\linebreak
    an \texttt{existence\_error} is raised
\linebreak
    a message is displayed then fails
\linebreak
    quietly fails &
      ~
\linebreak
      Y \\

\hline

~
\linebreak
\IdxPFD{syntax\_error} &
  ~
\linebreak
  \texttt{\underline{error}}
\linebreak
  \texttt{warning}
\linebreak
  \texttt{fail} &
    a predicate causes a syntax error:
\linebreak
    a \texttt{syntax\_error} is raised
\linebreak
    a message is displayed then fails
\linebreak
    quietly fails &
      ~
\linebreak
      N \\

\hline

~
\linebreak
\IdxPFD{os\_error} &
  ~
\linebreak
  \texttt{\underline{error}}
\linebreak
  \texttt{warning}
\linebreak
  \texttt{fail} &
    a predicate causes an O.S. error:
\linebreak
    a \texttt{system\_error} is raised
\linebreak
    a message is displayed then fails
\linebreak
    quietly fails &
      ~
\linebreak
      N \\

\hline
\end{tabular}

The \texttt{strict\_iso} flag is introduced to allow a compatibility with
other Prolog systems. When turned off the following relaxations apply:

\begin{itemize}

\item built-in predicates are found by \texttt{current\_predicate/1}
\RefSP{current-predicate/1}.

\item the term parser (\texttt{read/1} and friends) is more indulgent, e.g. \texttt{0''} is
  accepted and returns 39, the \Idx{escape sequence} \texttt{{\bs}s} (space) and
  \texttt{{\bs}e} (escape) are accepted.

\item the following arithmetic rounding functions: \texttt{ceiling}, \texttt{floor}, \texttt{round}, \texttt{truncate} also accept integers \RefSP{Evaluation-of-an-arithmetic-expression}.

\end{itemize}

\begin{PlErrors}

\ErrCond{\texttt{Flag} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Value} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Flag} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Flag)}

\ErrCond{\texttt{Flag} is an atom but not a valid flag}
\ErrTerm{domain\_error(prolog\_flag, Flag)}

\ErrCond{\texttt{Value} is inappropriate for Flag}
\ErrTerm{domain\_error(flag\_value, Flag+Value)}

\ErrCond{\texttt{Value} is appropriate for \texttt{Flag} but flag
\texttt{Flag} is not modifiable}
\ErrTerm{permission\_error(modify, flag, Flag)}

\end{PlErrors}

\Portability

ISO predicate. All ISO flags are implemented.

\subsubsection{\IdxPBD{current\_prolog\_flag/2}\label{current-prolog-flag/2}}

\begin{TemplatesOneCol}
current\_prolog\_flag(?flag, ?term)

\end{TemplatesOneCol}

\Description

\texttt{current\_prolog\_flag(Flag, Value)}
succeeds if there exists a \Idx{Prolog flag} that unifies with
\texttt{Flag} and whose value unifies with \texttt{Value}. This predicate
is re-executable on backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Flag} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Flag)}

\ErrCond{\texttt{Flag} is an atom but not a valid flag}
\ErrTerm{domain\_error(prolog\_flag, Flag)}

\end{PlErrors}

\Portability

ISO predicate.

\subsubsection{\IdxPBD{set\_bip\_name/2}\label{set-bip-name/2}}

\begin{TemplatesOneCol}
set\_bip\_name(+atom, +arity)

\end{TemplatesOneCol}

\Description

\texttt{set\_bip\_name(Functor, Arity)} initializes the context of the error
\RefSP{General-format-and-error-context} with \texttt{Functor} and
\texttt{Arity} (if \texttt{Arity} $<$ 0 only \texttt{Functor} is
significant).

\begin{PlErrors}

\ErrCond{\texttt{Functor} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Arity} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Functor} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Functor)}

\ErrCond{\texttt{Arity} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Arity)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{current\_bip\_name/2}\label{current-bip-name/2}}

\begin{TemplatesOneCol}
current\_bip\_name(?atom, ?arity)

\end{TemplatesOneCol}

\Description

\texttt{current\_bip\_name(Functor, Arity)} succeeds if \texttt{Functor} and
\texttt{Arity} correspond to the context of the error \RefSP{General-format-and-error-context} (if \texttt{Arity} $<$ 0 only \texttt{Functor} is
significant).

\begin{PlErrors}

\ErrCond{\texttt{Functor} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Functor)}

\ErrCond{\texttt{Arity} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Arity)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{write\_pl\_state\_file/1},\label{write-pl-state-file/1}
               \IdxPBD{read\_pl\_state\_file/1}}

\begin{TemplatesOneCol}
write\_pl\_state\_file(+source\_sink)\\
read\_pl\_state\_file(+source\_sink)

\end{TemplatesOneCol}

\Description

\texttt{write\_pl\_state\_file(FileName)} writes onto \texttt{FileName} all
information that influences the parsing of a term \RefSP{Term-input/output}. This allows a sub-process written in Prolog to read this
file and then process any Prolog term as done by the parent process. This
file can also be passed as argument of the \IdxK{--pl-state} option when
invoking \IdxK{gplc} \RefSP{Using-the-compiler}. More precisely the
following elements are saved:

\begin{itemize}

\item all operator definitions \RefSP{op/3:(Term-input/output)}.

\item the character conversion table \RefSP{char-conversion/2}.

\item the value of \IdxPF{char\_conversion}, \IdxPF{double\_quotes}, \IdxPF{back\_quotes}, \IdxPF{singleton\_warning}, \IdxPF{suspicious\_warning} and \IdxPF{multifile\_warning} \Idx{Prolog flag}s
\RefSP{set-prolog-flag/2}.

\end{itemize}

\texttt{read\_pl\_state\_file(FileName)} reads (restores) from
\texttt{FileName} all information previously saved by
\texttt{write\_pl\_state\_file/1.}

\begin{PlErrors}

\ErrCond{\texttt{FileName} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{FileName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, FileName)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{Program state}

\subsubsection{\IdxPBD{consult/1},\label{consult/1}
               \IdxPBD{'.'/2} - program consult}

\begin{TemplatesOneCol}
consult(+atom\_or\_atom\_list)\\
'.'(+atom, +atom\_list)

\end{TemplatesOneCol}

\Description

\texttt{consult(Files)} compiles and loads into memory each file
of the list \texttt{Files}. Each file is compiled for byte-code using the
GNU Prolog compiler \RefSP{The-GNU-Prolog-compiler} then loaded using
\texttt{load/1} \RefSP{load/1}. It is possible to specify \IdxPK{user} as a
file name to directly enter the program from the terminal. \texttt{Files} can
be also a single file name (i.e. an atom). Refer to the section concerning
the consult of a Prolog program for more information
\RefSP{Consulting-a-Prolog-program}.

The final file name of a file is computed using the predicates
\IdxPB{prolog\_file\_name/2} \RefSP{prolog-file-name/2} and
\IdxPB{absolute\_file\_name/2} \RefSP{absolute-file-name/2}.

\texttt{[ File | Files ]}, i.e. \texttt{'.'(File, Files)} is
equivalent to \texttt{consult([ File | Files ])}.

Since version 1.4.0, with the introduction of \Idx{shebang support},
\texttt{consult/1} ignores the first line of a Prolog source file which
directly begins with \texttt{\#}. See
\RefSP{Scripting-Prolog} for more information about
shebang support and \Idx{PrologScript}.

\begin{PlErrors}

\ErrCond{\texttt{Files} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Files} is neither a partial list nor a list nor an atom}
\ErrTerm{type\_error(list, Files)}

\ErrCond{an element \texttt{E} of the \texttt{Files} list is neither a
variable nor an atom}
\ErrTerm{type\_error(atom, E)}

\ErrCond{an element \texttt{E} of the \texttt{Files} list is an atom but not
a valid pathname}
\ErrTerm{domain\_error(os\_path, E)}

\ErrCond{an element \texttt{E} of the \texttt{Files} list is a valid
pathname but does not correspond to an existing source}
\ErrTerm{existence\_error(source\_sink, E)}

\ErrCond{an error occurs executing a directive}
\ErrTermRm{see \texttt{call/1} errors \RefSP{call/1}}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{load/1}\label{load/1}}

\begin{TemplatesOneCol}
load(+atom\_or\_atom\_list)

\end{TemplatesOneCol}

\Description

\texttt{load(Files)} loads into memory each file of the list
\texttt{Files}. Each file must have been previously compiled for byte-code
using the GNU Prolog compiler \RefSP{The-GNU-Prolog-compiler}.
\texttt{Files} can be also a single file name (i.e. an atom).

The final file name of a file is computed using the predicates
\IdxPB{absolute\_file\_name/2} \RefSP{absolute-file-name/2}. If no
suffix is given \texttt{'.wbc'} is appended to the file name.

\begin{PlErrors}

\ErrCond{\texttt{Files} is a partial list or a list with an element
\texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Files} is neither a partial list nor a list nor an atom}
\ErrTerm{type\_error(list, Files)}

\ErrCond{an element \texttt{E} of the \texttt{Files} list is neither a
variable nor an atom}
\ErrTerm{type\_error(atom, E)}

\ErrCond{an element \texttt{E} of the \texttt{Files} list is an atom but not
a valid pathname}
\ErrTerm{domain\_error(os\_path, E)}

\ErrCond{an element \texttt{E} of the \texttt{Files} list is a valid
pathname but does not correspond to an existing source}
\ErrTerm{existence\_error(source\_sink, E)}

\ErrCond{an error occurs executing a directive}
\ErrTermRm{see \texttt{call/1} errors \RefSP{call/1}}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{listing/1},\label{listing/1}
               \IdxPBD{listing/0}}

\begin{TemplatesOneCol}
listing(+predicate\_indicator)\\
listing(+atom)\\
listing

\end{TemplatesOneCol}

\Description

\texttt{listing(Pred)} lists the clauses of the consulted predicate whose
predicate indicator is \texttt{Pred}. \texttt{Pred} can also be a single
atom in which case all predicates whose name is \texttt{Pred} are listed (of
any arity). This predicate uses \IdxPB{portray\_clause/2}
\RefSP{portray-clause/2} to output the clauses.

\texttt{listing} lists all clauses of all consulted predicates.

\begin{PlErrors}

\ErrCond{\texttt{Pred} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Pred} is neither a variable nor predicate indicator or an
atom}
\ErrTerm{type\_error(predicate\_indicator, Pred)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{System statistics}

\subsubsection{\IdxPBD{statistics/0},\label{statistics/2}
               \IdxPBD{statistics/2}}

\begin{TemplatesOneCol}
statistics\\
statistics(?atom, ?list)

\end{TemplatesOneCol}

\Description

\texttt{statistics} displays statistics about memory usage and run times.

\texttt{statistics(Key, Value)} unifies \texttt{Value} with the current
value of the statistics key \texttt{Key}. \texttt{Value} a list of two
elements. Times are in milliseconds, sizes of areas in bytes.

\begin{tabular}{|l|l|l|}
\hline

Key & Description & Value \\

\hline\hline

\texttt{user\_time} & user CPU time & \texttt{[SinceStart, SinceLast]} \\

\hline

\texttt{system\_time} & system CPU time & \texttt{[SinceStart, SinceLast]}
\\

\hline

\texttt{cpu\_time} & total CPU time (user + system) & \texttt{[SinceStart,
SinceLast]} \\

\hline

\texttt{real\_time} & absolute time & \texttt{[SinceStart, SinceLast]} \\

\hline

\texttt{local\_stack} & local stack sizes (control, environments, choices) & \texttt{[UsedSize, FreeSize]} \\

\hline

\texttt{global\_stack} & global stack sizes (compound terms) &
\texttt{[UsedSize, FreeSize]} \\

\hline

\texttt{trail\_stack} & trail stack sizes (variable bindings to undo) &
\texttt{[UsedSize, FreeSize]} \\

\hline

\texttt{cstr\_stack} & constraint trail sizes (finite domain constraints) &
\texttt{[UsedSize, FreeSize]} \\

\hline

\texttt{atoms} & atom table &
\texttt{[NumberOfAtoms, FreeNumberOfAtoms]} \\

\hline
\end{tabular}

Note that the key \texttt{runtime} is recognized as \texttt{user\_time} for
compatibility purpose.


\begin{PlErrors}

\ErrCond{\texttt{Key} is neither a variable nor a valid key}
\ErrTerm{domain\_error(statistics\_key, Key)}

\ErrCond{\texttt{Value} is neither a variable nor a list of two elements}
\ErrTerm{domain\_error(statistics\_value, Value)}

\ErrCond{\texttt{Value} is a list of two elements and an element \texttt{E}
is neither a variable nor an integer}
\ErrTerm{type\_error(integer, E)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{user\_time/1},\label{user-time/1}
               \IdxPBD{system\_time/1},
               \IdxPBD{cpu\_time/1},
               \IdxPBD{real\_time/1}}

\begin{TemplatesOneCol}
user\_time(?integer)\\
system\_time(?integer)\\
cpu\_time(?integer)\\
real\_time(?integer)

\end{TemplatesOneCol}

\Description

\texttt{user\_time(Time)} unifies \texttt{Time} with the user
CPU time elapsed since the start of Prolog.

\texttt{system\_time(Time)} unifies \texttt{Time} with the
system CPU time elapsed since the start of Prolog.

\texttt{cpu\_time(Time)} unifies \texttt{Time} with the CPU
time (user + system) elapsed since the start of Prolog.

\texttt{real\_time(Time)} unifies \texttt{Time} with the
absolute time elapsed since the start of Prolog.

\begin{PlErrors}

\ErrCond{\texttt{Time} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Time)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsection{Random number generator}

\subsubsection{\IdxPBD{set\_seed/1},
               \IdxPBD{randomize/0}}

\begin{TemplatesOneCol}
set\_seed(+integer)\\
randomize

\end{TemplatesOneCol}

\Description

\texttt{set\_seed(Seed)} reinitializes the random number generator seed with
\texttt{Seed}.

\texttt{randomize} reinitializes the random number generator. This
predicates calls \texttt{set\_seed/1} with a random value depending on the
absolute time.

\begin{PlErrors}

\ErrCond{\texttt{Seed} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Seed} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Seed)}

\ErrCond{\texttt{Seed} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Seed)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{get\_seed/1}}

\begin{TemplatesOneCol}
get\_seed(?integer)

\end{TemplatesOneCol}

\Description

\texttt{get\_seed(Seed)} unifies \texttt{Seed} with the current random
number generator seed.

\begin{PlErrors}

\ErrCond{\texttt{Seed} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Seed)}

\ErrCond{\texttt{Seed} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Seed)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{random/1}}

\begin{TemplatesOneCol}
random(-float)

\end{TemplatesOneCol}

\Description

\texttt{random(Number)} unifies \texttt{Number} with a random floating point
number such that 0.0 $\leq$ \texttt{Number} $<$ 1.0.

\begin{PlErrors}

\ErrCond{\texttt{Number} is not a variable}
\ErrTerm{uninstantiation\_error(Number)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{random/3}}

\begin{TemplatesOneCol}
random(+number, +number, -number)

\end{TemplatesOneCol}

\Description

\texttt{random(Base, Max, Number)} unifies \texttt{Number} with a random
number such that \texttt{Base} $\leq$ \texttt{Number} $<$ \texttt{Max}. If
both \texttt{Base} and \texttt{Max} are integers \texttt{Number} will be an
integer, otherwise \texttt{Number} will be a floating point number.

\begin{PlErrors}

\ErrCond{\texttt{Base} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Base} is neither a variable nor a number}
\ErrTerm{type\_error(number, Base)}

\ErrCond{\texttt{Max} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Max} is neither a variable nor a number}
\ErrTerm{type\_error(number, Max)}

\ErrCond{\texttt{Number} is not a variable}
\ErrTerm{uninstantiation\_error(Number)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{File name processing}

\subsubsection{\IdxPBD{absolute\_file\_name/2}\label{absolute-file-name/2}}

\begin{TemplatesOneCol}
absolute\_file\_name(+atom, atom)

\end{TemplatesOneCol}

\Description

\texttt{absolute\_file\_name(File1, File2)} succeeds if \texttt{File2} is
the absolute pathname associated with the relative file name \texttt{File1}.
\texttt{File1} can contain \texttt{\$\Param{VAR\_NAME}} sub-strings. When
such a sub-string is encountered, it is expanded with the value of the
environment variable whose name is \Param{VAR\_NAME} if exists
(otherwise no expansion is done). \texttt{File1} can also begin with a
sub-string \texttt{\~{}\Param{USER\_NAME}/}, this is expanded as the home
directory of the user \Param{USER\_NAME}. If
\Param{USER\_NAME} does not exist \texttt{File1} is an invalid
pathname. If no \Param{USER\_NAME} is given (i.e. \texttt{File1}
begins with \texttt{\~{}/}) the \texttt{\~{}} character is expanded as the
value of the environment variable \texttt{HOME}. If the \texttt{HOME}
variable is not defined \texttt{File1} is an invalid pathname. Relative
references to the current directory (\texttt{/./} sub-string) and to the
parent directory (\texttt{/../} sub-strings) are removed and no longer
appear in \texttt{File2}. \texttt{File1} is also invalid if it contains too
many \texttt{/../} consecutive sub-strings (i.e. parent directory relative
references). Finally if \texttt{File1} is \IdxPK{user} then \texttt{File2}
is also unified with \texttt{user} to allow this predicate to be called on
Prolog file names (since \texttt{user} in DEC-10 input/output predicates
denotes the current input/output stream).

Under Windows the following applies: 
\begin{itemize}
\item an alternate recognized form for \texttt{\$\Param{VAR\_NAME}} is
  \texttt{\%\Param{VAR\_NAME}\%}. 

\item when \texttt{\~{}} is expanded, if the \texttt{HOME} variable is not defined, \texttt{\~{}} is expanded using \texttt{HOMEDIR} and
  \texttt{HOMEPATH} (if \texttt{HOMEPATH} is not defined then \texttt{File1}
  is an invalid pathname).
\end{itemize}

Most predicates using a file name implicitly call this predicate to obtain
the desired file, e.g. \texttt{open/4}.

\begin{PlErrors}

\ErrCond{\texttt{File1} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{File1} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, File1)}

\ErrCond{\texttt{File2} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, File2)}

\ErrCond{\texttt{File1} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, File1)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{is\_absolute\_file\_name/1},
               \IdxPBD{is\_relative\_file\_name/1}}

\begin{TemplatesOneCol}
is\_absolute\_file\_name(+atom)\\
is\_relative\_file\_name(+atom)

\end{TemplatesOneCol}

\Description

\texttt{is\_absolute\_file\_name(PathName)} succeeds if \texttt{PathName} is
an absolute file name. 

Conversely, \texttt{is\_relative\_file\_name(PathName)} succeeds if
\texttt{PathName} is not an absolute file name.

See \IdxPB{absolute\_file\_name/2} for information about the syntax of
\texttt{PathName} \RefSP{absolute-file-name/2}.

The current implementation does not check the validity of
\texttt{PathName}. If \texttt{PathName} starts with a \texttt{/} (slash) it
is considered as absolute. Under Windows, \texttt{PathName} can also start
with a \texttt{{\bs}} (backslash) or a drive specification.

\begin{PlErrors}

\ErrCond{\texttt{PathName} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{PathName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{decompose\_file\_name/4}}

\begin{TemplatesOneCol}
decompose\_file\_name(+atom, ?atom, ?atom, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{decompose\_file\_name(File, Directory, Prefix, Suffix)} decomposes
the pathname \texttt{File} and extracts the \texttt{Directory} part
(characters before the last \texttt{/}), the \texttt{Prefix} part
(characters after the last \texttt{/} and before the last \texttt{.} or
until the end if there is no suffix) and the \texttt{Suffix} part
(characters from the last \texttt{.} to the end of the string).

\begin{PlErrors}

\ErrCond{\texttt{File} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{File} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, File)}

\ErrCond{\texttt{Directory} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Directory)}

\ErrCond{\texttt{Prefix} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Prefix)}

\ErrCond{\texttt{Suffix} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Suffix)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{prolog\_file\_name/2}\label{prolog-file-name/2}}

\begin{TemplatesOneCol}
prolog\_file\_name(+atom, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{prolog\_file\_name(File1, File2)} unifies \texttt{File2} with the
Prolog file name associated with \texttt{File1}. More precisely \texttt{File2}
is computed as follows:

\begin{itemize}

\item if \texttt{File1} has a suffix or if it is \IdxPK{user} then
\texttt{File2} is unified with \texttt{File1}.

\item else if the file whose name is \texttt{File1} + \texttt{'.pl'} exists
then \texttt{File2} is unified with this name.

\item else if the file whose name is \texttt{File1} + \texttt{'.pro'} exists
then \texttt{File2} is unified with this name.

\item else \texttt{File2} is unified with the name \texttt{File1} +
\texttt{'.pl'}.

\end{itemize}

This predicate uses \IdxPB{absolute\_file\_name/2} to check the existence
of a file \RefSP{absolute-file-name/2}.

\begin{PlErrors}

\ErrCond{\texttt{File1} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{File1} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, File1)}

\ErrCond{\texttt{File2} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, File2)}

\ErrCond{\texttt{File1} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, File1)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{Operating system interface}

\subsubsection{\IdxPBD{argument\_counter/1}\label{argument-counter/1}}

\begin{TemplatesOneCol}
argument\_counter(?integer)

\end{TemplatesOneCol}

\Description

\texttt{argument\_counter(Counter)} succeeds if \texttt{Counter} is the
number of arguments of the command-line. Since the first argument is always
the name of the running program, \texttt{Counter} is always $\geq$ 1. See
\RefSP{The-GNU-Prolog-interactive-interpreter} for more information about
command-line arguments retrieved under the top\_level.


\begin{PlErrors}

\ErrCond{\texttt{Counter} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Counter)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{argument\_value/2}\label{argument-value/2}}

\begin{TemplatesOneCol}
argument\_value(+integer, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{argument\_value(N, Arg)} succeeds if the \texttt{N}\emph{th}
argument on the command-line unifies with \texttt{Arg}. The first argument
is always the name of the running program and its number is 0. The number of
arguments on the command-line can be obtained using
\texttt{argument\_counter/1} \RefSP{argument-counter/1}.

\begin{PlErrors}

\ErrCond{\texttt{N} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{N} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, N)}

\ErrCond{\texttt{N} is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, N)}

\ErrCond{\texttt{Arg} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Arg)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{argument\_list/1}\label{argument-list/1}}

\begin{TemplatesOneCol}
argument\_list(?list)

\end{TemplatesOneCol}

\Description

\texttt{argument\_list(Args)} succeeds if \texttt{Args} unifies with the
list of atoms associated with each argument on the command-line other than the
first argument (the name of the running program).

\begin{PlErrors}

\ErrCond{\texttt{Args} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Args)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{environ/2}}

\begin{TemplatesOneCol}
environ(?atom, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{environ(Name, Value)} succeeds if \texttt{Name} is the name of an
environment variable whose value is \texttt{Value}. This predicate is
re-executable on backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Name} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Name)}

\ErrCond{\texttt{Value} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Value)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{make\_directory/1},
               \IdxPBD{delete\_directory/1},
               \IdxPBD{change\_directory/1}}

\begin{TemplatesOneCol}
make\_directory(+atom)\\
delete\_directory(+atom)\\
change\_directory(+atom)

\end{TemplatesOneCol}

\Description

\texttt{make\_directory(PathName)} creates the directory whose pathname is
\texttt{PathName}.

\texttt{delete\_directory(PathName)} removes the directory whose pathname is
\texttt{PathName}.

\texttt{change\_directory(PathName)} sets the current directory to the
directory whose pathname is \texttt{PathName}.

See \IdxPB{absolute\_file\_name/2} for information about the syntax of
\texttt{PathName} \RefSP{absolute-file-name/2}.

\begin{PlErrors}

\ErrCond{\texttt{PathName} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{PathName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName)}

\ErrCond{\texttt{PathName} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, PathName)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{working\_directory/1}}

\begin{TemplatesOneCol}
working\_directory(?atom)

\end{TemplatesOneCol}

\Description

\texttt{working\_directory(PathName)} succeeds if \texttt{PathName} is the
pathname of the current directory.

\begin{PlErrors}

\ErrCond{\texttt{PathName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{directory\_files/2}}

\begin{TemplatesOneCol}
directory\_files(+atom, ?list)

\end{TemplatesOneCol}

\Description

\texttt{directory\_files(PathName, Files)} succeeds if \texttt{Files} is the
list of all entries (files, sub-directories,\ldots) in the directory whose
pathname is \texttt{PathName}. See \IdxPB{absolute\_file\_name/2} for
information about the syntax of \texttt{PathName}
\RefSP{absolute-file-name/2}.

\begin{PlErrors}

\ErrCond{\texttt{PathName} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{PathName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName)}

\ErrCond{\texttt{PathName} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, PathName)}

\ErrCond{\texttt{Files} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Files)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{rename\_file/2}}

\begin{TemplatesOneCol}
rename\_file(+atom, +atom)

\end{TemplatesOneCol}

\Description

\texttt{rename\_file(PathName1, PathName2)} renames the file or directory
whose pathname is \texttt{PathName1} to \texttt{PathName2}. See
\IdxPB{absolute\_file\_name/2} for information about the syntax of
\texttt{PathName1} and \texttt{PathName2} \RefSP{absolute-file-name/2}.

\begin{PlErrors}

\ErrCond{\texttt{PathName1} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{PathName1} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName1)}

\ErrCond{\texttt{PathName1} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, PathName1)}

\ErrCond{\texttt{PathName2} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{PathName2} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName2)}

\ErrCond{\texttt{PathName2} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, PathName2)}

\ErrCond{an operating system error occurs and value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{delete\_file/1},
               \IdxPBD{unlink/1}}

\begin{TemplatesOneCol}
delete\_file(PathName)\\
unlink(PathName)

\end{TemplatesOneCol}

\Description

\texttt{delete\_file(PathName)} removes the existing file whose pathname is
\texttt{PathName}.

\texttt{unlink/1} is similar to \texttt{delete\_file/1} except that it never
causes a \texttt{system\_error} (e.g. if \texttt{PathName} does not refer to
an existing file).

See \IdxPB{absolute\_file\_name/2} for information about the syntax of
\texttt{PathName} \RefSP{absolute-file-name/2}.

\begin{PlErrors}

\ErrCond{\texttt{PathName} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{PathName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName)}

\ErrCond{\texttt{PathName} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, PathName)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{file\_permission/2},\label{file-permission/2}
               \IdxPBD{file\_exists/1}}

\begin{TemplatesOneCol}
file\_permission(+atom, +atom)\\
file\_permission(+atom, +atom\_list)\\
file\_exists(+atom)

\end{TemplatesOneCol}

\Description

\texttt{file\_permission(PathName, Permission)} succeeds if
\texttt{PathName} is the pathname of an existing file (or directory) whose
permissions include \texttt{Permission}.

\SPart{File permissions}: \texttt{Permission} can be a single permission or
a list of permissions. A permission is an atom among:

\begin{itemize}

\item \IdxPXD{read}: the file or directory can be read.

\item \IdxPXD{write}: the file or directory can be written.

\item \IdxPXD{execute}: the file can be executed.

\item \IdxPXD{search}: the directory can be searched.

\end{itemize}

If \texttt{PathName} does not exists or if its permissions do not include
\texttt{Permission} this predicate fails.

\texttt{file\_exists(PathName)} is equivalent to
\texttt{file\_permission(PathName, [])}, i.e. it succeeds if
\texttt{PathName} is the pathname of an existing file (or directory).

See \IdxPB{absolute\_file\_name/2} for information about the syntax of
\texttt{PathName} \RefSP{absolute-file-name/2}.

\begin{PlErrors}

\ErrCond{\texttt{PathName} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{PathName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName)}

\ErrCond{\texttt{PathName} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, PathName)}

\ErrCond{\texttt{Permission} is a partial list or a list with an element
which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Permission} is neither an atom nor partial list or a list}
\ErrTerm{type\_error(list, Permission)}

\ErrCond{an element \texttt{E} of the \texttt{Permission} list is neither a
variable nor an atom}
\ErrTerm{type\_error(atom, E)}

\ErrCond{an element \texttt{E} of the \texttt{Permission} is an atom but not
a valid permission}
\ErrTerm{domain\_error(os\_file\_permission, Permission)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{file\_property/2}\label{file-property/2}}

\begin{TemplatesOneCol}
file\_property(+atom, ?os\_file\_property)

\end{TemplatesOneCol}

\Description

\texttt{file\_property(PathName, Property)} succeeds if \texttt{PathName} is
the pathname of an existing file (or directory) and if \texttt{Property}
unifies with one of the properties of the file. This predicate is
re-executable on backtracking.

\SPart{File properties}:

\begin{itemize}

\item \AddPPD{absolute\_file\_name}\texttt{absolute\_file\_name(File)}:
\texttt{File} is the absolute file name of \texttt{PathName}
\RefSP{absolute-file-name/2}.

\item \AddPPD{real\_file\_name}\texttt{real\_file\_name(File)}: \texttt{File} is
the real file name of \texttt{PathName} (follows symbolic links).

\item \AddPPD{type}\texttt{type(Type)}: \texttt{Type} is the type of
  \texttt{PathName}. Possible values are: \IdxPXD{regular},
  \IdxPXD{directory}, \IdxPXD{fifo}, \IdxPXD{socket},
\IdxPXD{character\_device}, \IdxPXD{block\_device} or \IdxPXD{unknown}.

\item \AddPPD{size}\texttt{size(Size)}: \texttt{Size} is the size (in bytes) of
\texttt{PathName}.

\item \AddPPD{permission}\texttt{permission(Permission)}: \texttt{Permission} is a
permission of \texttt{PathName} \RefSP{file-permission/2}.

\item \AddPPD{last\_modification}\texttt{last\_modification(DT)}: \texttt{DT} is
the last modification date and time \RefSP{date-time/1}.

\end{itemize}

See \IdxPB{absolute\_file\_name/2} for information about the syntax of
\texttt{PathName} \RefSP{absolute-file-name/2}.

\begin{PlErrors}

\ErrCond{\texttt{PathName} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{PathName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName)}

\ErrCond{\texttt{PathName} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, PathName)}

\ErrCond{\texttt{Property} is neither a variable nor a file property term}
\ErrTerm{domain\_error(os\_file\_property, Property)}

\ErrCond{\texttt{Property} = \texttt{absolute\_file\_name(E)},
\texttt{real\_file\_name(E)}, \texttt{type(E)} or \texttt{permission(E)} and
\texttt{E} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, E)}

\ErrCond{\texttt{Property} = \texttt{last\_modification(DateTime)} and
\texttt{DateTime} is neither a variable nor a compound term}
\ErrTerm{type\_error(compound, DateTime)}

\ErrCond{\texttt{Property} = \texttt{last\_modification(DateTime)} and
\texttt{DateTime} is a compound term but not a structure \texttt{dt/6}}
\ErrTerm{domain\_error(date\_time, DateTime)}

\ErrCond{\texttt{Property} = \texttt{size(E)} or
\texttt{last\_modification(DateTime)} and \texttt{DateTime} is a structure
\texttt{dt/6} but an element \texttt{E} is neither a variable nor an
integer}
\ErrTerm{type\_error(integer, E)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{temporary\_name/2}}

\begin{TemplatesOneCol}
temporary\_name(+atom, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{temporary\_name(Template, PathName)} creates a unique file name
\texttt{PathName} whose pathname begins by \texttt{Template}.
\texttt{Template} should contain a pathname with six trailing
\texttt{X}\emph{s}. \texttt{PathName} is \texttt{Template} with the six
\texttt{X}\emph{s} replaced with a letter and the process identifier. This
predicate is an interface to the C Unix function \texttt{mktemp(3)}.

See \IdxPB{absolute\_file\_name/2} for information about the syntax of
\texttt{Template} \RefSP{absolute-file-name/2}.

\begin{PlErrors}

\ErrCond{\texttt{Template} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Template} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Template)}

\ErrCond{\texttt{Template} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, Template)}

\ErrCond{\texttt{PathName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{temporary\_file/3}}

\begin{TemplatesOneCol}
temporary\_file(+atom, +atom, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{temporary\_file(Directory, Prefix, PathName)} creates a unique file
name \texttt{PathName} whose pathname begins by \texttt{Directory/Prefix}.
If \texttt{Directory} is the empty atom \texttt{''} a standard temporary
directory will be used (e.g. \texttt{/tmp}). \texttt{Prefix} can be the
empty atom \texttt{''}. This predicate is an interface to the C Unix
function \texttt{tempnam(3)}.

See \IdxPB{absolute\_file\_name/2} for information about the syntax of
\texttt{Directory} \RefSP{absolute-file-name/2}.

\begin{PlErrors}

\ErrCond{\texttt{Directory} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Directory} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Directory)}

\ErrCond{\texttt{Directory} is an atom but not a valid pathname}
\ErrTerm{domain\_error(os\_path, Directory)}

\ErrCond{\texttt{Prefix} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Prefix} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Prefix)}

\ErrCond{\texttt{PathName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, PathName)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{date\_time/1}\label{date-time/1}}

\begin{TemplatesOneCol}
date\_time(?compound)

\end{TemplatesOneCol}

\Description

\texttt{date\_time(DateTime)} unifies \texttt{DateTime} with a compound term
containing the current date and time. \texttt{DateTime} is a structure
\texttt{dt(Year, Month, Day, Hour, Minute, Second)}. Each sub-argument of
the term \texttt{dt/6} is an integer.

\begin{PlErrors}

\ErrCond{\texttt{DateTime} is neither a variable nor a compound term}
\ErrTerm{type\_error(compound, DateTime)}

\ErrCond{\texttt{DateTime} is a compound term but not a structure
\texttt{dt/6}}
\ErrTerm{domain\_error(date\_time, DateTime)}

\ErrCond{\texttt{DateTime} is a structure \texttt{dt/6} and an element
\texttt{E} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, E)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{host\_name/1}}

\begin{TemplatesOneCol}
host\_name(?atom)

\end{TemplatesOneCol}

\Description

\texttt{host\_name(HostName)} unifies \texttt{HostName} with the name of the
host machine executing the current GNU Prolog process. If the sockets are
available \RefSP{Introduction:(Sockets-input/output)}, the name returned
will be fully qualified. In that case, \texttt{host\_name/1} will also
succeed if \texttt{HostName} is instantiated to the unqualified name (or an
alias) of the machine.

\begin{PlErrors}

\ErrCond{\texttt{HostName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, HostName)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{os\_version/1}}

\begin{TemplatesOneCol}
os\_version(?atom)

\end{TemplatesOneCol}

\Description

\texttt{os\_version(OSVersion)} unifies \texttt{OSVersion} with the
operating system version of the machine executing the current GNU Prolog
process.

\begin{PlErrors}

\ErrCond{\texttt{OSVersion} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, OSVersion)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{architecture/1}}

\begin{TemplatesOneCol}
architecture(?atom)

\end{TemplatesOneCol}

\Description

\texttt{architecture(Architecture)} unifies \texttt{Architecture} with the
name of the machine executing the current GNU Prolog process.

\begin{PlErrors}

\ErrCond{\texttt{Architecture} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Architecture)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{shell/2},
               \IdxPBD{shell/1},
               \IdxPBD{shell/0}}

\begin{TemplatesOneCol}
shell(+atom, ?integer)\\
shell(+atom)\\
shell

\end{TemplatesOneCol}

\Description

\texttt{shell(Command, Status)} invokes a new shell (named by the
\texttt{SHELL} environment variable) passing \texttt{Command} for execution
and unifies \texttt{Status} with the result of the execution. If
\texttt{Command} is the empty atom \texttt{''} a new interactive shell is
executed. The control is returned to Prolog upon termination of the called
process.

\texttt{shell(Command)} is equivalent to \texttt{shell(Command, 0)}.

\texttt{shell} is equivalent to \texttt{shell('', 0)}.

\begin{PlErrors}

\ErrCond{\texttt{Command} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Command} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Command)}

\ErrCond{\texttt{Status} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Status)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{system/2},
               \IdxPBD{system/1}}

\begin{TemplatesOneCol}
system(+atom, ?integer)\\
system(+atom)

\end{TemplatesOneCol}

\Description

\texttt{system(Command, Status)} invokes a new default shell passing
\texttt{Command} for execution and unifies \texttt{Status} with the result
of the execution. The control is returned to Prolog upon termination of the
shell process. This predicate is an interface to the C Unix function
\texttt{system(3)}.

\texttt{system(Command)} is equivalent to \texttt{system(Command, 0)}.

\begin{PlErrors}

\ErrCond{\texttt{Command} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Command} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Command)}

\ErrCond{\texttt{Status} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Status)}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{spawn/3},
               \IdxPBD{spawn/2}}

\begin{TemplatesOneCol}
spawn(+atom, +atom\_list, ?integer)\\
spawn(+atom, +atom\_list)

\end{TemplatesOneCol}

\Description

\texttt{spawn(Command, Arguments, Status)} executes \texttt{Command} passing
as arguments of the command-line each element of the list \texttt{Arguments}
and unifies \texttt{Status} with the result of the execution. The control is
returned to Prolog upon termination of the command.

\texttt{spawn(Command, Arguments)} is equivalent to \texttt{spawn(Command,
Arguments, 0)}.

\begin{PlErrors}

\ErrCond{\texttt{Command} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Command} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Command)}

\ErrCond{\texttt{Arguments} is a partial list or a list with an element
which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Arguments} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Arguments)}

\ErrCond{an element \texttt{E} of the \texttt{Arguments} list is neither a
variable nor an atom}
\ErrTerm{type\_error(atom, E)}

\ErrCond{\texttt{Status} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Status)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{popen/3}\label{popen/3}}

\begin{TemplatesOneCol}
popen(+atom, +io\_mode, -stream)

\end{TemplatesOneCol}

\Description

\texttt{popen(Command, Mode, Stream)} invokes a new default shell (by
creating a pipe) passing \texttt{Command} for execution and associates a
stream either to the standard input or the standard output of the created
process. if \texttt{Mode} is \texttt{read} (resp. \texttt{write}) an input
(resp. output) stream is created and \texttt{Stream} is unified with the
stream-term associated. Writing to the stream writes to the standard input
of the command while reading from the stream reads the command's standard
output. The stream must be closed using \IdxPB{close/2} \RefSP{close/2}.
This predicate is an interface to the C Unix function \texttt{popen(3)}.

\begin{PlErrors}

\ErrCond{\texttt{Command} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Command} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Command)}

\ErrCond{\texttt{Mode} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Mode} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Mode)}

\ErrCond{\texttt{Mode} is an atom but neither \texttt{read} nor
\texttt{write}.}
\ErrTerm{domain\_error(io\_mode, Mode)}

\ErrCond{\texttt{Stream} is not a variable}
\ErrTerm{uninstantiation\_error(Stream)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{exec/5},
               \IdxPBD{exec/4}}

\begin{TemplatesOneCol}
exec(+atom, -stream, -stream, -stream, -integer)\\
exec(+atom, -stream, -stream, -stream)

\end{TemplatesOneCol}

\Description

\texttt{exec(Command, StreamIn, StreamOut, StreamErr, Pid)} invokes a new
default shell passing \texttt{Command} for execution and associates streams
to standard streams of the created process. \texttt{StreamIn} is unified
with the stream-term associated with the standard input stream of
\texttt{Command} (it is an output stream). \texttt{StreamOut} is unified
with the stream-term associated with the standard output stream of
\texttt{Command} (it is an input stream). \texttt{StreamErr} is unified with
the stream-term associated with the standard error stream of \texttt{Command}
(it is an input stream). \texttt{Pid} is unified with the process identifier
of the new process. This information is only useful if it is necessary to
obtain the status of the execution using \texttt{wait/2} \RefSP{wait/2}.
Until a call to \texttt{wait/2} is done the process remains in the system
processes table (as a zombie process if terminated). For this reason, if the
status is not needed it is preferable to use \texttt{exec/4}.

\texttt{exec/4} is similar to \texttt{exec/5} but the process is removed
from system processes as soon as it is terminated.

\begin{PlErrors}

\ErrCond{\texttt{Command} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Command} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Command)}

\ErrCond{\texttt{StreamIn} is not a variable}
\ErrTerm{uninstantiation\_error(StreamIn)}

\ErrCond{\texttt{StreamOut} is not a variable}
\ErrTerm{uninstantiation\_error(StreamOut)}

\ErrCond{\texttt{StreamErr} is not a variable}
\ErrTerm{uninstantiation\_error(StreamErr)}

\ErrCond{\texttt{Pid} is not a variable}
\ErrTerm{uninstantiation\_error(Pid)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{fork\_prolog/1}}

\begin{TemplatesOneCol}
fork\_prolog(-integer)

\end{TemplatesOneCol}

\Description

\texttt{fork\_prolog(Pid)} creates a child process that differs from the parent
process only in its PID. In the parent process \texttt{Pid} is unified with
the PID of the child while in the child process \texttt{Pid} is unified with
0. In the parent process, the status of the child process can be obtained
using \texttt{wait/2} \RefSP{wait/2}. Until a call to \texttt{wait/2} is done
the child process remains in the system processes table (as a zombie process
if terminated). This predicate is an interface to the C Unix function
\texttt{fork(2)}.

\begin{PlErrors}

\ErrCond{\texttt{Pid} is not a variable}
\ErrTerm{uninstantiation\_error(Pid)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{create\_pipe/2}}

\begin{TemplatesOneCol}
create\_pipe(-stream, -stream)

\end{TemplatesOneCol}

\Description

\texttt{create\_pipe(StreamIn, StreamOut)} creates  a  pair  of streams
pointing to a pipe inode. \texttt{StreamIn} is unified with the stream-term
associated with the input side of the pipe and \texttt{StreamOut} is unified
with the stream-term associated with output side. This predicate is an
interface to the C Unix function \texttt{pipe(2)}.

\begin{PlErrors}

\ErrCond{\texttt{StreamIn} is not a variable}
\ErrTerm{uninstantiation\_error(StreamIn)}

\ErrCond{\texttt{StreamOut} is not a variable}
\ErrTerm{uninstantiation\_error(StreamOut)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{wait/2}\label{wait/2}}

\begin{TemplatesOneCol}
wait(+integer, ?integer)

\end{TemplatesOneCol}

\Description

\texttt{wait(Pid, Status)} waits for the child process whose identifier is
\texttt{Pid} to terminate. \texttt{Status} is then unified with the exit
status. This predicate is an interface to the C Unix function
\texttt{waitpid(2)}.

\begin{PlErrors}

\ErrCond{\texttt{Pid} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Pid} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Pid)}

\ErrCond{\texttt{Status} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Status)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{prolog\_pid/1}}

\begin{TemplatesOneCol}
prolog\_pid(?integer)

\end{TemplatesOneCol}

\Description

\texttt{prolog\_pid(Pid)} unifies \texttt{Pid} with the process identifier
of the current GNU Prolog process.

\begin{PlErrors}

\ErrCond{\texttt{Pid} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Pid)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{send\_signal/2}}

\begin{TemplatesOneCol}
send\_signal(+integer, +integer)\\
send\_signal(+integer, +atom)

\end{TemplatesOneCol}

\Description

\texttt{send\_signal(Pid, Signal)} sends \texttt{Signal} to the process whose
identifier is \texttt{Pid.} \texttt{Signal} can be specified directly as an
integer or symbolically as an atom. Allowed atoms depend on the machine (e.g.
\texttt{'SIGINT'}, \texttt{'SIGQUIT'}, \texttt{'SIGKILL'},
\texttt{'SIGUSR1'}, \texttt{'SIGUSR2'}, \texttt{'SIGALRM'},\ldots). This
predicate is an interface to the C Unix function \texttt{kill(2)}.

\begin{PlErrors}

\ErrCond{\texttt{Pid} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Pid} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Pid)}

\ErrCond{\texttt{Signal} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Signal} is neither a variable nor an integer or an atom}
\ErrTerm{type\_error(integer, Signal)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{sleep/1}}

\begin{TemplatesOneCol}
sleep(+number)

\end{TemplatesOneCol}

\Description

\texttt{sleep(Seconds)} puts the GNU Prolog process to sleep for
\texttt{Second}s seconds. \texttt{Seconds} can be an integer or a floating
point number (in which case it can be $<$ 1). This predicate is an interface
to the C Unix function \texttt{usleep(3)}.

\begin{PlErrors}

\ErrCond{\texttt{Seconds} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Seconds} is neither a variable nor a number}
\ErrTerm{type\_error(number, Seconds)}

\ErrCond{\texttt{Seconds} is a number $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, Seconds)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{select/5}\label{select/5}}

\begin{TemplatesOneCol}
select(+list, ?list, +list, ?list, +number)

\end{TemplatesOneCol}

\Description

\texttt{select(Reads, ReadyReads, Writes, ReadyWrites, TimeOut)} waits for a
number of streams (or file descriptors) to change status.
\texttt{ReadyReads} is unified with the list of elements listed in
\texttt{Reads} that have characters available for reading. Similarly
\texttt{ReadyWrites} is unified with the list of elements of \texttt{Writes}
that are ok for immediate writing. The elements of \texttt{Reads} and
\texttt{Writes} are either stream-terms or aliases or integers considered as
file descriptors, e.g. for sockets \RefSP{Sockets-input/output}. Streams
that must be tested with \texttt{select/5} should not be buffered. This can
be done at the opening using \IdxPB{open/4} \RefSP{open/4} or later using
\IdxPB{set\_stream\_buffering/2} \RefSP{set-stream-buffering/2}.
\texttt{TimeOut} is an upper bound on the amount of time (in milliseconds)
elapsed before \texttt{select/5} returns. If \texttt{TimeOut} $\leq$ 0 (no
timeout) \texttt{select/5} waits until something is available (either or
reading or for writing) and thus can block indefinitely. This predicate is
an interface to the C Unix function \texttt{select(2)}.

\begin{PlErrors}

\ErrCond{\texttt{Reads} (or \texttt{Writes}) is a partial list or a list
with an element \texttt{E} which is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Reads} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Reads)}

\ErrCond{\texttt{Writes} is neither a partial list nor a list}
\ErrTerm{type\_error(list, Writes)}

\ErrCond{\texttt{ReadyReads} is neither a partial list nor a list}
\ErrTerm{type\_error(list, ReadyReads)}

\ErrCond{\texttt{ReadyWrites} is neither a partial list nor a list}
\ErrTerm{type\_error(list, ReadyWrites)}

\ErrCond{an element \texttt{E} of the \texttt{Reads} (or \texttt{Writes})
list is neither a stream-term or alias nor an integer}
\ErrTerm{domain\_error(stream\_or\_alias, E)}

\ErrCond{an element \texttt{E} of the \texttt{Reads} (or \texttt{Writes})
list is not a selectable item}
\ErrTerm{domain\_error(selectable\_item, E)}

\ErrCond{an element \texttt{E} of the \texttt{Reads} (or \texttt{Writes})
list is an integer $<$ 0}
\ErrTerm{domain\_error(not\_less\_than\_zero, E)}

\ErrCond{an element \texttt{E} of the \texttt{Reads} (or \texttt{Writes})
list is a stream-tern or alias not associated with an open stream}
\ErrTerm{existence\_error(stream, E)}

\ErrCond{an element \texttt{E} of the \texttt{Reads} list is associated with
an output stream}
\ErrTerm{permission\_error(input, stream, E)}

\ErrCond{an element \texttt{E} of the \texttt{Writes} list is associated with
an input stream}
\ErrTerm{permission\_error(output, stream, E)}

\ErrCond{\texttt{TimeOut} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{TimeOut} is neither a variable nor a number}
\ErrTerm{type\_error(number, TimeOut)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{Sockets input/output}
\label{Sockets-input/output}

\subsubsection{Introduction}
\label{Introduction:(Sockets-input/output)}
This set of predicates provides a way to manipulate sockets. The predicates
are straightforward interfaces to the corresponding BSD-type socket
functions. This facility is available if the sockets part of GNU Prolog has
been installed. A reader familiar with BSD sockets will understand them
immediately otherwise a study of sockets is needed.

The domain is either the atom \texttt{'AF\_INET'} or \texttt{'AF\_UNIX'}
corresponding to the same domains in BSD-type sockets.

An address is either of the form \texttt{'AF\_INET'(HostName, Port)} or
\texttt{'AF\_UNIX'(SocketName)}. \texttt{HostName} is an atom denoting a
machine name, \texttt{Port} is a port number and \texttt{SocketName} is an
atom denoting a socket.

By default, streams associated with sockets are \texttt{block} buffered. The
predicate \IdxPB{set\_stream\_buffering/2} \RefSP{set-stream-buffering/2}
can be used to change this mode. They are also text streams by default. Use
\IdxPB{set\_stream\_type/2} \RefSP{set-stream-type/2} to change the type
if binary streams are needed.

\subsubsection{\IdxPBD{socket/2}}

\begin{TemplatesOneCol}
socket(+socket\_domain, -integer)

\end{TemplatesOneCol}

\Description

\texttt{socket(Domain, Socket)} creates a socket whose domain is
\texttt{Domain} \RefSP{Sockets-input/output} and unifies \texttt{Socket}
with the descriptor identifying the socket. This predicate is an interface
to the C Unix function \texttt{socket(2)}.

\begin{PlErrors}

\ErrCond{\texttt{Domain} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Domain} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Domain)}

\ErrCond{\texttt{Domain} is an atom but not a valid socket domain}
\ErrTerm{domain\_error(socket\_domain, Domain)}

\ErrCond{\texttt{Socket} is not a variable}
\ErrTerm{uninstantiation\_error(Socket)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{socket\_close/1}}

\begin{TemplatesOneCol}
socket\_close(+integer)

\end{TemplatesOneCol}

\Description

\texttt{socket\_close(Socket)} closes the socket whose descriptor is
\texttt{Socket}. This predicate should not be used if \texttt{Socket} has
given rise to a stream, e.g. by \IdxPB{socket\_connect/4}
\RefSP{socket-connect/4}.  In that case simply use \IdxPB{close/2}
\RefSP{close/2} on the associated stream.

\begin{PlErrors}

\ErrCond{\texttt{Socket} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Socket} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Socket)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{socket\_bind/2}}

\begin{TemplatesOneCol}
socket\_bind(+integer, +socket\_address)

\end{TemplatesOneCol}

\Description

\texttt{socket\_bind(Socket, Address)} binds the socket whose descriptor is
\texttt{Socket} to the address specified by \texttt{Address}
\RefSP{Sockets-input/output}. If \texttt{Address} if of the form
\texttt{'AF\_INET'(HostName, Port)} and if \texttt{HostName} is
uninstantiated then it is unified with the current machine name. If
\texttt{Port} is uninstantiated, it is unified to a port number picked by
the operating system. This predicate is an interface to the C Unix function
\texttt{bind(2)}.

\begin{PlErrors}

\ErrCond{\texttt{Socket} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Socket} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Socket)}

\ErrCond{\texttt{Address} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Address} is neither a variable nor a valid address}
\ErrTerm{domain\_error(socket\_address, Address)}

\ErrCond{\texttt{Address} = \texttt{'AF\_UNIX'(E)} and \texttt{E} is a
variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Address} = \texttt{'AF\_UNIX'(E)} or \texttt{'AF\_INET'(E,
\_)} and \texttt{E} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, E)}

\ErrCond{\texttt{Address} = \texttt{'AF\_UNIX'(E)} and \texttt{E} is an atom
but not a valid pathname}
\ErrTerm{domain\_error(os\_path, E)}

\ErrCond{\texttt{Address} = \texttt{'AF\_INET'(\_, E)} and \texttt{E} is
neither a variable nor an integer}
\ErrTerm{type\_error(integer, E)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{socket\_connect/4}\label{socket-connect/4}}

\begin{TemplatesOneCol}
socket\_connect(+integer, +socket\_address, -stream, -stream)

\end{TemplatesOneCol}

\Description

\texttt{socket\_connect(Socket, Address, StreamIn, StreamOut)} connects the
socket whose descriptor is \texttt{Socket} to the address specified by
\texttt{Address} \RefSP{Sockets-input/output}. \texttt{StreamIn} is
unified with a stream-term associated with the input of the connection (it is
an input stream). Reading from this stream gets data from the socket.
\texttt{StreamOut} is unified with a stream-term associated with the output of
the connection (it is an output stream). Writing to this stream sends data
to the socket. The use of \IdxPB{select/5} can be useful
\RefSP{select/5}. This predicate is an interface to the C Unix function
\texttt{connect(2)}.

\begin{PlErrors}

\ErrCond{\texttt{Socket} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Socket} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Socket)}

\ErrCond{\texttt{Address} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Address} is neither a variable nor a valid address}
\ErrTerm{domain\_error(socket\_address, Address)}

\ErrCond{\texttt{Address} = \texttt{'AF\_UNIX'(E)} or \texttt{'AF\_INET'(E,
\_)} or \texttt{Address} = \texttt{'AF\_INET'(\_, E)} and \texttt{E} is a
variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Address} = \texttt{'AF\_UNIX'(E)} or \texttt{'AF\_INET'(E,
\_)} and \texttt{E} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, E)}

\ErrCond{\texttt{Address} = \texttt{'AF\_UNIX'(E)} and \texttt{E} is an atom
but not a valid pathname}
\ErrTerm{domain\_error(os\_path, E)}

\ErrCond{\texttt{Address} = \texttt{'AF\_INET'(\_, E)} and \texttt{E} is
neither a variable nor an integer}
\ErrTerm{type\_error(integer, E)}

\ErrCond{\texttt{StreamIn} is not a variable}
\ErrTerm{uninstantiation\_error(StreamIn)}

\ErrCond{\texttt{StreamOut} is not a variable}
\ErrTerm{uninstantiation\_error(StreamOut)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{socket\_listen/2}}

\begin{TemplatesOneCol}
socket\_listen(+integer, +integer)

\end{TemplatesOneCol}

\Description

\texttt{socket\_listen(Socket, Length)} defines the socket whose descriptor
is \texttt{Socket} to have a maximum backlog queue of \texttt{Length}
pending connections. This predicate is an interface to the C Unix function
\texttt{listen(2)}.

\begin{PlErrors}

\ErrCond{\texttt{Socket} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Socket} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Socket)}

\ErrCond{\texttt{Length} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Length} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Length)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{socket\_accept/4},
               \IdxPBD{socket\_accept/3}}

\begin{TemplatesOneCol}
socket\_accept(+integer, -atom, -stream, -stream)\\
socket\_accept(+integer, -stream, -stream)

\end{TemplatesOneCol}

\Description

\texttt{socket\_accept(Socket, Client, StreamIn, StreamOut)} extracts the
first connection to the socket whose descriptor is \texttt{Socket}. If the
domain is \texttt{'AF\_INET'}, \texttt{Client} is unified with an atom whose
name is the Internet host address in numbers-and-dots notation of the
connecting machine. \texttt{StreamIn} is unified with a stream-term
associated with the input of the connection (it is an input stream). Reading
from this stream gets data from the socket. \texttt{StreamOut} is unified
with a stream-term associated with the output of the connection (it is an
output stream). Writing to this stream sends data to the socket. The use of
\IdxPB{select/5} can be useful \RefSP{select/5}. This predicate is an
interface to the C Unix function \texttt{accept(2)}.

\texttt{socket\_accept(Socket, StreamIn, StreamOut)} is equivalent to
\texttt{socket\_accept(Socket, \_,\\
 StreamIn, StreamOut)}.

\begin{PlErrors}

\ErrCond{\texttt{Socket} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Socket} is neither a variable nor an integer}
\ErrTerm{type\_error(integer, Socket)}

\ErrCond{\texttt{Client} is not a variable}
\ErrTerm{uninstantiation\_error(Client)}

\ErrCond{\texttt{StreamIn} is not a variable}
\ErrTerm{uninstantiation\_error(StreamIn)}

\ErrCond{\texttt{StreamOut} is not a variable}
\ErrTerm{uninstantiation\_error(StreamOut)}

\ErrCond{an operating system error occurs and the value of the
\texttt{os\_error} Prolog flag is \texttt{error}
\RefSP{set-prolog-flag/2}}
\ErrTerm{system\_error(\textit{atom explaining the error})}

\end{PlErrors}

\Portability

GNU Prolog predicates.

\subsubsection{\IdxPBD{hostname\_address/2}}

\begin{TemplatesOneCol}
hostname\_address(+atom, ?atom)\\
hostname\_address(?atom, +atom)

\end{TemplatesOneCol}

\Description

\texttt{hostname\_address(HostName, HostAddress)} succeeds if the Internet
host address in numbers-and-dots notation of \texttt{HostName} is
\texttt{HostAddress}. \texttt{Hostname} can be given as a fully qualified
name, or an unqualified name or an alias of the machine. The predicate will
fail if the machine name or address cannot be resolved.

\begin{PlErrors}

\ErrCond{\texttt{HostName} and \texttt{HostAddress} are variables}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{HostName} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, HostName)}

\ErrCond{\texttt{HostAddress} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, HostAddress)}

\ErrCond{\texttt{Address} is neither a variable nor a valid address}
\ErrTerm{domain\_error(socket\_address, Address)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsection{Linedit management}
The following predicates are only available if the \IdxK{linedit} part of
GNU Prolog has been installed.

\subsubsection{\IdxPBD{get\_linedit\_prompt/1}}

\begin{TemplatesOneCol}
get\_linedit\_prompt(?atom)

\end{TemplatesOneCol}

\Description

\texttt{get\_linedit\_prompt(Prompt)} succeeds if \texttt{Prompt} is the
current \IdxK{linedit} prompt, e.g. the \Idx{top-level} prompt is
\texttt{'| ?-'}. By default all other reads have an empty prompt.

\begin{PlErrors}

\ErrCond{\texttt{Prompt} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Pred)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{set\_linedit\_prompt/1}}

\begin{TemplatesOneCol}
set\_linedit\_prompt(+atom)

\end{TemplatesOneCol}

\Description

\texttt{set\_linedit\_prompt(Prompt)} sets the current \IdxK{linedit}
prompt to \texttt{Prompt}. This prompt will be displayed for reads from a
terminal (except for \Idx{top-level} reads).

\begin{PlErrors}

\ErrCond{\texttt{Prompt} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Prompt} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Pred)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{add\_linedit\_completion/1}}

\begin{TemplatesOneCol}
add\_linedit\_completion(+atom)

\end{TemplatesOneCol}

\Description

\texttt{add\_linedit\_completion(Word)} adds \texttt{Word} in the list of
\Idx{completion} words maintained by \IdxK{linedit}
\RefSP{The-line-editor}. Only words containing letters, digits and
the underscore character are added (if \texttt{Word} does not respect
this restriction the predicate fails).

\begin{PlErrors}

\ErrCond{\texttt{Word} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Word} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Word)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

\subsubsection{\IdxPBD{find\_linedit\_completion/2}}

\begin{TemplatesOneCol}
find\_linedit\_completion(+atom, ?atom)

\end{TemplatesOneCol}

\Description

\texttt{find\_linedit\_completion(Prefix, Word)} succeeds if \texttt{Word}
is a word beginning by \texttt{Prefix} and belongs to the list of
\Idx{completion} words maintained by \IdxK{linedit}
\RefSP{The-line-editor}. This predicate is re-executable on backtracking.

\begin{PlErrors}

\ErrCond{\texttt{Prefix} is a variable}
\ErrTerm{instantiation\_error}

\ErrCond{\texttt{Prefix} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Prefix)}

\ErrCond{\texttt{Word} is neither a variable nor an atom}
\ErrTerm{type\_error(atom, Word)}

\end{PlErrors}

\Portability

GNU Prolog predicate.

%\subsection{Source reader facility}

% \subsubsection{Introduction}

% To be written...

% \subsubsection{\IdxPBD{sr\_open/3}}

% \subsubsection{\IdxPBD{sr\_change\_options/2}}

% \subsubsection{\IdxPBD{sr\_close/1}}

% \subsubsection{\IdxPBD{sr\_read\_term/4}}

% \subsubsection{\IdxPBD{sr\_current\_descriptor/1}}

% \subsubsection{\IdxPBD{sr\_get\_stream/2}}

% \subsubsection{\IdxPBD{sr\_get\_module/3}}

% \subsubsection{\IdxPBD{sr\_get\_file\_name/2}}

% \subsubsection{\IdxPBD{sr\_get\_position/3}}

% \subsubsection{\IdxPBD{sr\_get\_include\_list/2}}

% \subsubsection{\IdxPBD{sr\_get\_include\_stream\_list/2}}

% \subsubsection{\IdxPBD{sr\_get\_size\_counters/3}}

% \subsubsection{\IdxPBD{sr\_get\_error\_counters/3}}

% \subsubsection{\IdxPBD{sr\_set\_error\_counters/3}}

% \subsubsection{\IdxPBD{sr\_error\_from\_exception/2}}

% \subsubsection{\IdxPBD{sr\_write\_message/8},
%                \IdxPBD{sr\_write\_message/6},
%                \IdxPBD{sr\_write\_message/4}}

% \subsubsection{\IdxPBD{sr\_write\_error/6},
%                \IdxPBD{sr\_write\_error/4},
%                \IdxPBD{sr\_write\_error/2}}


%HEVEA\cutend
