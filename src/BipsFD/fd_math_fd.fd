/*-------------------------------------------------------------------------*
 * GNU Prolog                                                              *
 *                                                                         *
 * Part  : FD constraint solver buit-in predicates                         *
 * File  : fd_math_fd.fd                                                   *
 * Descr.: mathematical predicate management - FD part                     *
 * Author: Daniel Diaz                                                     *
 *                                                                         *
 * Copyright (C) 1999-2023 Daniel Diaz                                     *
 *                                                                         *
 * This file is part of GNU Prolog                                         *
 *                                                                         *
 * GNU Prolog is free software: you can redistribute it and/or             *
 * modify it under the terms of either:                                    *
 *                                                                         *
 *   - the GNU Lesser General Public License as published by the Free      *
 *     Software Foundation; either version 3 of the License, or (at your   *
 *     option) any later version.                                          *
 *                                                                         *
 * or                                                                      *
 *                                                                         *
 *   - the GNU General Public License as published by the Free             *
 *     Software Foundation; either version 2 of the License, or (at your   *
 *     option) any later version.                                          *
 *                                                                         *
 * or both in parallel, as here.                                           *
 *                                                                         *
 * GNU Prolog is distributed in the hope that it will be useful,           *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       *
 * General Public License for more details.                                *
 *                                                                         *
 * You should have received copies of the GNU General Public License and   *
 * the GNU Lesser General Public License along with this program.  If      *
 * not, see http://www.gnu.org/licenses/.                                  *
 *-------------------------------------------------------------------------*/

%{
#include "bips_fd.h"
#define ite(i, t, e)  		((i) ? (t) : (e))
#define is_even(a)		(((a) & 1) == 0)
#define is_odd(a)		(((a) & 1) == 1)
#define max_exponent(a)		((a>0) ? (Pl_Find_Expon_Dn(a,max_integer)) : (Pl_Find_Expon_Dn(-a,max_integer)))
#define abs(a)			((a>0) ? (a) : (-(a))) 

static int inline mult(int a, int b)
{
   int64_t res = ((int64_t)a) * ((int64_t)b);
   if (res > max_integer)
	res = max_integer;
   else if (res < min_integer)
	res = min_integer;
   return (int) res;
}

static int inline min_sqrt(int min_X, int min_N, int max_N){
   int sqrt = Pl_Sqrt_Up(min_N>0 ? min_N : 0);
   if (min_X <= - sqrt)
	return - (int) Pl_Sqrt_Dn(max_N);
   else return sqrt;
}

static int inline max_sqrt(int min_X, int min_N, int max_N){
   int sqrt = Pl_Sqrt_Up(min_N>0 ? min_N : 0);
   if (min_X >= sqrt)
	return (int) Pl_Sqrt_Dn(max_N);
   else return - sqrt;
}

#define Minus_Pl_Nth_Root_Dn(a,b) (-(int)Pl_Nth_Root_Dn(a,b))
#define Minus_Pl_Nth_Root_Up(a,b) (-(int)Pl_Nth_Root_Up(a,b))

static int inline min_root(int min_X, int min_Y, int max_Y, int A){
   int root = Pl_Nth_Root_Up(min_Y>0 ? min_Y : abs(closest_to_zero(min_Y,max_Y)) , A);
   if (min_X <= - root)
	return - (int) Pl_Nth_Root_Dn(max_Y, A);
   else return root;
}

static int inline max_root(int max_X, int min_Y, int max_Y, int A){
   int root = Pl_Nth_Root_Up(min_Y>0 ? min_Y : abs(closest_to_zero(min_Y,max_Y)) , A);
   if (max_X >= root)
	return (int) Pl_Nth_Root_Dn(max_Y, A);
   else return - root;
}

%}




/*-------------------------------------------------------------------------*
 * EQUAL (LINEAR)                                                          *
 *                                                                         *
 * NB: pl_x_eq_c(fdv X, int C) is defined as a function in math_supp.c to  *
 * avoid A Frame creation.                                                 *
 *-------------------------------------------------------------------------*/


	/*------------*
	 * Partial AC *
	 *------------*/


pl_x_eq_y(fdv X, fdv Y)

{
 start X in min(Y) .. max(Y)
 start Y in min(X) .. max(X)
}




pl_x_plus_c_eq_y(fdv X, int C, fdv Y)

{
 start X in min(Y) - C .. max(Y) - C
 start Y in min(X) + C .. max(X) + C
}


	/*------------*
	 *  Full AC   *
	 *------------*/


pl_x_eq_y_F(fdv X, fdv Y)

{
 start X in dom(Y)
 start Y in dom(X)
}




pl_x_plus_c_eq_y_F(fdv X, int C, fdv Y)

{
 start X in dom(Y) - C
 start Y in dom(X) + C
}




/*-------------------------------------------------------------------------*
 * DIFFERENT (LINEAR)                                                      *
 *                                                                         *
 *-------------------------------------------------------------------------*/


	/*------------*
	 * Partial AC *
	 *------------*/


pl_x_neq_c(fdv X, int C)

{
 start X in ~{C}
}




pl_x_neq_y(fdv X, fdv Y)

{
 start X in ~{val(Y)}
 start Y in ~{val(X)}
}




pl_x_plus_c_neq_y(fdv X, int C, fdv Y)

{
 start X in ~{val(Y) - C}
 start Y in ~{val(X) + C}
}




/*-------------------------------------------------------------------------*
 * LESS THAN (LINEAR)                                                      *
 *                                                                         *
 *-------------------------------------------------------------------------*/


	/*------------*
	 * Partial AC *
	 *------------*/


pl_x_lt_y(fdv X, fdv Y)

{
 start X in min_integer .. max(Y) - 1
 start Y in min(X) + 1 .. max_integer
}




/*-------------------------------------------------------------------------*
 * LESS THAN OR EQUAL TO (LINEAR)                                          *
 *                                                                         *
 *-------------------------------------------------------------------------*/


	/*------------*
	 * Partial AC *
	 *------------*/


pl_x_lte_c(fdv X, int C)

{
 start X in min_integer .. C
}




pl_x_lte_y(fdv X, fdv Y)

{
 start X in min_integer .. max(Y)
 start Y in min(X) .. max_integer
}




pl_x_plus_c_lte_y(fdv X, int C, fdv Y)

{
 start X in min_integer .. max(Y) - C
 start Y in min(X) + C .. max_integer
}




/*-------------------------------------------------------------------------*
 * GREATER THAN OR EQUAL TO (LINEAR)                                       *
 *                                                                         *
 *-------------------------------------------------------------------------*/


	/*------------*
	 * Partial AC *
	 *------------*/


pl_x_gte_c(fdv X, int C)

{
 start X in C .. max_integer
}




pl_x_plus_c_gte_y(fdv X, int C, fdv Y)

{
 start X in min(Y) - C .. max_integer
 start Y in min_integer .. max(X) + C
}




/*-------------------------------------------------------------------------*
 * OTHER EQUAL (LINEAR)                                                    *
 *                                                                         *
 * NB: used to split large equations introducing intermediate variables.   *
 *-------------------------------------------------------------------------*/


	/*------------*
	 * Partial AC *
	 *------------*/


pl_ax_eq_y(int A, fdv X, fdv Y) 				/* A != 0 */

{
  start X in ite(A>0, min(Y), max(Y)) /> A    			/* X = Y / A */
          .. ite(A>0, max(Y), min(Y)) /< A
  start Y in mult(ite(A>0, min(X), max(X)) , A)     			/* Y = X * A */
          .. mult(ite(A>0, max(X), min(X)) , A)
}




pl_x_plus_y_eq_z(fdv X, fdv Y, fdv Z)

{
 start X in min(Z) - max(Y) .. max(Z) - min(Y)
 start Y in min(Z) - max(X) .. max(Z) - min(X)
 start Z in min(X) + min(Y) .. max(X) + max(Y)
}




pl_ax_plus_y_eq_z(int A, fdv X, fdv Y, fdv Z)			/* A != 0 */

{
  start X in ite(A>0, min(Z) - max(Y), max(Z) - min(Y)) /> A    /* X = (Z - Y) / A */
          .. ite(A>0, max(Z) - min(Y), min(Z) - max(Y)) /< A

  start Y in min(Z) - mult(ite(A>0, max(X), min(X)) , A)   		/* Y = Z - X * A */
          .. max(Z) - mult(ite(A>0, min(X), max(X)) , A)  

  start Z in mult(ite(A>0, min(X), max(X)) , A) + min(Y)     		/* Z = X * A + Y */
          .. mult(ite(A>0, max(X), min(X)) , A) + max(Y)
}




pl_ax_plus_by_eq_z(int A, fdv X, int B, fdv Y, fdv Z)

{
 /* X = (Z - B*Y) / A (Y can cause overflows)*/
 start X in ite(A>0, ( min(Z) - mult(ite(B>0, max(Y), min(Y)), B) ) /> A
 	           , ( max(Z) - mult(ite(B>0, min(Y), max(Y)), B) ) /> A)
 	 .. ite(A>0, ( max(Z) - mult(ite(B>0, min(Y), max(Y)), B) ) /< A
 	           , ( min(Z) - mult(ite(B>0, max(Y), min(Y)), B) ) /< A)

 /* Y = (Z - A*X) / B (X does not cause overflows anymore) */
 start Y in ite(B>0, ( min(Z) - mult(ite(A>0, max(X), min(X)) , A) ) /> B
 	           , ( max(Z) - mult(ite(A>0, min(X), max(X)) , A) ) /> B)
 	 .. ite(B>0, ( max(Z) - mult(ite(A>0, min(X), max(X)) , A) ) /< B
 	           , ( min(Z) - mult(ite(A>0, max(X), min(X)) , A) ) /< B)

 /* Z = A*X + B*Y (X and Y do not cause overflows anymore) */
 start Z in mult(ite(A>0, min(X), max(X)) , A) + mult(ite(B>0, min(Y), max(Y)) , B)
	 .. mult(ite(A>0, max(X), min(X)) , A) + mult(ite(B>0, max(Y), min(Y)) , B)
}




pl_x_plus_y_plus_z_eq_t(fdv X, fdv Y, fdv Z, fdv T)

{
 start X in min(T) - max(Y) - max(Z) .. max(T) - min(Y) - min(Z)
 start Y in min(T) - max(X) - max(Z) .. max(T) - min(X) - min(Z)
 start Z in min(T) - max(X) - max(Y) .. max(T) - min(X) - min(Y)
 start T in min(X) + min(Y) + min(Z) .. max(X) + max(Y) + max(Z)
}


pl_ax_plus_y_plus_z_eq_t(int A, fdv X, fdv Y, fdv Z, fdv T)

{
 /* X = (T - Z - Y) / A */
 start X in ite(A>0, min(T) - max(Z) - max(Y), max(T) - min(Z) - min(Y)) /> A
 	 .. ite(A>0, max(T) - min(Z) - min(Y), min(T) - max(Z) - max(Y)) /< A

 /* Y = T - Z - A*X  (X does not cause overflows) */
 start Y in min(T) - max(Z) - mult(ite(A>0, max(X), min(X)) , A) 
 	 .. max(T) - min(Z) - mult(ite(A>0, min(X), max(X)) , A)

 /* Z = T - Y - A*X */
 start Z in min(T) - max(Y) - mult(ite(A>0, max(X), min(X)) , A)
 	 .. max(T) - min(Y) - mult(ite(A>0, min(X), max(X)) , A)

 /* T = A*X + Y + Z */
 start T in mult(ite(A>0, min(X), max(X)) , A)  + min(Y) + min(Z) 
 	 .. mult(ite(A>0, max(X), min(X)) , A)  + max(Y) + max(Z) 
}




pl_ax_plus_by_plus_z_eq_t(int A, fdv X, int B, fdv Y, fdv Z, fdv T)

{
 /* X = (T - Z - B*Y) / A */
 start X in ite(A>0, ( min(T) - max(Z) - mult(ite(B>0, max(Y), min(Y)), B) ) /> A
 	           , ( max(T) - min(Z) - mult(ite(B>0, min(Y), max(Y)), B) ) /> A)
 	 .. ite(A>0, ( max(T) - min(Z) - mult(ite(B>0, min(Y), max(Y)), B) ) /< A
 	           , ( min(T) - max(Z) - mult(ite(B>0, max(Y), min(Y)), B) ) /< A)

 /* Y = (T - Z - A*X) / B */
 start Y in ite(B>0, ( min(T) - max(Z) - mult(ite(A>0, max(X), min(X)) , A) ) /> B
 	           , ( max(T) - min(Z) - mult(ite(A>0, min(X), max(X)) , A) ) /> B)
 	 .. ite(B>0, ( max(T) - min(Z) - mult(ite(A>0, min(X), max(X)) , A) ) /< B
 	           , ( min(T) - max(Z) - mult(ite(A>0, max(X), min(X)) , A) ) /< B)

 /* Z = T - A*X - B*Y */
 start Z in min(T) - mult(ite(A>0, max(X), min(X)) , A) - mult(ite(B>0, max(Y), min(Y)) , B)
	 .. max(T) - mult(ite(A>0, min(X), max(X)) , A) - mult(ite(B>0, min(Y), max(Y)) , B)

 /* T = A*X + B*Y + Z */
 start T in mult(ite(A>0, min(X), max(X)) , A) + mult(ite(B>0, min(Y), max(Y)) , B) + min(Z)
	 .. mult(ite(A>0, max(X), min(X)) , A) + mult(ite(B>0, max(Y), min(Y)) , B) + max(Z)
}


	/*------------*
	 *  Full AC   *
	 *------------*/


pl_ax_eq_y_F(int A, fdv X, fdv Y)

{
 start X in (dom(Y)) / A
 start Y in dom(X)*A
}




pl_x_plus_y_eq_z_F(fdv X, fdv Y, fdv Z)

{
 start X in dom(Z) -- dom(Y)
 start Y in dom(Z) -- dom(X)
 start Z in dom(X) ++ dom(Y)
}




pl_ax_plus_y_eq_z_F(int A, fdv X, fdv Y, fdv Z)

{
 start X in (dom(Z) -- dom(Y)) / A
 start Y in dom(Z) -- dom(X)*A
 start Z in dom(X)*A ++ dom(Y)
}




pl_ax_plus_by_eq_z_F(int A, fdv X, int B, fdv Y, fdv Z)

{
 start X in (dom(Z) -- dom(Y)*B) / A
 start Y in (dom(Z) -- dom(X)*A) / B
 start Z in dom(X)*A ++ dom(Y)*B
}




pl_x_plus_y_plus_z_eq_t_F(fdv X, fdv Y, fdv Z, fdv T)

{
 start X in dom(T) -- dom(Y) -- dom(Z)
 start Y in dom(T) -- dom(X) -- dom(Z)
 start Z in dom(T) -- dom(X) -- dom(Y)
 start T in dom(X) ++ dom(Y) ++ dom(Z)
}




pl_ax_plus_y_plus_z_eq_t_F(int A, fdv X, fdv Y, fdv Z, fdv T)

{
 start X in (dom(T) -- dom(Y) -- dom(Z)) / A
 start Y in dom(T) -- dom(X)*A -- dom(Z)
 start Z in dom(T) -- dom(X)*A -- dom(Y)
 start T in dom(X)*A ++ dom(Y) ++ dom(Z)
}




pl_ax_plus_by_plus_z_eq_t_F(int A, fdv X, int B, fdv Y, fdv Z, fdv T)

{
 start X in (dom(T) -- dom(Y)*B -- dom(Z)) / A
 start Y in (dom(T) -- dom(X)*A -- dom(Z)) / B
 start Z in dom(T) -- dom(X)*A -- dom(Y)*B
 start T in dom(X)*A ++ dom(Y)*B ++ dom(Z)
}




/*-------------------------------------------------------------------------*
 * POWER and X * Y                                                         *
 *                                                                         *
 *-------------------------------------------------------------------------*/


	/*------------*
	 * Partial AC *
	 *------------*/

/* Note: for powers, the exponent (N) should be positive (otherwise we'll likely end up with fractions) */

pl_zero_power_n_eq_y(fdv N, fdv Y) 						/* N >= 0 */

{
 start Y in ite(max(N)==0 && min(N)==0, 1, 0)
         .. ite(min(N)<=0 && max(N)>=0, 1, 0)
 /* if (0 in Y): Try to not include 0 in the domain */ 
 start N in ite(max(Y)==0, ite(min(N)==0, 1, min_integer), 0)
         .. ite(min(Y)==0, ite(max(N)==0,-1, max_integer), 0) 
}



pl_a_power_n_eq_y(int A, fdv N, fdv Y)                           /* N >= 0 */

{ 
 start N in 0 .. max_exponent(A) 				/* make sure that N >= 0 and does not exceed A's maximum exponent */

 start Y in Pl_Power(A, ite(A>0, min(N), ite(is_odd(max(N)), max(N), 			/* min(N) or maximum odd N */
				ite(min(N)==max(N), min(N), max(N)-1))))		/* make sure that max(N)-1 is in the interval */
		..
	    Pl_Power(A, ite(A>0, max(N), ite(is_even(max(N)), max(N), 			/* max(N) or maximum even N */
				ite(min(N)==max(N), min(N), max(N)-1))))		/* make sure that max(N)-1 is in the interval */	

 start N in ite(min(Y)<=1 && max(Y)>=1, 0, 						/* A ^ 0 = 1 */
		ite(min(Y)<=0 && max(Y)>=0,
		    ite(min(Y)==max(Y), max_integer, 0), 				/* A ^ N != 0,  	A ^ 0 = 1 */
		    Pl_Find_Expon_Up(abs(A), abs(closest_to_zero(min(Y),max(Y))))))
		..
	    ite(min(Y)==max(Y) && max(Y)==0, min_integer, 				/* A ^ N != 0 */
		Pl_Find_Expon_Dn(abs(A),math_max(abs(min(Y)),abs(max(Y)))))		/* choose max abs Y as result */
}


pl_x_power_a_eq_y(fdv X, int A, fdv Y)                            /* here A > 2 */

{
 start X in ite(is_even(A),
                min_root(min(X), min(Y), max(Y), A),
                ite(min(Y) < 0, 
                    Minus_Pl_Nth_Root_Dn(-min(Y), A), 
                    Pl_Nth_Root_Up(min(Y), A)))	
         .. ite(is_even(A), 
                max_root(max(X), min(Y), max(Y), A),			
                ite(max(Y) < 0, 
                    Minus_Pl_Nth_Root_Up(-max(Y), A), 
                    Pl_Nth_Root_Dn(max(Y), A)))

 start Y in ite(min(X) < 0 && is_odd(A), 
                Pl_Power(min(X), A), 
                Pl_Power(closest_to_zero(min(X), max(X)), A)) 
         .. ite(min(X) < 0 && is_even(A), 
                Pl_Power(math_max(abs(min(X)), max(X)), A),
                Pl_Power(max(X), A))

}




pl_x2_eq_y(fdv X, fdv Y)	/* Y >= 0 */

{
 start X in min_sqrt(min(X), min(Y), max(Y)) 
         .. max_sqrt(max(X), min(Y), max(Y))
 
 start Y in mult(closest_to_zero(min(X), max(X)) , closest_to_zero(min(X), max(X))) 
         .. ite(abs(min(X)) > max(X), min(X)*min(X), max(X)*max(X))
}




pl_xy_eq_z(fdv X, fdv Y, fdv Z)

{ 	
 /* There are a lot of combinations for X*Y = Z ... */
 start X in math_min(math_min(ite(min(Y)!=0, math_min(min(Z)/>min(Y), max(Z)/>min(Y)), max_integer), 	/* Z / Y */
		      ite(max(Y)!=0, math_min(min(Z)/>max(Y), max(Z)/>max(Y)), max_integer) ),
		 math_min(ite(min(Y)<=1 && max(Y)>=1, math_min(min(Z),max(Z)), max_integer),		/* Z or -Z */
		      math_min(ite(min(Y)<=-1 && max(Y)>=-1, math_min(-min(Z),-max(Z)), max_integer),
			   ite(min(Z)<=0 && max(Z)>=0, 0, max_integer))))			/* 0 */
	.. 
	    math_max(math_max(ite(min(Y)!=0, math_max(min(Z)/<min(Y), max(Z)/<min(Y)), min_integer), 
		      ite(max(Y)!=0, math_max(min(Z)/<max(Y), max(Z)/<max(Y)), min_integer) ),
		 math_max(ite(min(Y)<=1 && max(Y)>=1, math_max(min(Z),max(Z)), min_integer),
		      math_max(ite(min(Y)<=-1 && max(Y)>=-1, math_max(-min(Z),-max(Z)), min_integer),
			   ite(min(Z)<=0 && max(Z)>=0, 0, min_integer))))


 start Y in math_min(math_min(ite(min(X)!=0, math_min(min(Z)/>min(X), max(Z)/>min(X)), max_integer),
		      ite(max(X)!=0, math_min(min(Z)/>max(X), max(Z)/>max(X)), max_integer) ),
		 math_min(ite(min(X)<=1 && max(X)>=1, math_min(min(Z),max(Z)), max_integer),
		      math_min(ite(min(X)<=-1 && max(X)>=-1, math_min(-min(Z),-max(Z)), max_integer),
			   ite(min(Z)<=0 && max(Z)>=0, 0, max_integer))))
	.. 
	    math_max(math_max(ite(min(X)!=0, math_max(min(Z)/<min(X), max(Z)/<min(X)), min_integer), 
		      ite(max(X)!=0, math_max(min(Z)/<max(X), max(Z)/<max(X)), min_integer) ),
		 math_max(ite(min(X)<=1 && max(X)>=1, math_max(min(Z),max(Z)), min_integer),
		      math_max(ite(min(X)<=-1 && max(X)>=-1, math_max(-min(Z),-max(Z)), min_integer),
			   ite(min(Z)<=0 && max(Z)>=0, 0, min_integer))))

 start Z in math_min(math_min(mult(min(X),min(Y)), mult(min(X),max(Y))), 
		 math_min(mult(max(X),min(Y)), mult(max(X),max(Y)))) 
 	..  
	    math_max(math_max(mult(min(X),min(Y)), mult(min(X),max(Y))), 
		 math_max(mult(max(X),min(Y)), mult(max(X),max(Y))))
}




	/*------------*
	 *  Full AC   *
	 *------------*/

pl_a_power_n_eq_y_F(int A, fdv N, fdv Y)                         /* here A >= 2 */

{
 start Y in Pl_Full_Coeff_Power_Var(A, dom(N))  /* to ensure Y < max_integer */
 start N in Pl_Full_Find_Expon(A, dom(Y))
}




pl_x_power_a_eq_y_F(fdv X, int A, fdv Y)                          /* here A > 2 */

{
 start Y in Pl_Full_Var_Power_Coeff(dom(X), A)  /* to ensure Y < max_integer */
 start X in Pl_Full_Nth_Root(dom(Y), A)
}




pl_x2_eq_y_F(fdv X, fdv Y)

{
 start Y in Pl_Full_Var_Power_2(dom(X))        /* to ensure Y < max_integer */
 start X in Pl_Full_Sqrt_Var(dom(Y))
}




pl_xy_eq_z_F(fdv X, fdv Y, fdv Z)

{
 start Z in dom(X)**dom(Y)
 wait_switch
    case min(Z) > 0
            start Y in 1..max_integer
            start X in dom(Z)//dom(Y)
            start Y in dom(Z)//dom(X)

    case max(Z)==0 && min(Y) > 0
            start X in { 0 }

    case max(Z)==0 && min(X) > 0
            start Y in { 0 }
}








/*-------------------------------------------------------------------------*
 * MINIMUM                                                                 *
 *                                                                         *
 *-------------------------------------------------------------------------*/


	/*------------*
	 * Partial AC *
	 *------------*/


pl_min_x_y_eq_z(fdv X, fdv Y, fdv Z)

{
 start (c1) Z in math_min(min(X), min(Y)) .. max_integer /* Z >= min(X, Y) */

 start (c2) Z in min_integer .. max(X)                                /* Z <= X */
 start (c3) X in min(Z) .. max_integer

 start (c4) Z in min_integer .. max(Y)                                /* Z <= Y */
 start (c5) Y in min(Z) .. max_integer


 wait_switch
	case min(Y) > max(Z)                              /* case : Y != Z */
		stop c1
		stop c2
		stop c3
		stop c4
		stop c5
		start Z in min(X) .. max(X)                       /* Z = X */
		start X in min(Z) .. max(Z)

	case min(X) > max(Z)                              /* case : X != Z */
		stop c1
		stop c2
		stop c3
		stop c4
		stop c5
		start Z in min(Y) .. max(Y)                       /* Z = Y */
		start Y in min(Z) .. max(Z)
}




pl_min_x_a_eq_z(fdv X, int A, fdv Z)

{
 start (c1) Z in math_min(min(X), A) .. max_integer      /* Z >= min(X, A) */

 start (c2) Z in min_integer .. max(X)                                /* Z <= X */
 start (c3) X in min(Z) .. max_integer

 start      Z in min_integer .. A                                          /* Z <= A */


 wait_switch
	case A > max(Z)                                   /* case : A != Z */
		stop c1
		stop c2
		stop c3
		start Z in min(X) .. max(X)                       /* Z = X */
		start X in min(Z) .. max(Z)
}



	/*------------*
	 *  Full AC   *
	 *------------*/


pl_min_x_y_eq_z_F(fdv X, fdv Y, fdv Z)

{
 start (c1) Z in dom(X) : dom(Y)                         /* Z = X or Z = Y */

 start (c2) Z in min_integer .. max(X)                                /* Z <= X */
 start (c3) X in min(Z) .. max_integer

 start (c4) Z in min_integer .. max(Y)                                /* Z <= Y */
 start (c5) Y in min(Z) .. max_integer

 wait_switch
	case Pl_Range_Test_Null_Inter(dom(Y), dom(Z))     /* case : Y != Z */
		stop c1
		stop c2
		stop c3
		stop c4
		stop c5
		start Z in dom(X)                                 /* Z = X */
		start X in dom(Z)

	case Pl_Range_Test_Null_Inter(dom(X), dom(Z))     /* case : X != Z */
		stop c1
		stop c2
		stop c3
		stop c4
		stop c5
		start Z in dom(Y)                                 /* Z = Y */
		start Y in dom(Z)
}




pl_min_x_a_eq_z_F(fdv X, int A, fdv Z)

{
 start (c1) Z in dom(X) : {A}                            /* Z = X or Z = A */

 start (c2) Z in min_integer .. max(X)                                /* Z <= X */
 start (c3) X in min(Z) .. max_integer

 start      Z in min_integer .. A                                          /* Z <= A */


 wait_switch
	case A > max(Z)                                   /* case : A != Z */
		stop c1
		stop c2
		stop c3
		start Z in dom(X)                                 /* Z = X */
		start X in dom(Z)
}




/*-------------------------------------------------------------------------*
 * MAXIMUM                                                                 *
 *                                                                         *
 *-------------------------------------------------------------------------*/


	/*------------*
	 * Partial AC *
	 *------------*/


pl_max_x_y_eq_z(fdv X, fdv Y, fdv Z)

{
 start (c1) Z in min_integer .. math_max(max(X), max(Y))           /* Z <= max(X, Y) */

 start (c2) Z in min(X) .. max_integer                           /* Z >= X */
 start (c3) X in min_integer .. max(Z)

 start (c4) Z in min(Y) .. max_integer                           /* Z >= Y */
 start (c5) Y in min_integer .. max(Z)


 wait_switch
	case max(Y) < min(Z)                              /* case : Y != Z */
		stop c1
		stop c2
		stop c3
		stop c4
		stop c5
		start Z in min(X) .. max(X)                       /* Z = X */
		start X in min(Z) .. max(Z)

	case max(X) < min(Z)                              /* case : X != Z */
		stop c1
		stop c2
		stop c3
		stop c4
		stop c5
		start Z in min(Y) .. max(Y)                       /* Z = Y */
		start Y in min(Z) .. max(Z)
}




pl_max_x_a_eq_z(fdv X, int A, fdv Z)

{
 start (c1) Z in min_integer .. math_max(max(X), A)                /* Z <= max(X, A) */

 start (c2) Z in min(X) .. max_integer                           /* Z >= X */
 start (c3) X in min_integer .. max(Z)

 start      Z in A .. max_integer                                /* Z >= A */


 wait_switch
	case A < min(Z)                                   /* case : A != Z */
		stop c1
		stop c2
		stop c3
		start Z in min(X) .. max(X)                       /* Z = X */
		start X in min(Z) .. max(Z)
}


	/*------------*
	 *  Full AC   *
	 *------------*/


pl_max_x_y_eq_z_F(fdv X, fdv Y, fdv Z)

{
 start (c1) Z in dom(X) : dom(Y)                         /* Z = X or Z = Y */

 start (c2) Z in min(X) .. max_integer                           /* Z >= X */
 start (c3) X in min_integer .. max(Z)

 start (c4) Z in min(Y) .. max_integer                           /* Z >= Y */
 start (c5) Y in min_integer .. max(Z)


 wait_switch
	case Pl_Range_Test_Null_Inter(dom(Y), dom(Z))      /* case : Y != Z */
		stop c1
		stop c2
		stop c3
		stop c4
		stop c5
		start Z in dom(X)                                 /* Z = X */
		start X in dom(Z)

	case Pl_Range_Test_Null_Inter(dom(X), dom(Z))      /* case : X != Z */
		stop c1
		stop c2
		stop c3
		stop c4
		stop c5
		start Z in dom(Y)                                 /* Z = Y */
		start Y in dom(Z)
}




pl_max_x_a_eq_z_F(fdv X, int A, fdv Z)

{
 start (c1) Z in dom(X) : {A}                            /* Z = X or Z = A */

 start (c2) Z in min(X) .. max_integer                           /* Z >= X */
 start (c3) X in min_integer .. max(Z)

 start      Z in A .. max_integer                                /* Z >= A */


 wait_switch
	case A < min(Z)                                     /* case : A != Z */
		stop c1
		stop c2
		stop c3
		start Z in dom(X)                                 /* Z = X */
		start X in dom(Z)
}




/*-------------------------------------------------------------------------*
 * ABSOLUTE VALUE                                                          *
 *                                                                         *
 *-------------------------------------------------------------------------*/


	/*------------*
	 * Partial AC *
	 *------------*/

pl_abs_x_minus_y_eq_z(fdv X, fdv Y, fdv Z)

{
 start (c1) X in min(Y) + min(Z) .. max(Y) + max(Z) :
                 min(Y) - max(Z) .. max(Y) - min(Z)

 start (c2) Y in min(X) + min(Z) .. max(X) + max(Z) :
                 min(X) - max(Z) .. max(X) - min(Z)

 start (c3) Z in min(X) - max(Y) .. max(X) - min(Y) :
                 min(Y) - max(X) .. max(Y) - min(X)

 wait_switch
	case min(X) >= max(Y)                             /* case : X >= Y */
		stop c1
		stop c2
		stop c3
		start X in min(Y) + min(Z) .. max(Y) + max(Z)
		start Y in min(X) - max(Z) .. max(X) - min(Z)
		start Z in min(X) - max(Y) .. max(X) - min(Y)

	case min(Y) >= max(X)                             /* case : Y >= X */
		stop c1
		stop c2
		stop c3
		start X in min(Y) - max(Z) .. max(Y) - min(Z)
		start Y in min(X) + min(Z) .. max(X) + max(Z)
		start Z in min(Y) - max(X) .. max(Y) - min(X)
}


	/*------------*
	 *  Full AC   *
	 *------------*/


pl_abs_x_minus_a_eq_z(fdv X, int A, fdv Z)

{
 start (c1) X in A + min(Z) .. A + max(Z) :
                 A - max(Z) .. A - min(Z)

 start (c2) Z in min(X) - A .. max(X) - A :
                 A - max(X) .. A - min(X)

 wait_switch
	case min(X) >= A                                  /* case : X >= A */
		stop c1
		stop c2
		start X in A + min(Z) .. A + max(Z)
		start Z in min(X) - A .. max(X) - A

	case A >= max(X)                                  /* case : A >= X */
		stop c1
		stop c2
		start X in A - max(Z) .. A - min(Z)
		start Z in A - max(X) .. A - min(X)
}


pl_abs_x_minus_y_eq_z_F(fdv X, fdv Y, fdv Z)

{
 start (c1) X in dom(Y) ++ dom(Z) :
                 dom(Y) -- dom(Z)

 start (c2) Y in dom(X) ++ dom(Z) :
                 dom(X) -- dom(Z)

 start (c3) Z in dom(X) -- dom(Y) :
                 dom(Y) -- dom(X)

 wait_switch
	case min(X) >= max(Y)                             /* case : X >= Y */
		stop c1
		stop c2
		stop c3
		start X in dom(Y) ++ dom(Z)
		start Y in dom(X) -- dom(Z)
		start Z in dom(X) -- dom(Y)

	case min(Y) >= max(X)                             /* case : Y >= X */
		stop c1
		stop c2
		stop c3
		start X in dom(Y) -- dom(Z)
		start Y in dom(X) ++ dom(Z)
		start Z in dom(Y) -- dom(X)
}




pl_abs_x_minus_a_eq_z_F(fdv X, int A, fdv Z)

{
 start (c1) X in dom(Z) + A :
                 { A } -- dom(Z)

 start (c2) Z in dom(X) - A :
                 { A } -- dom(X)

 wait_switch
	case min(X) >= A                                  /* case : X >= A */
		stop c1
		stop c2
		start X in dom(Z) + A
		start Z in dom(X) - A

	case A >= max(X)                                  /* case : A >= X */
		stop c1
		stop c2
		start X in { A } -- dom(Z)
		start Z in { A } -- dom(X)
}




/*-------------------------------------------------------------------------*
 * EUCLIDIAN DIVISION WITH REMAINDER                                       *
 *                                                                         *
 *-------------------------------------------------------------------------*/

/* Compute X // Y = Z with remainder R, i.e X = Z*Y + R */

	/*------------*
	 * Partial AC *
	 *------------*/


pl_quot_rem_x_y_r_eq_z(fdv X, fdv Y, fdv R, fdv Z)            /* X = Z*Y+R */

{
 start Y in min(R)+1 .. max_integer                               /* R < Y */
 start R in 0        .. max(Y)-1

 start Z in (min(X)-max(R)) /> max(Y) .. (max(X)-min(R)) /< min(Y)
 start R in min(X)-(max(Z)*max(Y))    .. max(X)-(min(Z)*min(Y))
 start X in min(Z)*min(Y)+min(R)      .. max(Z)*max(Y)+max(R)

 start Y in (min(X) /< (max(Z)+1))+1..max_integer             /* Y > X/(Z+1) */
 start X in 0..(max(Z)+1)*max(Y)-1

 wait_switch
	case min(Z) > 0
		 start Y in (min(X)-max(R)) /> max(Z)..
                            (max(X)-min(R)) /< min(Z)
}




pl_quot_rem_a_y_r_eq_z(int A, fdv Y, fdv R, fdv Z)            /* A = Z*Y+R */

{
 start Y in min(R)+1 .. max_integer                               /* R < Y */
 start R in 0        .. max(Y)-1

 start Y in (A /< (max(Z)+1))+1..max_integer                  /* Y > A/(Z+1) */

 start Z in (A-max(R)) /> max(Y) .. (A-min(R)) /< min(Y)
 start R in A-(max(Z)*max(Y))    .. A-(min(Z)*min(Y))

 wait_switch
	case min(Z) > 0
		 start Y in (A-max(R)) /> max(Z)..(A-min(R)) /< min(Z)
}




pl_quot_rem_x_a_r_eq_z(fdv X, int A, fdv R, fdv Z)            /* X = Z*A+R */
{
 start R in 0 .. A-1                                              /* R < A */

 start Z in (min(X)-max(R)) /> A .. (max(X)-min(R)) /< A
 start R in min(X)-(max(Z)*A)    .. max(X)-(min(Z)*A)
 start X in min(Z)*A+min(R)      .. max(Z)*A+max(R)

 start X in 0..(max(Z)+1)*A-1                               /* X < (Z+1)*A */
}


	/*------------*
	 *  Full AC   *
	 *------------*/


pl_quot_rem_x_y_r_eq_z_F(fdv X, fdv Y, fdv R, fdv Z)          /* X = Z*Y+R */

{
 start Y in min(R)+1 .. max_integer                               /* R < Y */
 start R in 0        .. max(Y)-1

 start Z in (dom(X)--dom(R))//dom(Y)
 start R in dom(X)--(dom(Z)**dom(Y))
 start X in dom(Z)**dom(Y)++dom(R)

 start Y in (min(X) /< (max(Z)+1))+1..max_integer           /* Y > X/(Z+1) */
 start X in 0..(max(Z)+1)*max(Y)-1

 wait_switch
	case min(Z) > 0
		 start Y in (dom(X)--dom(R)) // dom(Z)
}




pl_quot_rem_a_y_r_eq_z_F(int A, fdv Y, fdv R, fdv Z)          /* A = Z*Y+R */

{
 start Y in min(R)+1 .. max_integer                               /* R < Y */
 start R in 0        .. max(Y)-1

 start Y in (A /< (max(Z)+1))+1..max_integer                /* Y > A/(Z+1) */

 start Z in ({ A }--dom(R))//dom(Y)
 start R in { A }--(dom(Z)**dom(Y))

 wait_switch
	case min(Z) > 0
		 start Y in ({ A }--dom(R)) // dom(Z)
}




pl_quot_rem_x_a_r_eq_z_F(fdv X, int A, fdv R, fdv Z)          /* X = Z*A+R */
{
 start R in 0        .. A-1                                       /* R < A */

 start Z in (dom(X)--dom(R))/A
 start R in dom(X)--(dom(Z)*A)
 start X in (dom(Z)*A)++dom(R)

 start X in 0..(max(Z)+1)*A-1                               /* X < (Z+1)*A */
}
